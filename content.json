{"meta":{"title":"四川小旋风","subtitle":null,"description":null,"author":"ZH","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-12-20T11:23:58.000Z","updated":"2018-12-20T11:26:35.096Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-20T11:23:23.000Z","updated":"2018-12-20T11:26:54.378Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django(五)","slug":"Django-五","date":"2019-03-20T12:47:35.000Z","updated":"2019-03-20T13:04:24.982Z","comments":true,"path":"2019/03/20/Django-五/","link":"","permalink":"http://yoursite.com/2019/03/20/Django-五/","excerpt":"","text":"DjangoRestFrameWork1.安装库pip install djangorestframeworkpip install django-filterpip install markdown 可以不装markdown 2.配置appINSTALLED_APPS = ( ‘’’ ‘rest_framework’,) 3.配置路由urls资源(数据来源):student12345678910111213from rest_framework.routers import SimpleRouter# 声明路由对象router = SimpleRouter()# 注册一个student资源，对应的为StuView类router.register(&apos;student&apos;, views.StuView)urlpatterns = [ &apos;&apos;&apos;]# 将生成的路由添加进django能解析的路由中urlpatterns += router.urls 4.在相应views中操作1234567891011121314151617181920212223242526272829303132333435363738from rest_framework import viewsets,mixins&apos;&apos;&apos;class StuView(Viewsets.GenericViewSet, mixins.ListModelMixin, mixins.RetrieveModelMixin, mixins.DestroyModelMixin, mixins.CreateModelMixin, mixins.UpdateModelMixin):# mixins.ListModelMixin 可查询所有学生列表信息,get请求# mixins.RetrieveModelMixin 继承此类可查询指定id学生的信息,127.0.0.1:8080/user/student/1/，get请求# mixins.DestroyModelMixin 可删除对应学生信息，delete请求# mixins.CreateModelMixin 可创建学生信息，post请求# mixins.UpdateModelMixin 可修改学生信息，put/patch请求# put 修改全部属性，替换# patch 修改某个学生的部分信息 # queryset 不能是其他名字，获取所有的学生信息 # 资源是什么就返回指定资源的内容 queryset = Student.objects.all() # 序列化queryset的结果，转成json数据 # 在对应模块(app)下新建py文件serializers serializer_class = StuSerialier # 此时即可在127.0.0.1:8080/user/student/下查看返回的所有学生json数据 # 展示时过滤掉被删除的学生信息，重构或者直接查询资源时添加限制条件： # queryset=Student.objects.filter(is_delete=0) def get_queryset(self): queryset = self.queryset return queryset.filter(is_delete=0) # 源码是硬删除，一般是软删，需要重构，给student模型添加一个表示是否已删除的bool值字段。数据库也需添加相应字段，0表示未删除，1表示是已删除状态。默认值为0。tinyint def perform_destroy(self, instance): # instance 需要删除的对象 instance.is_delete=1 instance.save() pip uninstall djangorestframeworkpip install djangorestframework有问题可试试更新版本，可看源码127.0.0.1:8080/user/ 可查看user下定义的所有路由 5.序列化文件serializers指定需要序列化哪些字段12345678910111213141516171819from rest_framework import serializers# ModelSerializer 模型序列化class StuSerialier(serializers.ModelSerializer): class Meta: # 指定序列化模型 model = Student # 该模型需要序列化的字段 fields = [&apos;s_name&apos;, &apos;s_gender&apos;, &apos;s_age&apos;] # 修改序列化结果，如性别字段：1 》 男 def to_representation(self, instance): # instance 每个对象 data = super(StuSerializer, self).to_representation(instance) data[&apos;s_gender&apos;] = &apos;男&apos; if data[&apos;s_gender&apos;] else &apos;女&apos; return data","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"","slug":"新建文本文档","date":"2019-01-10T01:34:42.237Z","updated":"2019-01-11T13:58:41.913Z","comments":true,"path":"2019/01/10/新建文本文档/","link":"","permalink":"http://yoursite.com/2019/01/10/新建文本文档/","excerpt":"","text":"serializers1.在对应应用的路由文件中进行操作 导包： 1from rest_framework.routers import SimpleRouter 声明一个路由对象： 1router = SimpleRouter 在路由中注册一个名为student(自己资源的名字)的资源，不用加斜杠 1router.register('student', views.StuView) 向路由地址中添加生成的路由地址 1urlpatterns += router.urls 2.在对应应用目录下新建一个python文件 导包： 123from rest_framework import serializers# 导入对应模型from app.models import Student 创建类： 123456789101112131415161718192021class StuSerializer(serializers.ModelSerializer): class Meta: # 序列化模型 model = Student fields = ['s_name', 's_gender', 's_age'] # instance是要序列化的字段,重构，设置需要的返回内容 def to_representation(self, instance): data = super(StuSerializer, self).to_representation(instance) # data = &#123; # \"s_name\": \"小花1\", # \"s_gender\": False, # \"s_age\": 20 # &#125; data['s_gender'] = '男' if data['s_gender'] else '女' # 设置后 # data = &#123; # \"s_name\": \"小花1\", # \"s_gender\": \"女\", # \"s_age\": 20 # &#125;, return data 3.在应用文件中创建对应的类123456789101112131415161718192021222324252627282930# mixins.RetrieveModelMixin设置通过路由后添加id查询指定学生# mixins.ListModelMixin查看所有学生# mixins.DestroyModelMixin设置可依据id删除指定学生权限class StuView(viewsets.GenericViewSet, # 查看所有资源,GET mixins.ListModelMixin, # 查看指定id资源,GET mixins.RetrieveModelMixin, # 删除指定资源，硬删除，DELETE mixins.DestroyModelMixin, # 创建资源，POST mixins.CreateModelMixin, # 修改资源，PUT/PATCH(修改单个) mixins.UpdateModelMixin): # 指定资源返回的内容,要和路由设置匹配 # 过滤掉被删除的学生信息,法1 # queryset = Student.objects.filter(is_delete=0) queryset = Student.objects.all() # 序列化queryset的结果,建一个py文件，此处名为serializers可自定义 # pip uninstall djangorestframework 报错卸载重安 serializer_class = StuSerializer # 查询所有信息时，过滤掉被删除的学生信息，法2，重构 def get_queryset(self): queryset = self.queryset return queryset.filter(is_delete=0) def perform_destroy(self, instance): # 删除就把is_delete数据改为1,软删，查询时可过滤 instance.is_delete = 1 instance.save()","categories":[],"tags":[]},{"title":"Django（四）","slug":"Django（四）","date":"2019-01-04T13:57:41.000Z","updated":"2019-01-04T14:41:28.967Z","comments":true,"path":"2019/01/04/Django（四）/","link":"","permalink":"http://yoursite.com/2019/01/04/Django（四）/","excerpt":"","text":"解析模板文件位置 在settings.py文件中定义TEMPALTES的目录地址 os.path.join(BASE_DIR, ‘templates’)temlates文件创建在项目主目录下 12345678910111213141516TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 修改此处地址为相应目录 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 后端渲染模板 使用render()渲染模板 传递参数给模板(写在视图文件中)render(request, 模板名, {key1:value1,key2:value2}) 123def index(request): stus = Student.objects.all() return render(request, 'index.html', &#123;'a': stus&#125;) 前端渲染数据12解析变量：&#123;&#123; 变量 &#125;&#125;解析标签：&#123;% 标签 %&#125;&#123;% end标签 %&#125; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;今天天气真好。。。&lt;/p&gt; &#123;&#123; a &#125;&#125;&lt;hr&gt; &#123;% for stu in a %&#125; &lt;p&gt; 姓名：&#123;&#123; stu.s_name &#125;&#125; 年龄：&#123;&#123; stu.s_age &#125;&#125; 班级：&#123;&#123; stu.g.g_name &#125;&#125; 选课： &#123;% for c in stu.cou.all %&#125; &#123;&#123; c.c_name &#125;&#125; &#123;% endfor %&#125; &lt;P/&gt; &#123;% endfor %&#125;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Djang（三）","slug":"Djang（三）","date":"2019-01-04T03:52:35.000Z","updated":"2019-01-04T11:50:48.452Z","comments":true,"path":"2019/01/04/Djang（三）/","link":"","permalink":"http://yoursite.com/2019/01/04/Djang（三）/","excerpt":"","text":"迁移表名的定义指定db_table参数，表示模型迁移时，映射到数据库中的表的名称1234class Meta: # 指定模型和表的关系 # 设置好后，表名即为student db_table = 'student' 如果没有指定db_table参数则以：该模型所在应用的名字_模型名字小写 来命名： 不设置时，表名：myapp_student 字段类型CharField:字符串类型，需要设置长度IntwgerField：整数型ImageField：字符串类型，用于保存图片BolleanField：布尔，True，FalseDateTimeField：年月日时分秒DateField：年月日TextField：存储长文本内容，areatext标签，不用限制长度FloatField:浮点类型DecimalField：浮点类型，限制最大长度和小数点后的长度 约束unique：是否唯一default：设置默认null：是否为空primarry_key：主键auto_now_add:创建时，默认赋值为当前时间auto_now：创建或修改时，默认设置为当前时间max_length:最大长度related_name：反向查询名称on_delete:删除主数据表时对从表的约束 on_delete = models.CASCADE 默认值，删除主表数据，对应的从表数据也会被删除on_delete = models.PROTECT，不能删除主表，但能删除从表on_delete = models.SET_NULL（前提是设置外键可为空null=True），删除主表数据时，不会删除从表数据但会将相应的外键设置为空 一对一，1：1 存储 关联字段存储1：stu_info.关联字段=关联对象 stu_info.stu = Student.objects.get(id=9) 关联字段存储2: stu_info.关联字段_id = 主键id值 stu_info.stu_id = 9 查询 模型定义；学生模型和学生拓展模型的定义；1：1 123456789101112131415161718192021222324252627 class Student(models.Model): # 定义姓名字段，类型为字符串，最大长度10，唯一 s_name = models.CharField(max_length=10, unique=True) # 默认20 s_age = models.IntegerField(default=20) s_gender = models.BooleanField(default=0) # auto_now_add=True:创建时，默认字段赋值为最新的时间 creat_time = models.DateTimeField(auto_now_add=True) # creat_time = models.DateField 没有时分秒 # auto_now=True:修改数据时，自动赋值为更新字段时的时间 update_time = models.DateTimeField(auto_now=True) # 限制小数后位数的浮点数 math = models.DecimalField(max_digits=3, decimal_places=1, null=True) wuli = models.DecimalField(max_digits=3, decimal_places=1, null=True) class Meta: # 指定模型和表的关系 db_table = 'student'class StudentInfo(models.Model): s_no = models.CharField(max_length=10, null=False) phone = models.CharField(max_length=11, null=True) name = models.CharField(max_length=10, null=True) # 与学生表1：1；定义一对一的关联关系 # on_delete 设置删除时主外键的变化 stu = models.OneToOneField(Student, on_delete=models.CASCADE) 查询1,没设置related_name参数时 学生对象查询拓展表对象: 学生对象.拓展模型名称的小写 stu_info = stu.studentinfo 拓展表对象查询学生对象: 拓展表对象.OneToOneField定义的字段 stu = stu_info.stu 查询2, 设置related_name参数时 学生对象查询拓展表对象: 对象对象.related_name参数 123# 定义了别名info之后只能用别名# related_name='info'，模型文件中stu_info = stu.info 拓展表对象查询学生对象: 拓展表对象.OneToOneField定义的字段 12345678def sel_stu_by_info(request): # 1.查看拓展信息 stu_info = StudentInfo.objects.filter(s_no='1212321421').first() # 2.查询学生对象 stu = stu_info.stu print(stu.s_name) # 老王 return HttpResponse('查询成功：%s' % stu.s_name) 定义模型 OneToOneField: 定义在关联模型的任何一方都可以 一对多，1：N 存储 关联字段的存储1：stu.关系字段=关联模型对象 stu.g = Grade.objects.get(pk=4).first() 关联字段的存储2:stu.关系字段_id=关联表的主键id值 stu.g_id = 4 查询 模型定义； 123456789101112131415161718192021222324252627282930class Grade(models.Model): g_name = models.CharField(max_length=10, unique=True) class Meta: db_table = 'grade'class Student(models.Model): # 定义姓名字段，类型为字符串，最大长度10，唯一 s_name = models.CharField(max_length=10, unique=True) # 默认20 s_age = models.IntegerField(default=20) s_gender = models.BooleanField(default=0) # auto_now_add=True:创建时，默认字段赋值为最新的时间 creat_time = models.DateTimeField(auto_now_add=True) # creat_time = models.DateField 没有时分秒 # auto_now=True:修改数据时，自动赋值为更新字段时的时间 update_time = models.DateTimeField(auto_now=True) # 限制小数后位数的浮点数 math = models.DecimalField(max_digits=3, decimal_places=1, null=True) wuli = models.DecimalField(max_digits=3, decimal_places=1, null=True) # 一对多的外键定义 g = models.ForeignKey( Grade, null=True, on_delete=models.CASCADE, related_name='stu' ) class Meta: # 指定模型和表的关系 db_table = 'student' 查询1,没设置related_name参数时 学生查询班级:多的一方(学生)对象.关联字段 1234567def sel_grade_by_stu(request): # 1.查询名字为小花3的学生对象 stu = Student.objects.filter(s_name='小花3').first() grade = stu.g print(grade.g_name) # Python1804 return HttpResponse('查询成功') 班级查询学生：1的一方(班级)对象.关联模型名的小写_set.fliter().all() 123456789def sel_stu_by_grade(request): # 查询班级Python1804 grade = Grade.objects.filter(g_name='Python1804').first() # 下方获取到的是一个查询集，还能使用filter等过滤，加.all即为查看集合 stus = grade.student_set.all() # 设置了外键related_name='stu'后上面代码会报错 # stus = grade.stu.all() print(stus) return HttpResponse('查询成功') 查询2, 设置related_name参数时 学生查询班级:多的一方(学生)对象.关联字段 1234567def sel_grade_by_stu(request): # 1.查询名字为小花3的学生对象 stu = Student.objects.filter(s_name='小花3').first() grade = stu.g print(grade.g_name) # Python1804 return HttpResponse('查询成功') 班级查询学生：1的一方(班级).ForeignKey定义的字段.fliter().all() 123456789def sel_stu_by_grade(request): # 查询班级Python1804 grade = Grade.objects.filter(g_name='Python1804').first() # 下方获取到的是一个查询集，还能使用filter等过滤，加.all即为查看集合 # stus = grade.student_set.all() # 设置了外键related_name='stu'后上面代码会报错 stus = grade.stu.all() print(stus) return HttpResponse('查询成功') 定义模型 ForeignKey：必须定义在多的一方 多对多，N：M 存储同一对多 查询 模型定义； 1234567891011121314151617181920212223242526class Student(models.Model): # 定义姓名字段，类型为字符串，最大长度10，唯一 s_name = models.CharField(max_length=10, unique=True) # 默认20 s_age = models.IntegerField(default=20) s_gender = models.BooleanField(default=0) # auto_now_add=True:创建时，默认字段赋值为最新的时间 creat_time = models.DateTimeField(auto_now_add=True) # creat_time = models.DateField 没有时分秒 # auto_now=True:修改数据时，自动赋值为更新字段时的时间 update_time = models.DateTimeField(auto_now=True) # 限制小数后位数的浮点数 math = models.DecimalField(max_digits=3, decimal_places=1, null=True) wuli = models.DecimalField(max_digits=3, decimal_places=1, null=True) class Meta: # 指定模型和表的关系 db_table = 'student'class Course(models.Model): c_name = models.CharField(max_length=10, unique=True) # ManyToManyField字段可以定义在任何一个模型中 stu = models.ManyToManyField(Student, null=True, related_name='cou') class Meta: db_table = 'course' 查询1,没设置related_name参数时 课程查询学生:课程对象.关联字段.filter().all() 123456789def add_s_c(request): # 将大学英语分配给小花 # 1.查询课程对象 cou = Course.objects.filter(c_name='商务英语').first() # 2.查询学生对像 stu1 = Student.objects.filter(s_name='小花').first() # 3.找到小花选了哪些课的集，在向其中加入新选的课程 # 加入关联关系 cou.stu.add(stu1) return HttpResponse('添加中间表信息成功') 学生查询课程：学生对象.关联模型名的小写_set.filter().all() 12345678910def add_s_c(request): # 将大学英语分配给小花 # 1.查询课程对象 cou = Course.objects.filter(c_name='商务英语').first() # 2.查询学生对像 stu1 = Student.objects.filter(s_name='小花').first() # 3.找到小花选了哪些课的集，在向其中加入新选的课程 # 加入关联关系 stu1.course_set.add(cou) return HttpResponse('添加中间表信息成功') 查询2, 设置related_name参数时 课程查询学生:课程对象.关联字段.filter().all() 12345678def add_s_c(request): # 将大学英语分配给小花 # 1.查询课程对象 cou1 = Course.objects.filter(c_name='商务英语').first() # 2.查询学生对像 stu1 = Student.objects.filter(s_name='小花').first() cou1.stu.add(stu1) return HttpResponse('添加中间表信息成功') 学生查询课程：学生对象.related_name参数.filter().all() 12345678910def add_s_c(request): # 将大学英语分配给小花 # 1.查询课程对象 cou1 = Course.objects.filter(c_name='商务英语').first() # 2.查询学生对像 stu1 = Student.objects.filter(s_name='小花').first() # 3.找到小花选了哪些课的集，在向其中加入新选的课程 # 加入关联关系 stu1.cou.add(cou1) return HttpResponse('添加中间表信息成功') 定义模型 ManyToMany：定义在模型任意一方都可以","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Django（二）","slug":"Django（二）","date":"2019-01-03T04:26:05.000Z","updated":"2019-01-04T13:56:06.720Z","comments":true,"path":"2019/01/03/Django（二）/","link":"","permalink":"http://yoursite.com/2019/01/03/Django（二）/","excerpt":"","text":"概念ORM(objects relationship mapping):对象关系映射管理器：objects；默认模型的属性 创建法1： create()方法 模型名.objects.create(字段1=值1，字段2=值2) 法2： save()方法 模型对象.save() 例：1234567891011def add_stu(request): # 会自动映射成SQL语句 # 实现插入数据,实现的第一种方式 # Student.objects.create(s_name='小明') # 实现的第二种方法 # 拿到学生对象，再赋值 stu = Student() stu.s_name = '小花' stu.s_gender = 1 stu.save() return HttpResponse('创建学生成功') 删除 delete()方法 模型名.objects.filter(条件).delete() 例：123456def del_stu(request): # 实现删除 # 1.获取满足条件的删除对象，filter(条件) # 2.实现删除方法 Student.objects.filter(id=1).delete() return HttpResponse('删除学生成功') 修改 update()方法 模型名.objects.filter(条件).update(字段1=值1,字段2=值2) save()方法 模型对象.save() update()和save()的区别：是否能更新使用auto_now约束条件的字段，update()方法不能更新该类字段，save()方法可以。例：12345678910111213def up_stu(request): # 实现更新 # 1.获取符合条件的数据，filter(条件) # 2.实现更新方法，update() # 更新的第一种方法，不能更新使用auto_now约束条件的字段 # Student.objects.filter(id=9).update(s_name='小王') # 更新的第二种方法 # first才能取出对象，才能用stu使用对象属性 stu = Student.objects.filter(id=9).first() stu.s_name = '老王' # save方法是更新字段，会自动修改更新时间 stu.save() return HttpResponse('更新学生成功') 查询基础查询 filter(条件)方法：查询满足条件的数据 模型名.objects.filter(条件) all()方法：查询所有 模型名.objects.all() 例：1234567def sel_stu(request): # 查询学生信息 # 查询所有的学生信息,all()取出所有的学生对象 stus = Student.objects.all() for stu in stus: print(stu.s_name) return HttpResponse('查询学生成功') get(条件)方法：查询满足条件的数据 模型名.objects.get(条件)get()方法只能返回唯一的一个结果；条件必须成立；两者任意一条不满足都会报错。 first()方法:取出结果中的第一个对象 模型名.objects.filter(条件).first() 例：12345678910111213def sel_stu(request): # 查询id=5的学生信息，filter() stu = Student.objects.filter(id=12).first() # 条件不满足时返回的是空的QuerySet print(stu) # 不加.first()的结果是一个对象集 # 加.first()的结果：Student object (12) 为取出的对象 stu = Student.objects.get(id=12) # 1.get()只能取唯一的一个对象 # 2.get(条件)；条件必须成立，不成立会报错 print(stu) # Student object (12) return HttpResponse('查询学生成功') exclude()方法:查询出不满足条件的信息 模型名.objects.exclude(条件) 例：1234567def sel_stu(request): stus1 = Student.objects.filter(s_gender=0) # 过滤出不满足条件的信息 stus2 = Student.objects.exclude(s_gender=1) print(stus1 == stus2) # True return HttpResponse('查询学生成功') oder_by()方法：升序order_by(‘id’);降序order_by(‘-id’) 模型名.objects.order_by(‘id’)模型名.objects.order_by(‘-id’) 例：1234567891011def sel_stu(request): # 排序order_by # 升序 stus = Student.objects.order_by('id') print(stus) # &lt;QuerySet[&lt;Student: Student object (1)&gt;, &lt;Student: Student object (2)&gt;]&gt; # 降序 stus = Student.objects.order_by('-id') print(stus) # &lt;QuerySet[&lt;Student: Student object (2)&gt;, &lt;Student: Student object (1)&gt;]&gt; return HttpResponse('查询学生成功') values()方法：获取查询对象中的字段，获取元素时效率更高 模型名.objects.all().values(‘属性名’)：获取所有对象的指定属性对应的值，以类似list1[dict1，dict2]的形式展现，dict的键就是相应属性名，值是属性值。 模型名.objects.all().values():获取所有对象的属性和对应的值，以类似list1[dict1，dict2]的形式展现，dict的键就是相应属性名，值是属性值。 例：123456789def sel_stu(request): # 取出对象中的某个字段 stus = Student.objects.all().values('s_name') # 取出所有对象的所有字段 stus1 = Student.objects.all().values() print(stus) # &lt;QuerySet[&#123;'s_name': '小花'&#125;, &#123;'s_name': '小花2'&#125;, &#123;'s_name': '老王'&#125;]&gt; print(stus1) return HttpResponse('查询学生成功') exists()方法：判断结果是否存在，存在返回True，否则返回False 模型名.objects.filter(条件).exists() 例：123456def sel_stu(request): # 判断查询结果是否存在 bool = Student.objects.filter(s_name='小张').exists() print(bool) # False return HttpResponse('查询学生成功') count()方法：计算结果的条数;等价于len(结果语句) 模型名.objects.filter(条件).count() 例：123456def sel_stu(request): stus = Student.objects.filter(s_gender=0) num = Student.objects.filter(s_gender=0).count() print(len(stus) == num) # True return HttpResponse('查询学生成功') 运算符语法：字段__运算符 contains:模糊查询，表示只要包含该字段就满足条件 模型名.objects.filter(字段__contains=’值’) 例：1234# contains：模糊查询，表示只要包含该字段就满足条件# 语法：字段__运算符;运算符有contains等# 找出名字中含有‘小花’的所有对象stus = Student.objects.filter(s_name__contains='小花') startswith:以什么开头 模型名.objects.filter(字段__startswith=’值’) endswith：以什么结尾 模型名.objects.filter(字段__endswith=’值’) 例：123456# like： '小%' '明%'# startswith endswith# 找出名字中以‘小’开头的所有对象stus = Student.objects.filter(s_name__startswith='小')# 找出名字中以‘花’结尾的所有对象stus = Student.objects.filter(s_name__endswith='花') in：在某个范围 模型名.objects.filter(字段__in=[列表]) 例：123456# SQL where id in (1,2,3,4,5,6,7)# 查询id在1-10的对象stus_i = Student.objects.filter(id__in=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])# pk:primary key 主键stus_p = Student.objects.filter(pk__in=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10])# 此处id即为主键pk gt,gte：大于；大于等于 模型名.objects.filter(字段__gt=值) lt,lte：小于；小于等于 模型名.objects.filter(字段__lt=值) 例：12345# gte:大于等于 gt：大于,greater than lte:小于等于 lt：小于# 两种都可以，写一起表示‘且’# 年龄大于等于18小于20stus1 = Student.objects.filter(s_age__gte=18, s_age__lt=20)stus2 = Student.objects.filter(s_age__gte=18).filter(s_age__lt=20) Q逻辑运算符 与1：Q(条件1),Q(条件2)与2：Q(条件1) &amp; Q(条件2)或：Q(条件1) | Q(条件2)非：~Q(条件1) 模型名.objects.filter(逻辑条件) 例：123456789# 查询年龄大于等于18且小于20的学生stus1 = Student.objects.filter(s_age__gte=18, s_age__lt=20)# 查询年龄大于等于18或小于20,语法：Student.objects.filter(Q(过滤条件1) | Q(过滤条件2))，表示‘或者’# 或stus2 = Student.objects.filter(Q(s_age__gte=18) | Q(s_age__lt=20))# 且stus3 = Student.objects.filter(Q(s_age__gte=18) &amp; Q(s_age__lt=20))# 取反stus4 = Student.objects.filter(~Q(s_age__gte=18)) 聚合函数语法：模型名.objects.all().aggregate(聚合函数(字段))使用前需要导包：from django.db.models import Max, Avg, Min, Sun, Count F()函数，匹配两个字段用于比较俩个字段，可使用+，-符号语法：模型名.objects.filter(字段1=F(字段2))例：12345678# 查询物理成绩大于数学成绩的学生stus = Student.objects.all()for stu in stus: if(stu.wuli &gt; stu.math): print(stu.s_name)# F()函数，匹配俩个字段# 物理成绩至少超过数学成绩10分的学生stus = Student.objects.filter(wuli__gt=F('math')+10) 注：文中例子均在Django（一）的配置前提下进行,在视图文件中添加方法，在路由文件中添加相应路由","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"web前端+Linux+Vim","slug":"web前端-Linux-Vim","date":"2019-01-02T15:33:52.000Z","updated":"2019-01-02T15:44:03.096Z","comments":true,"path":"2019/01/02/web前端-Linux-Vim/","link":"","permalink":"http://yoursite.com/2019/01/02/web前端-Linux-Vim/","excerpt":"","text":"Web前端HTML标签 - 承载内容 - contentCSS - 渲染页面 - display 选择器 通配符选择器：* 标签选择器：标签名 类选择器：.+类名；如：.class ID选择器：#+id；id不能是数字 属性选择器 后代选择器 / 父子选择器 兄弟选择器 / 相邻兄弟选择器 伪类 / 伪元素 就近原则/具体性原则/重要性原则 盒子模型（内容-padding-border-背景图-背景色-margin） 常用样式属性和常用属性值 JavaScript - 交互行为 - behavior 语法规范 - ECMAScript BOM - 浏览器对象模型 - window DOM - 文档对象模型 - document getElementById() / getElementsByTagName() / getElementsByClassName() / querySelector() / querySelectorAll() createElement() / appendChild() / insertBefore() removeChild() innerHTML / textContent / className / style parentNode / children / prevSibling / nextSibling addEventListener / removeEventListener jQuery —&gt; window.$ / window.jQuery $(‘样式表选择器’)：获取页面元素返回jQuery对象 $(‘&lt;标签&gt;’)：创建新元素得到jQuery对象 $(原生JavaScript对象)：将原生JS对象转成jQuery对象 $(function() {})：绑定页面加载完成之后要执行的回调函数 Linux文件操作命令： pwd - print working directory cd - change directory ls - list directory contents -a - all -l - long -R - recursive mkdir - make directory rmdir - remove empty directory touch cp - copy rm - remove mv - move less / more / head / tail cat - concatenate uniq / sort / cut / wc / diff find / grep ps -ef / ps -aux netstat -nap ifconfig / ip top / sar scp / sftp / ssh Linux安装软件和配置服务： 包管理工具 - yum / rpm / apt / deb 源代码构建安装 wget gunzip / xz -d tar -xvf make &amp;&amp; make install ln -s 源 目标 systemctl - start / stop / restart / status / enable / disable service firewalld / iptables - 防火墙 Vim命令模式 –i/a–&gt; 插入模式（编辑模式） –Esc–&gt; 命令模式命令模式 –:?/–&gt; 末行模式 –Enter–&gt; 命令模式Ctrl+e / Ctrl+y - 滚动一行Ctrl+f / Ctrl+b - 滚动一页gg - 到首行G - 到末行100G - 到100行hjkl - 左下上右移动光标$ - 光标到行尾^ - 光标到行首dd / dw / d0 / d$ - 删除yy / p - 复制 / 黏贴u / Ctrl+r - 撤销 / 恢复ZZ / :wq - 保存退出 - ! - 强制操作 /搜索内容（正则） - 查找 -n / N - 向下/上搜索?搜索内容（正则） - 查找:1,$s/搜索的内容（正则）/替换后的内容/ice - 查找替换 版本比较 - vim -d 文件1 文件2多文件查看 - vim 文件1 文件2 文件3:ls - 查看文件:b - 切换文件:sp / :vs - 拆分窗口Ctrl+w Ctrl+w - 切换窗口 配置vim —&gt; ~/.vimrc1234567set nuset ts=4set expandtabset autoindentset nohlssyntax onset ruler","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Django(一)","slug":"Django（一）","date":"2019-01-02T08:41:55.000Z","updated":"2019-01-03T04:24:55.639Z","comments":true,"path":"2019/01/02/Django（一）/","link":"","permalink":"http://yoursite.com/2019/01/02/Django（一）/","excerpt":"","text":"Django虚拟环境1.安装(cmd)：pip install virtualenv2.使用：virtualenv --no-site-packages -p 自己python解释器的绝对路径 name(设置本环境名字)注意:创建前需切换到自己建立的用于存储环境设置的文件夹目录下，下面路径中的env是我的环境目录123--no-site-packages:表示创建的虚拟环境为纯净的环境，未安装有其他的库-p:表示虚拟环境中的python版本 3.pip使用 pip list:查看安装的库pip install xxx:安装xxx库 4.激活虚拟环境 windows中：直接执行activate命令注：找到activate文件目录后执行，如：D:\\python\\django\\env\\djenv8\\ScriptsMac/Linux/ubuntu中：直接执行source activate命令注：激活环境后需在当前环境中配置Django如：在名为djenv8(我自己设置的环境名称)的虚拟环境下安装django(djenv8) D:\\python\\django\\env\\djenv8\\Scripts&gt;pip install Django 5.退出虚拟环境 直接执行deactivate指令 Django项目注：以下命令均在虚拟环境中输入，若要查看文件可用pycharm打开1.创建：django-admin startproject 项目名称 最好自己创建一个专门存放项目的文件夹，在其中创建以上项目 2.启动 启动命令：python manage.py runserver 默认IP为127.0.0.1 默认端口为8000修改启动端口：python manage.py runserver 端口修改IP和端口：python manage.py runserver IP:端口IP参数：如果为0.0.0.0表示任何人都可以通过公网IP访问此Django项目端口PORT参数：如果端口设置为80，表示该端口可以不写 上图为pycharm中设置自启动方法，设置好后可不用输入启动命令来启动。 数据库准备工作(此处为MySQL)1.在setting.py中配置 USER参数：访问用户(一般为root，即superuser)PASSWORD参数：密码HOST参数：访问数据库的地址PORT参数：访问数据库的端口(mysql为3306)NAME参数：要访问的数据库名‘OPTIONS’:{‘isolation_level’:None} 如果报错说数据库版本低，则加上此句，不报错则不加 具体如下：12345678910DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'dj8', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': 3306 &#125;&#125; 2.安装pymysql 用pymysql连接数据库：因为python3没有MySQLdb驱动，无法直接连接MySQL须在工程目录的__init__.py文件中定义pymysql.install_as_MySQLdb() 3.迁移 第一次迁移：python manage.py migrate除开第一次迁移：（先建立自己的应用及模型,方法见下文） 生成迁移文件：python manage.py makemigrations执行迁移文件：python manage.py migrate 4.插入管理员账号 python manage.py createsuperuser Django模式 MVT/MTV模式 M：模型层 - 定义模型和数据库中的表之间的关联关系V：视图层 - 定义业务逻辑T：模板 - HTML页面 MVT模式是由MVC模式演变出来的，MVC模式是所有的框架遵循的模式 MVC模式 M：模型层V：模板，HTML页面C(controller)：控制器，写业务逻辑的地方 补：创建应用(app)：在虚拟环境(Terminal)中工程目录下输入创建命令：python manage.py startapp 自己设置的名字，如： (djenv8)D:\\python\\django\\wordspace\\8.django\\day01&gt;python manage.py startapp myapp 在创建好的应用目录下，我们需要关注的有models.py(M)和views.py(V)文件自定义模型：先在models.py文件中建立数据表的模型然后迁移进数据库，注意要在项目的setting.py(设置文件)中的INSTALLED_APPS条目中添加上自己的app(应用)的名字：在models.py文件中建一个简单的学生数据模型：python manage.py makemigrations 生成相应的迁移文件，结果如下：python manage.py migrate 执行迁移文件，迁移至数据库中结果如下：","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Redis数据库基本操作","slug":"Redis数据库基本操作","date":"2018-12-31T07:55:02.000Z","updated":"2018-12-31T09:01:52.659Z","comments":true,"path":"2018/12/31/Redis数据库基本操作/","link":"","permalink":"http://yoursite.com/2018/12/31/Redis数据库基本操作/","excerpt":"","text":"基础指令auth - 验证身份ping - 心跳事件set - 设置键值对get - 取值expire - 设置超时时间del - 删除键keys - 查看键exists - 判断键是否存在 flushdb - 清空当前数据库flushall - 清空所有库select - 切换底层数据库 save - 手动保存，会有阻塞bgsave - 手动后台保存，不阻塞shutdown - 关闭服务器quit - 退出dbsize - 查看当前数据库有多少组键值对incrincrbyincrbyfloat Redis提供了两种持久化数据的方案： RDB - 默认开启，rdb文件 AOF - 默认关闭；打开方式：–appendonly yes，aof文件 注意：默认redis16个库，编号0-15，可通过 select+数字 切换不同的数据库 若要查询更多Redis相关指令请点击下方链接：redis指令 set username hellokitty px 1500 mget user1 user2 setex setnx user1 43345 分布式锁，已有则不能放进去 getset user1 123 先拿到user1的值再改为123 append user1 333 strlen user1 setbit foo 128 1 最多51210241024*8个比特，将128比特设置为1 getbit foo 128 得出1 type key 查询键对应值的数据类型 object encoding key 底层数据类型 哈希表哈希表：适合保存对象一个键对应一个字典hset stu1 stuid 1001 hget stu1 name 获取key为stu1下键为name对应的值 hgetall stu1 获取stu1下所有的键值对 hvals stu1 hmset stu2 id 1002 name 12123 addr 333 一次放入多个键值对 hmget stu2 name addr 获取多个键对应的值 hdel stu2 addr 删除哈希stu2中的addr字段 lpush list1 100 200 300 400 500 左输入 lrange list1 0 -1 lpop list1 弹出list1左边第1个数据 栈（stack） - FILO 先进后出 first in last out 递归，就是栈原理1234567def f(num): if num in (0,1): return 1 return num * f(num - 1) f(5)# 实现步骤就是依次将5*f(4)、4*f(3)...1放入栈中，先进后出来计算。 队列（queue）- FIFO 先进先出 redis的list类型 - 经典的数据存储结构：栈（stack） - FILO 先进后出 first in last out lpush + lpop / rpush + rpop 队列（queue）- FIFO 先进先出 lpush + rpop / rpush + lpop brpop list2 5 如果列表中没有元素则等5秒取值，在5秒钟放进数据也能获取。 blpop 集合普通集合sadd set1 100 200 100 200 100smembers set1sinter set1 set2sunion set1 set2sdiff set1 set2sdiff set2 set1sismember set1 200 查询spop set1 弹出scard set1 查看数据个数srandmember set1 2 随机查看两个数据，如果没2个则打印全部 zset有序集合(动态排行榜):zadd paihangbang 100 yuting 200 wanghaifei 50 ZHzrange paihangbang 0 -1 按值正序zrevrange paihangbang 0 -1 倒序zincrby paihangbang 20000 yuting 增加 Redis主从复制读写分离结构slaveof 120.77.222.217 6379 (给120.77.222.217奴隶机masterauth 主机密码) 主机启动redis：redis-server –requirepass 123123 &gt; redis.log 2&gt; redis-error.log &amp;从机启动redis：redis-server –slaveof 主机地址 6379 –masterauth 主机密码&gt; redis.log 2&gt; redis-error.log &amp; info replication 查看自己的主从关系 slaveof no one 退出奴隶 故障切换，哨兵模式启动哨兵关注master，哨兵有票","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"python运行Django项目","slug":"python运行Django项目","date":"2018-12-31T07:43:02.000Z","updated":"2018-12-31T08:23:24.362Z","comments":true,"path":"2018/12/31/python运行Django项目/","link":"","permalink":"http://yoursite.com/2018/12/31/python运行Django项目/","excerpt":"","text":"PyCharm环境搭建 通过PyCharm创建Python项目 —&gt; hellodjango(自己命名) 在Terminal的虚拟环境中安装依赖项 pip install django pymysql django-redis djangorestframework pillow pip check - 检查是否兼容 pip freeze - 查看当前虚拟环境所有的依赖项版本 pip freeze &gt; requirements.txt - 将所有的版本信息重定向到requirements.txt文件中 相关设置 创建Django项目django-admin startproject hellodjango . （在当前目录下开始名为hellodjango的django项目） 运行项目 python manage.py runserver - 启动服务器，默认8000端口 123# 本地查看地址http://localhost:8000http://127.0.0.1:8000 python manage.py runserver 0.0.0.0:80 - 启动服务器，接入80端口，让局域网内部也能访问12345# 本地查看地址http://localhosthttp://127.0.0.1# 局域网查看地址（为本机ip）http://10.7.187.140 修改配置文件 —&gt; hellodjango/settings.py 12345678910111213LANGUAGE_CODE = &apos;zh-hans&apos;TIME_ZONE = &apos;Asia/Chongqing&apos;DATABASES = &#123; &apos;default&apos;: &#123; &apos;BACKEND&apos;: &apos;....mysql&apos;, &apos;NAME&apos;: &apos;&apos; &apos;HOST&apos;: &apos;&apos;, &apos;PORT&apos;: 3306, &apos;USER&apos;: &apos;&apos;, &apos;PASSWORD&apos;: &apos;&apos;, &apos;TIME_ZONE&apos;: &apos;Asia/Chongqing&apos;, &#125;&#125; 修改__init__.py文件,添加以下内容import pymysqlpymysql.install_as_MySQLdb() 生成Django自带的数据表（在Terminal中输入）python manage.py migrate 创建后台管理员账号（在Terminal中输入）python manage.py createsuperuser Unix - BSD - FreeBSD - Macintosh - macOS - iOSUnix - MINIX - Linux - AndroidUnix - AIX / HP-UX / Solaris Django / Flask / Tornado","categories":[],"tags":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"参考资料及一些好用的网站","slug":"参考资料网站","date":"2018-12-27T10:56:36.000Z","updated":"2019-01-11T09:44:33.314Z","comments":true,"path":"2018/12/27/参考资料网站/","link":"","permalink":"http://yoursite.com/2018/12/27/参考资料网站/","excerpt":"","text":"redis数据库命令学习 : http://redisdoc.com/ 模拟分析Python执行过程: http://pythontutor.com/visualize.html#mode=edit python题库:领扣: https://leetcode-cn.com/problemset/all/ 前端框架: http://www.bootcss.com/ 虚拟接口网站: http://rap2.taobao.org/ 虚拟接口用法: http://mockjs.com/ 玩转Linux操作系统: https://github.com/jackfrued/Python-100-Days/blob/master/Day31-35/%E7%8E%A9%E8%BD%ACLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.md 数据库问题查找解决方法: https://stackoverflow.com/ tornado学习网站 http://demo.pythoner.com/itt2zh/ch1.html 权限控制（Django） https://github.com/coco369/knowledge/blob/master/django Djangorestframework https://github.com/coco369/knowledge/blob/master/django/djangorestframework%E6%80%BB%E7%BB%93.md","categories":[{"name":"参考资料","slug":"参考资料","permalink":"http://yoursite.com/categories/参考资料/"}],"tags":[{"name":"参考资料","slug":"参考资料","permalink":"http://yoursite.com/tags/参考资料/"},{"name":"好用的网站","slug":"好用的网站","permalink":"http://yoursite.com/tags/好用的网站/"}]},{"title":"数据库","slug":"数据库","date":"2018-12-25T14:26:01.000Z","updated":"2019-01-02T15:54:05.577Z","comments":true,"path":"2018/12/25/数据库/","link":"","permalink":"http://yoursite.com/2018/12/25/数据库/","excerpt":"","text":"数据库安装数据库 - 实现项目中数据持久化 数据库类别： 关系型数据库 - MySQL NoSQL数据库 - Redis 关系型数据库 - MySQL 特点： 1.理论基础：集合论和关系代数 2.用二维表组织数据(一行就是一条记录，一列就是一个字段) 3.SQL - 结构化查询语言DDL - 数据定义语言 - create / drop / alter DML - 数据操作语言 - insert / delete / update / select DCL - 数据控制语言 - grant / revoke / commit / rollback 关系型数据库可以保证数据的完整性： 实体完整性：每条记录都是独一无二的，没有冗余。（主键/唯一索引）参照完整性：外键域完整性：数据类型、非空约束、默认值约束、检查约束。 Linux安装数据库首先创建虚拟化容器：Docker Docker - 虚拟化服务，创建虚拟化容器并安装软件（用于安装MyDQL） yum -y install docker-io 服务器安装docker的命令 yum -y remove docker-io 服务器删除docker的命令 yum info docker-io 服务器查看docker-io信息的命令 yum search docker-io 服务器查看docker-io信息的命令 yum list installed | grep docker 服务器查看与docker有关的进程 启动Docker服务systemctl start docker 启用服务 systemctl stop docker 停止服务 systemctl restart docker 重启服务 systemctl status docker 查看状态 systemctl enable docker 开机自启 systemctl disable docker 禁用开机自启 使用Docker的命令 docker images 查看已经下载的文件（安装包） docker pull mysql:5.7 下载mysql镜像文件 MySQL数据库超级管理员账号：root Oracle数据库超级管理员账号：sys SQLserver数据库超级管理员账号：sa docker run -d -p 3306:3306 –name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 创建并运行容器,容器停了数据库就停了，必须加参数-d否则关 容器时会被阻止 -p 传输协议 3306 默认端口 –name mysql57 容器名字 -e MYSQL_ROOT_PASSWORD=123456 编辑信息,设置密码 docker ps 查看运行中的容器 查看所有的容器：docker container ls -a 停止容器docker stop mysql57 启动容器docker start mysql57 删除容器docker rm -f mysql57 安装MySQL客户端工具Navicat for MySQL - 猫 SQLyog - 海豚 Toad for MySQL - 蛤蟆","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"HTML标签","slug":"HTML标签","date":"2018-12-25T13:25:51.000Z","updated":"2018-12-25T14:16:15.119Z","comments":true,"path":"2018/12/25/HTML标签/","link":"","permalink":"http://yoursite.com/2018/12/25/HTML标签/","excerpt":"","text":"HTML标签1.文本标签标题标签：级别递减&lt;h1&gt;我是标题1&lt;/h1&gt; &lt;h2&gt;我是标题2&lt;/h2&gt; &lt;h3&gt;我是标题3&lt;/h3&gt; &lt;h4&gt;我是标题4&lt;/h4&gt; &lt;h5&gt;我是标题5&lt;/h5&gt; &lt;h6&gt;我是标题6&lt;/h6&gt; 段落标签&lt;p&gt;&lt;/p&gt; 文本符号和强制换行符空格： &amp;nbsp;空一个像素 &amp;emsp;一个空格键 换行标签 &lt;br&gt; 文字效果标签文字加粗 &lt;b&gt;单纯加粗&lt;/b&gt; &lt;strong&gt;强调加粗&lt;/strong&gt; 文字倾斜 &lt;i&gt;倾斜&lt;/i&gt; &lt;em&gt;强调倾斜&lt;/em&gt; 单纯文字标签&lt;font&gt;纯文本标签&lt;/font&gt; 2.列表标签无序列表ul-li:(都是双标签) ul标签：代表整个列表 li标签：代表列表中的元素 有序列表ol-li:(都是双标签) ol标签：代表整个列表 li标签：代表列表中的元素 3.图片标签&lt;img src=&quot;图片地址&quot; title=&quot;图片标题&quot; alt=&quot;图片加载失败提示语&quot; /&gt; 4.超链接标签&lt;a href=&quot;链接地址&quot; target=&quot;_blank&quot;&gt;显示内容&lt;/a&gt; 1.显示内容: 超链接在网页中可点击的内容，可是文字或图片 2.href属性：点击后跳转目标的地址 a.设置另一个网页的地址：跳转到指定网页 b.设置成另一个本地html路径：跳转到本地网页中 c.设置成当前页面标签对应的选择器：让当前网页滚动到指定位置 d.设置为空：刷新网页（会重新请求数据） 3.target属性 _self（默认值）：在当前页面中显示新的网页 _blank：在新的页面显示新的网页 5.表格标签表格标签（table-tr-td）： table标签：代表整个表格 tr标签：代表表格中的一行 td标签：代表表格中每一个单元格 1.border：设置边框宽度（单位是像素） 默认情况下是设置整个表格边框的宽度为border，同时设置每个单元格的边框宽为1。 2.bordercolor：设置边框颜色 html中的颜色值： a.颜色英文单词：red、black、yellow、pink等 b.rgb对应的16进制值：例如 #00ff00（绿色）、#ff0000（红色） 3.sellspacing:设置表格中单元格与单元格之间，以及单元格与边框之间的间距。 4.sellpadding:设置表格中内容到单元格边框之间的间距,单位是像素。 默认情况下，单元格的大小跟当前列中的内容的大小有关。 5.bgcolor：设置背景颜色 作为table属性：设置整个表格的背景颜色 作为tr属性：设置整行的背景颜色 作为td属性：设置单元格的背景颜色 6.width:设置宽度 作为table属性：设置整个列表宽度 作为td属性：设置当前列的宽度 7.height:设置高度 作为table属性：设置整个列表高度 作为tr属性：设置当前行的高度 8.align：设置水平对齐方式 left（默认）：左对齐（默认） right：右对齐 center：居中 作为table属性：让整个列表在网页中左右对齐和居中 作为tr属性：让一行中所有的单元格中的内容，在单元格中左右对齐和居中 作为td属性：让一个单元格中的内容，在单元格中左右对齐和居中 注意：html中所有的属性值都是写在双引号中的，双标签中内容是任意的。 6.复杂的表格合并： colspan：列合并 rowspan:行合并","categories":[{"name":"H5","slug":"H5","permalink":"http://yoursite.com/categories/H5/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Linux指令","slug":"linux指令","date":"2018-12-22T09:55:00.000Z","updated":"2018-12-24T12:50:23.770Z","comments":true,"path":"2018/12/22/linux指令/","link":"","permalink":"http://yoursite.com/2018/12/22/linux指令/","excerpt":"","text":"Linux指令系统(部分)指令格式： 命令名称 [命名参数] [命令对象] 一、日常操作1.cd指令 - 进入指定文件夹cd 目录 - 进入指定目录(也可以是文件夹对应的路径)~相对路径 — 绝对路径 cd .. - 返回上层目录 cd ~ - 回到根目录 2. ls指令 - 查看当前目录中的内容ls -l/-lh -竖排显示 ls -a - 隐藏文件也一起显示 ls -R - 递归显示所有内容 ls -S/-t - 按大小/时间排序 3.pwd指令 - 显示当前完整目录pwd 4.文件操作指令touch 文件名 - 新建文件 cat 文件名 - 查看文件内容 rm 文件名 - 删除文件 rm - r 目录 - 删除文件夹 cp 文件名1 文件名2 - 将文件1中的内容拷贝到文件2中 cp -r 文件名/目录名 目录2 - 将文件/目录拷贝到目录2中 mv 文件名1 文件名2 - 将文件1中的内容移动到文件2中 ,并且删除文件1（文件重命名） mv 文件名1 文件目录- 将文件1移动到指定目录中 (注意：cp/mv/rm 后面可以跟： -i询问 -f强制 -n不覆盖) mkdir 目录名 - 新建文件夹 mkdir -p a/b/c - 按层级创建a,b,c三个文件夹 mkdir -p a/{b,c}/{d,e,f} -同一层级常见多个 rmdir 目录名 - 删除指定空目录 5.history - 显示历史指令记录bashrc 配置显示时间：export HISTTIMEFORMAT=”[%y‐%m‐%d_%T] “ 修改bashrc 后使其生效: source ~/.bashrc 或 . .bashrc 6.链接ln -s 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个软链接(可以看成是快捷键)(源路径是绝对路径) ln 源路径 目标路径 - 给源路径对应的文件在目标路径下创建一个硬链接 7.快捷键ctr + f - 前进一个字符 ctr + b - 后退一个字符 ctr + a - 回到行首 ctr + e - 回到行尾 ctr + w - 向左删除一个单词 ctr + u - 向左删除全部 ctr + k - 向右删除全部 ctr + y - 粘贴上次删除的内容 ctr + l - 清屏 二、进程相关指令1.ps指令ps - 进程状态 ps -aux 或者 ps ex - 查看进程 ps -aux|grep 进程名 - 查看指定进程 psgrep 进程名 2.top指令top - 动态监控进程 top -p PID1,PID2,…. - 动态监控指定进程 3.free指令free -单位 - 以指定单位查看内存 4.kill指令kill 进程号 - 杀死指定的进程 kill -1/-9/-15 - -1(HUP)不间断重启，-9(KILL)强制杀死进程,-15(TERM)正常终止进程 pkill 进程名 - 按名字处理进程 killall 进程名 - 处理名字匹配的进程 uptime - 查看系统状态 三、权限管理1.user和group : 一个系统可以有多个用户和多个分组； 一个分组中可以有多个用户，一个用户在不同的分组中(多对多)users - 查看当前用户 groups - 查看当前分组 groupadd 分组名 - 添加分组 useradd ‐G 分组列表 ‐m ‐s /bin/bash 用户名 - 创建一个用户添加到指定的分组中(在home创建相应的文件夹) usermod -G 分组列表 用户名 - 修改分组 passwd 用户名 - 修改密码 su - 用户名 - 切换用户身份 sudo - 以管理员执行其他程序 注意： a.在ubuntu需要将用户添加到sudo分组中，才能使用sudo以管理员的身份执行程序b.在centOS中需要先执行visudo指令进入sudoers文件中在指定的位置添加内容 ## Allow root to run any commands anywhere root ALL=(ALL) ALL xiaoming ALL=(ALL) ALL(自己添加的，xiaoming是用户名) 2.chmodchmod 权限值 文件 - 修改指定文件的权限 chmod [a,u,g,o][+,-][r,w,x] 文件 - 为指定文件，给所有用户添加相应的权限 (a:所有，u:自己，g:同组，o:其他；+：添加， -: 取消r:读，w:写，x:执行) chown 用户名 文件 - 改变文件所有者 (权限制是三组二进制值) self group other rwx rwx rwx 111 101 001 - 自己读写可执行，同一分组的只读可执行，其他的只可执行 110 100 000 三、日志管理1.cat指令cat 文件 - 查看文件内容 2.查看部分head -n N 文件 - 查看前N行内容 tail -n N 文件 - 查看后N行内容 3.less [-N] 文件- 按 j 向下 - 按 k 向上 - 按 f 向下翻屏 - 按 b 向上翻屏 - 按 g 到全文开头 - 按 G 到全文结尾 - 按 Q 退出 more [-N] 文件 - 和less差不多，这个是尽可能多，less是尽可能少的加载 4.处理sort - 排序 (cat 文件 |sort) uniq - 去重 (cat 文件 |uniq) - 只会去重相邻的重复数据，一般结合sort一起使用: |sort|uniq awk ‘{print $N}’ - 打印第N列的内容(netstat -natp|awk ‘{print $4}’) history |awk ‘{print $4}’ |sort |uniq ‐c | sort ‐rnk 1 | head ‐n 3 -获取历史指令中，使用最频繁的三个指令 5.统计wc -c(字符)/-w(单词)/-l(行) 文件 6.查找grep 查看对象 目录/文件 参数 参数： -i 忽略大小写 -n 显示行标号 -E 通过正则表达式匹配 -v 忽略字段 -rn 递归查找目录，并打印行号 —include=‘*.py’ 仅包含 py文件 —exclude=‘*.js’ 不包含 js 文件 例如： grep you bb.txt grep you bb.txt -i grep you bb.txt -i -n grep -E &apos;[0-9]+&apos; bb.txt find DIR -name ‘*.xxx’ 找到目录下所有名字匹配的文件 找出文件夹 例：find /tmp/xyz/ ‐perm 0642 ‐size +10k ‐size ‐100k ‐name &apos;*.log&apos; which 指令 - 精确查找当前可执行的指令 whereis 指令 - 查找所有匹配的命令 ps -aux|awk ‘{print \\$2,\\$3,\\$4,$11}’ &gt; 存储数据.txt 很好用！执行查看进程操作获取数据的指令后把结果保存在后面的存储数据文件中！（覆盖原文件内容） ps -aux|awk ‘{print \\$2,\\$3,\\$4,$11}’ &gt;&gt; 存储数据.txt 在原文件后追加新获得的数据。 wget url ：下载 四、网络管理ifconfig 查看网卡状态 netstat -natp - 查看网络连接状态 netstat -natp|grep 端口号 - 查看指定端口的网络连接状态 ping 地址 ping -i 时间 地址 ping -c 次数 地址 telnet ip地址 端口 - 查看远程主机网络连接状况 dig 地址 - 查看DNS wget 地址 - 下载 包管理工具 ：yum yum install 包名 安装对应的包名，前提是包已存在 yum search 包名 搜索对应的包名","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"markdwon常用操作","slug":"markdwon常用操作","date":"2018-12-22T07:04:00.000Z","updated":"2018-12-22T08:48:16.538Z","comments":true,"path":"2018/12/22/markdwon常用操作/","link":"","permalink":"http://yoursite.com/2018/12/22/markdwon常用操作/","excerpt":"","text":"1.标题可以在行首通过改变添加#号的数目来控制标题的级别，从1~6级标题，如#H1、##H2、###H3等。可使用—作分割线，前后应空行，否则会出错，例：-– 2.斜体和粗体使用 * 和 ** 来表示 斜体 和 粗体 字。例如：（标识符前后需加上空格，否则会按整句读取）这是 *斜体* 这是 **粗体**这是 斜体 这是 粗体 3.添加外部链接使用 [描述](链接地址) 为文字添加外部链接，示例： [詹洪简书](https://www.jianshu.com/u/5bb8c539a12d)这是去往 詹洪简书 的链接 4.无序列表使用 * + - 来表示无序列表，示例：- 无序列表1- 无序列表2- 无序列表3 无序列表1 无序列表2 无序列表3 5.有序列表使用数字加.号来确定顺序，如：1.有序列表12.有序列表2 6.文字引用在行首使用&gt;表示文字引用，如：>print(“hello world!”) print(“hello world!”) 7.行内代码块使用 `代码块` 来表示行内带码块，如：python中是这样输出的：`print(“hello world!!”)`。 python中是这样输出的：print(&quot;hello world!!&quot;)。 8.代码块使用 四个缩进空格 表示代码块，如： (注意要空一行) for i in range(0,10): 9.插入图像使用![图片描述](图片链接地址) 插入图像，如： 10.删除线~~删除线的内容~~删除线的内容","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"git常用指令","slug":"Linux文档整理/git常用指令","date":"2018-12-22T07:04:00.000Z","updated":"2018-12-22T09:08:55.028Z","comments":true,"path":"2018/12/22/Linux文档整理/git常用指令/","link":"","permalink":"http://yoursite.com/2018/12/22/Linux文档整理/git常用指令/","excerpt":"","text":"1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git stutas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset - - hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本git reset - - hard 版本号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到指定的版本git checkout - - 文件名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分之的时候才用) 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"vim编辑器之神","slug":"Linux文档整理/vim编辑器之神","date":"2018-12-22T07:04:00.000Z","updated":"2019-01-02T09:43:05.621Z","comments":true,"path":"2018/12/22/Linux文档整理/vim编辑器之神/","link":"","permalink":"http://yoursite.com/2018/12/22/Linux文档整理/vim编辑器之神/","excerpt":"","text":"vim编辑器之神配置vimrc配置在shell中可以通过 vim ~/.vimrc 或者 vim /etc/vimrc 打开vimrc文件对vim进行配置。在这个文件中可以进行很多和vim相关的配置，常用的如下（如果对其他配置感兴趣的可以自己百度）： 常用操作1.模式切换我们可以将vim分为命令模式、编辑模式和末行模式三种命令模式：进入vim的时候vim是处于命令模式状态下的，这个时候输入内容不会出现在编辑区 (最末什么都没有) 末行模式：在命令模式下输入冒号，让vim进入末行模式。在末行模式的冒号后面可以输入相关的一些指令进行相关操作 (最后有一个冒号) 编辑模式：在命令模式下按’i’进入编辑模式。在编辑模式下可以对文件内容进行编辑 (最后 –INSERT– 或者 –插入–) 2.保存和退出在末行模式下输入相应的指令可以对编辑区的内容进行保存和退出vim界面w – 只保存(类似快捷键ctr+s)q – 退出（在编辑区的内容全部都保存的情况下才有效）wq – 保存并退出q! – 强制退出（不保存修改信息） 3.光标操作以下光标操作都是在命令模式下输入的^(shift+6) – 移动到行首$(shift+4) – 移动到行尾G(shift+g) – 移动到文件末尾行号G – 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行gg – 移动到文件开头 4.文本操作以下操作不带冒号的是在命令模式下输入，前面有冒号代码后面的内容是在末行模式下输入dd – 删除光标所在的行数字dd – 从光标所在行开始往后面开始删，删除指定数量行内容:%d – 删除所有 yy – 复制光标所在的行数字yy – 从光标所在行开始复制指定行数的内容p – 将复制的内容粘贴到光标所在的位置u – 撤销ctr+r – 反撤销 :%!sort – 对内容排序 :/查找对象[/gice] – 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找 $s/被替换对象/替换内容[/gice*] – 将正则表达式匹配到的内容替换成指定内容 - g: 全局匹配 - i: 忽略大小写 - c: 替换时需要提示 - e: 忽略错误","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Nginx服务器安装","slug":"Linux文档整理/Nginx服务器安装","date":"2018-12-22T07:04:00.000Z","updated":"2019-01-02T09:42:41.637Z","comments":true,"path":"2018/12/22/Linux文档整理/Nginx服务器安装/","link":"","permalink":"http://yoursite.com/2018/12/22/Linux文档整理/Nginx服务器安装/","excerpt":"","text":"Nginx服务器1.阿里云添加80端口阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口 2.安装nginx a) 添加nginx存储库 1yum install epel-release b) 安装nginx yum install nginx c) 运行nginxNginx不会自行启动。要运行Nginx systemctl start nginx nginx的运行命令: systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d) 系统启动时启动Nginx systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=https sudo firewall-cmd --reload 3.nginx目录共享配置a) 在contOS目录中确定一个需要共享的文件夹，例如：/home/yutingb) 打开etc/nginx/nginx.conf 文件，设置server1234567#共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表root /home/yuting;location / &#123;autoindex on;autoindex_exact_size on; autoindex_localtime on;&#125; 除了可以共享文件，还可以自定义页面12345#自定义服务器页面location / &#123;root /home/yuting;index index.html index.htm;&#125; 注意： 如果出现权限问题，可以修改目录的权限 ssh密钥认证1.在主机和从机上执行：ssh-keygen 2.在从机上执行: scp id_rsa.pub root@主机地址:~/.ssh/master.pub(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’) 3.在主机中的.ssh文件夹中创建authorized_keys文件： touch authorized_keys 4.修改文件authorized_keys的权限: chmod 600 authorized_keys 5.将master.pub放进authorized_keys文件中: cat master.pub &gt;&gt; authorized_keys 6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/服务器/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]}]}