{"meta":{"title":"四川小旋风","subtitle":null,"description":null,"author":"酱油壹号","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2018-12-20T11:23:23.000Z","updated":"2018-12-20T11:26:54.378Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-12-20T11:23:58.000Z","updated":"2018-12-20T11:26:35.096Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"day1-markdwon常用操作","slug":"day1-markdwon常用操作","date":"2018-12-21T03:30:24.625Z","updated":"2018-12-21T03:30:24.626Z","comments":true,"path":"2018/12/21/day1-markdwon常用操作/","link":"","permalink":"http://yoursite.com/2018/12/21/day1-markdwon常用操作/","excerpt":"","text":"1.标题可以在行首通过改变添加#号的数目来控制标题的级别，从1~6级标题，如#H1、##H2、###H3等。可使用—作分割线，前后应空行，否则会出错，例：-– 2.斜体和粗体使用 * 和 ** 来表示 斜体 和 粗体 字。例如：（标识符前后需加上空格，否则会按整句读取）这是 *斜体* 这是 **粗体**这是 斜体 这是 粗体 3.添加外部链接使用 [描述](链接地址) 为文字添加外部链接，示例： [詹洪简书](https://www.jianshu.com/u/5bb8c539a12d)这是去往 詹洪简书 的链接 4.无序列表使用 * + - 来表示无序列表，示例：- 无序列表1- 无序列表2- 无序列表3 无序列表1 无序列表2 无序列表3 5.有序列表使用数字加.号来确定顺序，如：1.有序列表12.有序列表2 6.文字引用在行首使用&gt;表示文字引用，如：>print(“hello world!”) print(“hello world!”) 7.行内代码块使用 `代码块` 来表示行内带码块，如：python中是这样输出的：`print(“hello world!!”)`。 python中是这样输出的：print(&quot;hello world!!&quot;)。 8.代码块使用 四个缩进空格 表示代码块，如： (注意要空一行) for i in range(0,10): 9.插入图像使用![图片描述](图片链接地址) 插入图像，如： 10.表格用冒号定义对齐格式：|品牌|价格|数量||:–|–:|–:||华硕 | 18888 | 8 ||神舟 | 19999 | 7 || 品牌 | 价格 | 数量 || :— | —-: | —: || 华硕 | 18888 | 8 || 神舟 | 19999 | 7 | 11.删除线~~删除线的内容~~删除线的内容","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"","slug":"day2-作业","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day2-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day2-作业/","excerpt":"","text":"1.下列四组数，依次为二进制、八进制和十六进制，符合要求的是（d）a. 12, 77, 10b. 12, 80, 10c. 11, 78, 19d. 11, 77, 19 2.二进制数加法运算的基本特点是“逢二进一”，即0+0=0，0+1=1，1+0=1，1+1=0并进位。运用这一基本法则和十进制运算的类似规律，得出二进制数加法运算1001+101的结果为(c)a. 1001b. 1010c. 1110d. 1101 3.八进制754中的数码7对应的位权是(c)a. 10^2 b. 16^1 c. 8^2 d. 2^2 4.十进制数53转换成二进制数是(b)a. 100101b. 110101c.100100d.110100 5.已知，十进制中的8在X进制中表示为11，即(10)8=(X)11。请问这个X进制具体为(b)进制a. 6b. 7c. 8d. 9 6.二进制的1000001相当十进制的_④_，二进制的100.001可以表示为_④__。A: ① 62 ② 63 ③ 64 ④ 65B: ① 2^3 + 2^–3 ② 2^2 + 2^–2 ③ 2^3 + 2^–2 ④ 2^2 + 2^–3","categories":[],"tags":[]},{"title":"","slug":"day3-作业","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day3-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day3-作业/","excerpt":"","text":"1.使用位运算判断一个数是否是奇数注：奇数的二进制的最后一位是1，偶数是01234567#用 &amp; 判断一个数奇偶性#&amp; ：按位与，比较每一位上的数字，都是1，则为1，其余为0。num = 33if (num &amp; 1) == 0 : print('%d为偶数'%num)else: print('%d为奇数' % num) 2.表达式0x13&amp;0x17的值是（19 ） 0x13 = 0b0001 00110x17 = 0b0001 0111——–&gt;0b0001 0011—–&gt;2^4 + 2 + 1 = 19 3.若x=2,y=3则x&amp;y的结果是（2 ） 2 = 0b0103 = 0b011—–&gt;0b010 = 2 4.表达式 -97 | 120 的运算结果是(-1) 97 = 0b0110 0001-97 = 0b1110 0001(yuan)-97 = 0b1001 1110(fan)-97 = 0b1001 1111(bu)120 = 0b0111 1000————-&gt;1111 1111bu1111 1110fan ————-&gt;1000 0001yuan 5.在位运算中，操作数每右移一位，其结果相当于（ B） A.操作数乘以2 B.操作数除以2 C.操作数除以4 D.操作数乘以4 6.设x 是一个整数（16位）.若要通过x|y使x低度8位置1，高8位不变，则y的二进制数是（ 0b0000 0000 1111 1111） X|Y = 1111 1111不变则Y = 0000 0000 1111 1111 下面定义变量正确的是(a) a. a = b = c = 10 b. a,c = 10 c. in = 20 d. num = 10; t = 20 n = 6784，以下能够获取到7 的方法有（c，d） a. n / 1000 % 100 b. n % 1000 / 100 c. n // 100 % 10 d. n // 10 % 100 // 10 9.以下表达式 10 / 4 + 23 // 4 * 2 - 30的计算结果是：-17.5__。 2.5 + 5*2-30 写代码获取输入数字12345中的每一位上的数字1234567891011n = 12345wan = n // 10000qian = n % 10000 // 1000bai = n % 10000 % 1000 // 100shi = n % 10000 % 1000 % 100 // 10ge = n % 10print('%d的万位为：%d'%(n,wan))print('%d的千位为：%d'%(n,qian))print('%d的百位为：%d'%(n,bai ))print('%d的十位为：%d'%(n,shi))print('%d的个位为：%d'%(n,ge)) 写出判断一个数是否能同时被3和7整除的条件语句12345num = int(input('请输入一个整数：'))if num % 3 == 0 and num % 7 == 0 : print('%d能同时被3和7整除'%num)else : print('%d不能同时被3和7整除' % num) 写出判断一个数是否能够被3或者7整除，但是不能同时被3和7整除的表达式12345num = int(input('请输入一个整数：'))if (num % 3 == 0 or num % 7 == 0) and num % 21 != 0 : print('%d能被3或7整除,且不能同时被3和7整除'%num)else : print('%d不满足条件' % num)","categories":[],"tags":[]},{"title":"","slug":"day4-Python-的字符串内建函数","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day4-Python-的字符串内建函数/","link":"","permalink":"http://yoursite.com/2018/12/21/day4-Python-的字符串内建函数/","excerpt":"","text":"Python 的字符串常用内建函数如下：|序号|方法|描述||—|—|—|1 |capitalize()|将字符串的第一个字符转换为大写2| center(width, fillchar)|返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。3| count(str)|返回 str 在 string 里面出现的次数4| bytes.decode(encoding=”utf-8”, errors=”strict”)|Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。5| encode(encoding=’UTF-8’,errors=’strict’)|以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’6| endswith(suffix)|检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.7| expandtabs(tabsize=8)|把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。8| find(str, beg=0 end=len(string))|检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-19| index(str, beg=0, end=len(string))|跟find()方法一样，只不过如果str不在字符串中会报一个异常.10| isalnum()|如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False11| isalpha()|如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False12 |isdigit()|如果字符串只包含数字则返回 True 否则返回 False..13 |islower()|如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False14 |isnumeric()|如果字符串中只包含数字字符，则返回 True，否则返回 False（中文数字也可以）15 |isspace()|如果字符串中只包含空白，则返回 True，否则返回 False.16| istitle()|如果字符串是标题化的(见 title())则返回 True，否则返回 False17|isupper()|如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False18| join(seq)|以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串19| len(string)|返回字符串长度20| ljust(width[, fillchar])|返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。21 |lower()|转换字符串中所有大写字符为小写.22 |lstrip()|截掉字符串左边的空格或指定字符。23| maketrans()|创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。24 |max(str)|返回字符串 str 中最大的字母。25| min(str)|返回字符串 str 中最小的字母。26 |replace(old, new [, max])|把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。27 |rfind(str, beg=0,end=len(string))|类似于 find()函数，不过是从右边开始查找.28 |rindex( str, beg=0, end=len(string))|类似于 index()，不过是从右边开始.29| rjust(width,[, fillchar])|返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串30 |rstrip()|删除字符串字符串末尾的空格.31 |split(str=””, num=string.count(str))|num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串32 |splitlines([keepends])|按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。33 |startswith(str, beg=0,end=len(string))|检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。34 |strip([chars])|在字符串上执行 lstrip()和 rstrip()35 |swapcase()|将字符串中大写转换为小写，小写转换为大写36 |title()|返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())37 |translate(table, deletechars=””)|根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中38 |upper()|转换字符串中的小写字母为大写39 |zfill (width)|返回长度为 width 的字符串，原字符串右对齐，前面填充040 |isdecimal()|检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。","categories":[],"tags":[]},{"title":"","slug":"day5-分支和循环总结","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day5-分支和循环总结/","link":"","permalink":"http://yoursite.com/2018/12/21/day5-分支和循环总结/","excerpt":"","text":"#5.1 分支结构python中分支结构只有if语句，没有switch语句 ##5.1.1 if语句 a.语法：if 条件语句 ： 代码段 b.说明：if – 关键字条件语句 – 任何有结果的表达式，不管结果类型。： – 固定写法，有冒号下以下必定有缩进代码段 – 和if保持一个缩进的一条或多条语句。 c.执行过程：先判断条件结果是否是True，如果是True就执行冒号后面的代码段。否则就不执行。注意：如果条件语句结果不是布尔，会先将结果转换成布尔，再判断。除了0，空值以外的值转为布尔都为True。if后面可以写哪些语句注意：赋值语句不能写在if后面，其他都可以。12345678910111213141516171819num = 10if num &amp; 1 == 0: print('%d是偶数' % (num)) print('========') # 和if保持一个缩进的语句是在条件成立才执行 # 与if无关的语句最好换个行print('##########') # 在if外面的语句不管if条件是否成立都会执行if 'ADS'.isupper(): print('全是大写') #不执行# 练习：随机产生一个年龄值，如果大于等于18就打印成年。import randomage = random.randint(0,100)if age &gt;= 18: print('%d已经成年了。' %(age))else: print('未成年')print(age) ##5.1.2 if-else a.语法：if 条件语句 ： 代码段1else: 代码段2 b.说明：if – 关键字else – 关键字条件语句 – 任何有结果的表达式，不管结果类型。： – 固定写法，有冒号下以下必定有缩进代码段 – 和if及else保持一个缩进的一条或多条语句。 c.执行过程：先判断条件结果是否是True，如果是True就执行代码段1。否则就执行代码段2。注意：如果条件语句结果不是布尔，会先将结果转换成布尔，再判断。除了0，空值以外的值转为布尔都为True。123456#随机产生一个整数，如果是奇数打印’***是奇数‘，否则，反之。num = random.randint(0,9999)if num &amp; 1: print('%d是奇数' %(num))else: print('%d是偶数' %(num)) ##5.1.3 if-elif-else a.语法：if 条件语句1 ： 代码段1elif 条件语句2: 代码段2elif 条件语句3: 代码段3…else: 代码段n b.说明：if – 关键字elif – 关键字else – 关键字条件语句 – 任何有结果的表达式，不管结果类型。： – 固定写法，有冒号下以下必定有缩进代码段 – 和if、elif及else保持一个缩进的一条或多条语句。 c.执行过程：先判断条件语句1结果是否是True，如果是True就执行代码段1。否则就判断条件语句2结果是否是True，如果是True就执行代码段2。否则就判断条件语句3结果是否是True，如果是True就执行代码段3。…如果前面所有的条件都为False，就执行代码段n。注意：后面的条件判断的前提是前面条件不成立。这里的elif根据情况可以有多个，else也可以省略。如果条件语句结果不是布尔，会先将结果转换成布尔，再判断。除了0，空值以外的值转为布尔都为True。1234567891011# score 60以下不及格 60-70及格 71-89良好 90以上优秀score = random.randint(0,100)print('成绩为%d:' %(score),end=\"\")if score &lt; 60: print('不及格')elif score &lt;= 70: print('及格')elif score &lt;= 89: print('良好')else: print('优秀') ##5.1.4 if嵌套 可以在if，elif，else后面的代码段中，都可以再写其他的if语句。1234567891011121314151617181920212223242526272829#判断一个数字是否为偶数，是的话判断是否被4整除score = random.randint(0,100)if score &amp; 1: print(&apos;%d是奇数&apos; %score)else: if score % 4 == 0: print(&apos;%d是4的倍数&apos; % score) else: print(&apos;%d是偶数&apos; %score)&quot;&quot;&quot;练习：输入一个字符串，判断字符串的第一个字符是否是字母，如果是,打印’以字符开头&apos;。如果这个字母是大写的再打印’大写字母‘。&quot;&quot;&quot;str1 = input(&apos;请输入一串字符：&apos;)if str1[0].isalpha(): #if &apos;a&apos; &lt;= str1[0] &lt;= &apos;z&apos; or &apos;A&apos; &lt;= str1[0] &lt;= &apos;Z&apos;: print(&apos;以字母开头&apos;) if str1[0].isupper(): #&apos;A&apos; &lt;= str1[0] &lt;= &apos;Z&apos;: print(&apos;大写字母&apos;)else: print(&apos;什么都不打印&apos;)&apos;&apos;&apos;l = []num = 0while num &lt;= 888: num = random.randint(0, 999) l.append(num)print(l)&apos;&apos;&apos; #5.2 for循环 python中的循环结构有两种：for和while循环。什么时候用循环：某个操作需要重复执行，就考虑用循环。 ##5.2.1 for循环 语法：for 变量名 in 序列： 循环体 说明：for、in – 关键字变量名 – 满足变量名要求即可序列 – 字符串，列表，元组，字典，集合，迭代器，range循环体 – 可以是一条或多条和for保持一个缩进的语句（需要重复执行的代码） 执行过程：让变量去序列中取值，一个一个的取，取完为止；每取一个值，执行一次循环体。（for循环中，序列中元素的个数，决定了循环的次数）注意：如果for后的变量取到的值，在循环体里不使用，那么这个变量命名时，用一个_来命名。123456for x in range(97,123): print(chr(x), end='---&gt;')for x in 'abc': print(x) print('##$$#$$#$#') ##5.2 range range（n） – 产生一个数字序列，序列内容是0~n-1（结果是一个序列）range（m,n） – 产生一个数字序列，序列内容是m~n-1,m&lt;n（结果是一个序列）range（m,n,step） – 产生一个数字序列，序列从m开始，每次加step直到n前为止，取不到n。range一般用在：1.需要产生指定范围的数字序列2.单纯的控制for循环的循环次数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for num in range(10): print(num, end='')print()for num in range(10, 20, 2): print(num, end='---&gt;')#练习：求1+2+。。+100sum1 = 0for num in range(1, 101): sum1 += numprint(sum1)print(sum([1, 2, 3]))#练习：2+4+6+8+。。。+100#方法1：不用ifsum1 = 0for num in range(1, 51): # range(2,101,2) sum1 += num*2print(sum1)#方法2：用ifsum2 = 0for num in range(1, 101): if not num &amp;1: sum2 += numprint(sum2)\"\"\" if num &amp; 1: pass else: sum2 += num\"\"\"#练习：写程序统计一个字符串中数字字符的个数str1 = input('请输入一个字符串：')sum1 = 0for i in str1: if '0' &lt;= i &lt;= '9': print(i) sum1 += 1print('数字字符的个数是：', sum1)#用循环控制打印10行”*“for _ in range(1,10): print('*')for x in range(1, 10): print('*'*x) #5.3 while ##5.3.1 while循环 语法：while 条件语句： 循环体 说明：while – 关键字条件语句 – 有结果的表达式，除了赋值语句： – 固定写法循环体 – 和while保持一个缩进的一条或者多条语句（会被重复执行） 执行过程：先判断条件语句是否为True，为True就执行循环体；执行完循环体再判断条件语句是否为True，为True又执行循环体；。。。。。以此类推，直到条件语句为False，就结束整个循环。123456789101112131415#1*2*..*10num = 1sum1 = 1while num &lt;= 10: sum1 *= num num += 1print(sum1)print(1*2*3*4*5*6*7*8*9*10)#获取字符串abc123中的每个字符str1 = 'abc123'num = 0while num &lt;= 5: print(str1[num]) num += 1 ##5.3.2 for和while循环 python中，for循环能做到的while循环都能做到；但是while循环能做的，for循环不一定能做到。 使用for循环：1.获取序列中的元素（值）2.循环次数确定 while循环：1.死循环2.循环次数不确定1234#练习：程序不断的输入，知道为0为止i = input('请输入：')while i != '0': i = input('请输入：') #5.4 continue,break和else ##5.4 .1 continue continue是一个关键字，只能写在循环体中 功能：当循环遇到continue则会结束当次循环，直接进入下次循环判断。 进入下次循环：for循环就是用变量取下一个值；while循环就是直接判断条件语句是否为True。##5.4 .2 break break是一个关键字，只能写在循环体中。 功能：当循环遇到break时，直接结束当前循环。##5.4.3 else python中特有 语法： while 条件语句： 循环体else： 代码段 for 变量 in 序列： 循环体else： 代码段 执行过程：else结构不会影响原循环的执行过程。当循环自然死亡时，就会执行else后面的代码段。循环因为遇到break而结束时，不会执行else后面的代码段。1234for x in range(10): print(x)else: print('for循环结束')","categories":[],"tags":[]},{"title":"","slug":"day4-字符串总结","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day4-字符串总结/","link":"","permalink":"http://yoursite.com/2018/12/21/day4-字符串总结/","excerpt":"","text":"1.什么是字符串序列 有序 不可变。用单引号或双引号括起来的任意字符集。2.字符串中的字符a.普通字符： ‘23’ ‘wefsfewfewq’ ‘😍 🧔🐕’b.转义字符： \\n \\t \\’ \\” \\阻止转义：r或R加在代码前 ##4.1字符编码python中的字符采用的是Unicode编码 a.什么是编码就是数字和字符的对应关系，其中字符对应的数字就是字符的编码。‘a’ - 97‘b’ - 98‘余’ - 20313 b.编码方式ASCII码：针对数字、字母字符、一些英文中常用的符号进行编码，采用一个字节（0~127 2 ^ 7 - 1 = 127）对字符进行编码（128个字符） 1.大写字母数字小于小写字母数字2.大写字母与小写字母之间还有其他字符 Unicode码：包含了ASCII码表，同时能够对世界上所有的语言对应符号进行编码。采用2个字节对字符进行编码，能编码65536个字符中文编码范围：4e00 ~ 9fa5 c.两个函数chr(编码值) - 将字符编码转换成字符ord(字符) - 获取字符对应的编码值，一次只能一个。1234567891011print(chr(0x0087))print(chr(0x1100))print(chr(0x4e00))Z = '詹'H = '洪'print(ord(Z), ord(H)) #获得的是一个十进制 35449 27946print(hex(ord(Z)), hex(ord(H))) #十进制转十六进制 0x8a79 0x6d2a#d.可以将字符编码放到字符串中便是一个字符： \\u + 4位的16进制编码值str1 = 'abc\\u4f96123\\u1234'print(str1) # abc侖123ሴ ##4.2 获取字符串中的字符一旦一个字符串确定，那么字符串中每个字符的位置就确定。而且每个字符会对应一个用来表示其位置和顺序的下标值。 1.下标（索引）字符串中每个字符都有一个下标，代表其在字符串中的位置下标的范围是： 0到字符串长度减一（0代表第一个字符位置）-1到负的字符串长度（-1代表最后一个字符的位置） 12&apos;abc\\n123&apos; # &apos;1&apos; : 下标为4或-3&apos;abc\\u4eff23&apos; # &apos;2&apos; : 下标为4或-2 2.获取单个字符语法：字符串[下标] – 获取字符串中，指定下标对应的字符。说明：字符串 – 可以是字符串常量，也可以是字符串变量（只要结果是字符串就行）。[] – 固定写法下标 – 字符的下标，不能越界 3.获取部分字符语法1：字符串[开始下标:结束下标:步长]说明：字符串 – 可以是字符串常量，也可以是字符串变量（只要结果是字符串就行）。[] – 固定写法: – 固定写法开始和结束下标 – 字符的下标步长 – 整数功能： 1.从开始下标开始获取到结束下标前为止，每次下标值增加步长对应的值。结果是字符串。注意：当步长是正数（从前往后取），开始下标对应的字符要在结束下标对应的字符的前面。当步长是负数（从后往前取），开始下标对应的字符要在结束下标对应的字符的后面。结束下标对应的值是取不到的。 12345str1 = 'abcdefghijklmn'print(str1[0:6:2]) #aceprint(str1[0:6:1]) #abcdefprint(str1[-1:6:-1]) #nmlkjih 倒着取 语法2：字符串[开始下标:结束下标] – 相当于步长是11print(str1[-1:3]) #空串，啥都没有 &apos;&apos; != &apos; &apos; 4.获取部分字符，省略下标获取部分字符时，开始下标和结束下标都可以省略 a.开始下标省略字符串[:结束下标:步长] 或者 字符串[:结束下标]步长为正，从头开始步长为负，从尾开始 1234str2 = 'abc123abc'print(str2[:4]) #步长为正，从头开始 abc1print(str2[:4:-1]) #步长为负，从尾开始 cba3 b.结束下标省略字符串[开始下标::步长] 或者 字符串[结束下标:]步长为正：从开始下标从前往后获取到字符串结束步长为负：从开始下标从后往前获取到字符串结束123456str2 = 'abc123abc'print(str2[4:]) #23abcprint(str2[:]) #获取整个字符串 abc123abcprint(str2[:4:-1]) # cba3print(str2[::-1]) #字符串倒叙 cba321cbaprint(str2[-100:100]) #这里的开始和结束下标都能越界 abc123abc ##4.3 字符串相关计算 + 字符串1 + 字符串2 ：拼接两个字符串，产生一个新的字符串注意：字符串相加，加号两边必须是字符串 12345str1 = '成都'str2 = '理工'str3 = '大学'print(str1 + str2 + str3) # 成都理工大学 * 字符串 * n（正整数） ： 字符串内容复制n次，产生一个新的字符串 12# 练习打印 10个* 跟10个%print('*' * 10 + '%' * 10) 比较运算符：&gt; &lt; == &gt;= &lt;= != a. ==,!=字符串1 == 字符串2 – 判断两个字符串是否相等b. &gt;,&lt;,&gt;=,&lt;=俩个字符串比较大小：从第一位开始比，找到第一对不同的字符，比较他们编码值的大小。 12345678910111213141516171819print('abc' &gt; 'ad') # False 因为 ord(b) &lt; ord(d)print('1abc' &lt; 'ahkks') # True# 练习：判断一个字符是否为字母char1 = input('请输入一个字符：') # cprint('是否是字母：', 'a' &lt;= char1 &lt;= 'z' or 'A' &lt;= char1 &lt;= 'Z') #True# 练习：判断一个字符是否为中文 4e00 - 9fa5n = ord(char1) # 97if 0x4e00 &lt;= n &lt;= 0x9fa5: print(\"中文\") else: print('NO')if '\\u4e00' &lt;= char1 &lt;= '\\u9fa5': print(\"中文\")else: print('NO') in 和 not in 字符串1 in 字符串2 ：判断字符串2中是否包含字符串1，结果是布尔值。字符串1 not in 字符串2 ：判断字符串2中是否不包含字符串1，结果是布尔。 12print('abc' in 'abc2432') # Trueprint('#' in 'ahsjfds#') # True len函数 len(序列)len(字符串) – 获取字符串中字符的个数。 12print(len('abh\\u6666ui\\n')) # 7print(len('abh\\\\u6666ui\\n')) # 12 str str(数据)：将数据转成字符串,转换就是在数据值的最外面加引号注意：系统数据类型名不能用来给变量命名 1.其他数据转换成字符串：所有类型的数据都可以转换成字符串1234str1 = str(100)str2 = str(&#123;'a': 100, 'b': 200&#125;)print(str1) # '100'print(str2) # '&#123;'a': 100, 'b': 200&#125;' 2.字符串转其他类型字符串转整数：int(字符串)，只有去掉引号后剩下的部分本身就是一个整数的字符串才能转换。字符串转浮点型：float(字符串)，只有去掉引号后剩下的部分本身就是一个整数或浮点数的字符串才能转换。1234float('2e3') #2000.0#只有‘’空串转成bool值才为False，其他都为True。print(bool('0'), bool('False'), bool('')) # True True False ##4.4 格式字符串 1.格式字符串指的是字符串中通过格式占位符来表示字符串变化，然后再通过其他的值来给占位符赋值。 语法：含有格式占位符的字符串 %（占位符对应的值）说明：格式占位符有固定的写法，可以有多个% – 固定写法() – 里面值的类型和个数要和前面的格式占位符一一对应。 2.常见格式占位符 %d – 整数占位符%s – 字符串占位符%f – 小数占位符%.nf – 小数占位符,保留小数点后n位小数%c – 字符占位符,可以将数字转换成字符 1234567name = input('名字：')message = '%s你好，吃饭了吗？' % nameprint(message)message = '%s今年%d岁，体重：%.2fkg, 血型是：%c' % ('小花', 18, 46.3, 97)#97 经过%c转换成了字符进行填充print(message) ##4.5 字符串常用方法 字符串.capitalize() - 将字符串第一个字母转换成大写 字符串对齐 字符串.center(width,fillchar) – 居中字符串.ljust(width,fillchar) – 左对齐字符串.rjust(width,fillchar) – 右对齐width – 正整数，表示新的字符串的宽度fillchar – 字符，填充字符串 12345678910111213141516171819202122232425str1 = '12hello'str2 = 'hello'new_str1 = str1.capitalize()new_str2 = str2.capitalize()print(new_str1)print(new_str2)str3 = '123'new_str3 = str3.center(7, '$')print(new_str3) # 新字符串7个长度，123居中，其余用$填充new_str3 = str3.ljust(7, '$')print(new_str3) # 新字符串7个长度，123左对齐，其余用$填充new_str3 = str3.rjust(7, '$')print(new_str3) # 新字符串7个长度，123右对齐，其余用$填充# rjust() 用处import randomn = random.randint(0, 20) # 产生一个0到100的随机整数str4 = 'Python1808'new_str4 = str4 + str(n).rjust(3, '0')print(new_str4) jion(sep) str1.jion(str2) 用str1插入到str2的每2个字符之间。 4.\\ max(str1) :求出str1中最大编码的字符min(str1) ：求出str1中最小编码的字符","categories":[],"tags":[]},{"title":"","slug":"day4-Python字符串常用内建函数","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day4-Python字符串常用内建函数/","link":"","permalink":"http://yoursite.com/2018/12/21/day4-Python字符串常用内建函数/","excerpt":"","text":"#Python字符串常用内建函数 #1. capitalize() str1.capitalize() – 将字符串str1第一个字符转换为大写，若不为字母则无效果123str1 = 'cjzh'new_str1 = str1.capitalize()print(new_str1) # Cjzh #2. center() 字符串.center(width,fillchar) – 居中字符串.ljust(width,fillchar) – 左对齐字符串.rjust(width,fillchar) – 右对齐width – 正整数，表示新的字符串的宽度fillchar – 字符，填充字符串123456789str2 = '123'new_str2 = str2.center(7, '$')print(new_str2) # 新字符串7个长度，123居中，其余用$填充 $$123$$new_str2 = str2.ljust(7, '$')print(new_str2) # 新字符串7个长度，123左对齐，其余用$填充 123$$$$new_str2 = str2.rjust(7, '$')print(new_str2) # 新字符串7个长度，123右对齐，其余用$填充 $$$$123 #3. count(str) str1.count(str2) – 返回str2在str1中出现的次数123str3 = 'cj1cj2cj3cj4cj5'n = str3.count('cj')print(n) # 5 #4. bytes.decode(encoding=”utf-8”, errors=”strict”) #5. encode(encoding=’UTF-8’,errors=’strict’) #6. endswith() str1.endswith(char1) – 检查str1是否以char1结尾，返回值为布尔123str6 = 'cj1cj2cj3'bool1 = str6.endswith('3')print(bool1) #True #7. expandtaps(tabsize=8) – 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 #8. find(str,beg=0,end=len(string)) str1.find(str2,0,len(str1)) – 在指定下标范围0~len（str1）内，检查str2是否包含其中，如果包含则返回首个str2(此处为左起第一个类比rfind())开始的下标，否则返回-112345str8 = '0cj1cj2cj'n1 = str8.find('cj', 0, 9)n2 = str8.find('3', 0, 9)print(n1) # 1print(n2) # -1 #9. index(str,beg=0,end=len(string)) str1.index(str2,0,len(str1)) – 在指定下标范围0~len（str1）内，检查str2是否包含其中，如果包含则返回首个str2开始的下标，否则报一个异常:ValueError: substring not found。123str9 = '1cj2cj'n = str9.index('2') #不写范围则默认整个字符串print(n) # 3 如果报异常则以下代码会出错 #10. isalnum() str1.isalnum() – 判断str1是否所有字符都是字母或数字，是则返回True,否则返回False。123str10 = '1cj2cj'bool2 = str10.isalnum()print(bool2) #True #11. isalpha() str1.isalpha() – 如果str1至少有一个字符并且所有字符都是字母则返回 True,否则返回 False12str11 = 'abcdd'print(str11.isalpha()) #True #12. isdigit() str1.isdigit() – 如果str1只包含数字则返回 True 否则返回 False.1print('16217cj1421621'.isdigit()) #False #13. islower() str1.islower() – 如果str1中包含至少一个区分大小写的字符(拉丁文也区分大小写)，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False1print('cj12837138zh'.islower()) #True #14. isnumeric() str1.isnumeric() – 如果字符串中只包含数字字符，则返回 True，否则返回 False（中文数字也可以）12str14 = '1一Ⅰ壹幺'print(str14.isnumeric()) #True #15. isspace() str1.isspace() – 如果str1中只包含空白，则返回 True，否则返回 False.用于判断str1是否为空。12str15 = ' 'print(str15.isspace()) #True 空指的是空格，不是None'' #16. istitle() str1.istitle() – 如果str1是标题化的(见 title())则返回 True，否则返回False12str16 = 'Cj Zh Qf 'print(str16.istitle()) # True #17. isupper() 类比 islower()相反 str1.isupper() – 如果str1中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False12str17 = 'AJKIHdkdj12124'print(str17.isupper()) # False #18. join(seq) 类比 sep = str1.join(str2) – 以str1作为分隔符，分隔str2每一个字符，将str2中所有的元素(的字符串表示)合并为一个新的字符串。123str18 = '￥'new_str18 = str18.join('money')print(new_str18) # m￥o￥n￥e￥y #19. len(str) len(str1) – 返回str1的长度12str19 = '0123456'print(len(str19)) # 7 #20. ljust(width, fillchar) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。见2 #21. lower() str1.lower() – 转换str1中所有大写字符为小写。12str21 = 'aAbBcCjJ'print(str21.lower()) # aabbccjj #22. lstrip() str1.lstrip(char) – 截掉str1左边的空格或指定字符。默认为空格1234str22 = ' cjcjcjcjcj'new_str22 = '#*#jcjcjcjcj'print(str22.lstrip()) #'cjcjcjcjcj'print(new_str22.lstrip('#')) #'*#jcjcjcjcj' #23. maketrans() ?????????? str1.maketrans() – 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 #24. max(str) max(str1) – 返回str1中编码值最大的字母12str24 = 'aAbBcCjJ'print(max(str24)) # j #25. min(str) min(str1) – 返回str1中编码值最小的字母12str25 = 'aAbBcCjJ2234'print(min(str25)) # 2 #26. replace(old,new,max) str3.replace(str1,str2,max]) – 把str3中的str1替换成str2,如果max 指定，则替换不超过 max 次。123str26 = 'aaaaaabbbbbbcccccc12344'new_str26 = str26.replace('a', '$', 3)print(new_str26) # '$$$aaabbbbbbcccccc12344' #27. rfind(str,beg=0,end=len(string)) str1.rfind(str2,0,len(string)) – 从右边开始检测 str2是否包含在str1中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值（正），否则返回-1123str27 = '1cj2cj3cj4zh'print(str27.rfind('c')) # 7 即右起第一个c的位置！！print(str27.rfind('jc')) # -1 没有‘jc’ #28 rindex(str,beg=0,end=len(string)) str1.rindex(str2,0,len(str1)) – 从右边开始检测 str2是否包含在str1中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值（正），否则返回-1。即：右起第一个str2的开始正下标12str28 = 'abababcjcjcjzhzhzh'print(str28.rindex('cj')) # 10 右起第1个‘cj’的开始下标 #29. rjust(width,fillchar) 具体使用见 2 #30. rstrip() str1.rstrip(char1) – 删除str1末尾的指定字符char1，直到不为char1为止，默认char1为空格。1234str30 = '1234asdfcj 'new_str30 = '1234asdfcj#*##'print(str30.rstrip()) # 1234asdfcjprint(new_str30.rstrip('#')) # 1234asdfcj#* #31. split() str1.split(str2,num) – 用char1为分隔符截取str1为一个列表,num表示截取次数默认为char1在str1中出现的次数 即num(默认)=str1.count(str2)。12str31 = 'abc##def##ghi##334##678'print(str31.split('##', 2)) #截取两次 ['abc','def','ghi##334##678'] #32. splitlines([keepends]) str1.splitlines(bool) – 将字符串str1按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果bool为 False，不包含换行符，如果为 True，则保留换行符。12str32 = '123\\n456\\r888\\n'print(str32.splitlines(True)) # ['123\\n','456\\r','888\\n'] #33. startswith(str,beg=0,end=len(string)) str1.startswith(str2,0,len(str1)) – 检查str1是否是以str2开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。12str33 = '123321'print(str33.startswith('12')) # True #34. strip(char) str1.strip(char1) – 删除str1左边lstrip()和右边rstrip的字符char112str34 = '$$123456$$'print(str34.strip('$')) # 123456 #35. swapcase() str1.swapcase() – 将str1中大写转换为小写，小写转换为大写12str35 = 'aAbBcCjJ'print(str35.swapcase()) # AaBbCcJj #36. title() str1.title() – 返回”标题化”的str1,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())12str36 = 'student is teacher' #注意单词之间要用空格隔开print(str36.title()) # Student Is Teacher #37. translate(table, deletechars=””) ??????????????? 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 #38. upper() str1.upper() – 转换str1中的小写字母为大写12str38 = 'AaBbCcJj'print(str38.upper()) # AABBCCJJ #39. zfill(width) str1.zfill(n) – 将str1返回为长度n的新字符串，以原字符串右对齐，前面填充0。123str39 = '123cjcjcj'print(str39.zfill(12)) # 000123cjcjcjprint(str39) # 123cjcjcj #40. isdecimal() str1.isdecima() – 检查str1是否只包含十进制字符，如果是返回 true，否则返回 false。12str40 = '3123443'print(str40.isdecimal()) # True","categories":[],"tags":[]},{"title":"","slug":"day3-python变量和运算符总结","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day3-python变量和运算符总结/","link":"","permalink":"http://yoursite.com/2018/12/21/day3-python变量和运算符总结/","excerpt":"","text":"#1.变量 ##1.1声明变量（定义变量） 变量就是在程序中用来保存数据的容器 在python中是个假的声明，语法：变量名 = 值 说明：变量名 – 要求：标识符，不能是关键字 **规范：** **a.**遵守PEP8命名规范（变量名名字的所有字母都小写，如果由多个单词组成，单词之间用_隔开），如：student_name **b.**见名知义（看到名字就知道变量中存的是什么数据） “=” – 赋值符号，将=右边的值放入左边的变量中值 – 可以是任何有结果的表达式，如：190 ， 变量 ， 调用函数表达式等 1234age = 18name = &apos;小王&apos;number = 666print(age,name,number,sep=&apos;-----&gt;&apos;) #使用变量，就是使用变量中保存的值 1234#变量必须先声明（赋值）再使用#同时给多个变量赋同一个值num1 = num2 = num3 = 66print(num1,num2,num3) 12345678910111213#同时给多个变量赋不同的值。（注意：变量的个数和值的个数要保持一致）n1,n2,n3 = 1,2,3print(n1,n2,n3)num4 = 100num4 = 200print(num4) #给同一个变量赋值，后附的值会覆盖掉先附的值num4 = &apos;abc&apos;print(num4) #同一个变量可以存储不同类型的值！！！num4 = [1,2,3]print(num4)num4 = &#123;&apos;a&apos;:100,&apos;b&apos;:200&#125;print(num4) ##1.2python中声明变量和给变量赋值的本质 C中声明变量：int num = 10; Python中声明变量：num = 10num = ‘321ewqfwfdfwgtre’ 结论： python中所有的变量，存的都是数据在内存中的地址（即C中的指针）。内存地址的大小一样，修改变量也只是改变num对应的地址。 用一个变量给另一个变量赋值，实质是将新变量地址赋给旧的变量。使用变量的时候，是使用的变量中地址对应的值。##1.3变量的三要素：值、地址和类型值：变量中存的地址对应的值地址：变量中存储的地址（id）类型：变量中存的地址对应的类型1234567name1 = '小明'name2 = name1print(name1) #使用变量拿到变量中地址对应的值print(id(name1)) #id(变量) -- 获取变量中存储的地址print(id(name2)) #两者地址相同，获取的是同一个地址。print(type(name1)) #查看变量中地址对应的类型 #2.运算符 python中的运算符：数学运算符，比较运算符，逻辑运算符，赋值运算符，位运算符。##2.1数学运算符：+ - * / % // ** +：加法运算-：减法运算*：乘法运算/：除法运算%：求余运算//：整除**：幂运算 ###2.1.1 % 应用：1.获取一个整数的最低位的一位或几位的值 num % （10^n）2。判断一个数是否能被另一个数整除 num1 % num2123456print(10 % 3) # % -- 取余#获取一个数的个位数num = 23232432print(num % 10) #3print(num % 100) #23#与2取余可判断奇偶性 ###2.1.2 // – 求商，获取商的整数部分12345print(5//2) #2print(3.9//3) #1.0num = 289print(num // 100) #取一个3位数百位上的值 ###2.1.3 ** – 幂运算1234#x**y -- 求x的y次方print(2**10) #2的10次方print(9**0.5) #9开平方，结果为浮点数print(8**(1/3)) #8开3次方，结果为浮点数 ##2.2比较运算符： &gt; &lt; == != &gt;= &lt;=123#所有的比较运算符的结果都是布尔值。print(100 &gt; 10) #Trueprint(10 &gt; 100) #False ##2.3逻辑运算符： and or not逻辑运算符的运算对象及结果都是布尔值。 ###2.3.1 and – 逻辑‘与’运算 值1 and 值2：判断是否为真，如果两者都为True，则结果为True； 果两者有一个为False，则结果为False。 逻辑与运算相当于生活中的‘并且’；当需要多个条件同时满足，就使用and将多个条件连接在一起1234grade = 99score = 80print(&apos;是否获取奖学金：&apos;,grade &gt; 90 and score&gt;95) #False#例子：要求成绩大于90，且表现分大于95，才能获得奖学金 ###2.3.2 or – 逻辑‘或’运算 值1 or 值2：如果值1 和 值2 有一个True就为真，两个都为False才为False 逻辑或运算，相当于生活中的‘或者’。当需要多个条件中至少有一个条件满足，就用or连接。1234grade = 99score = 80print(&apos;是否获取奖学金：&apos;,grade &gt; 90 or score&gt;95) #False#例子：要求成绩大于90，且表现分大于95，才能获得奖学金 ###2.3.3 not – 逻辑‘非’运算 not 值 ： 如果值是True，结果就是False；如果值是False，结果就是True。1234age = 21print(&apos;是否能进入网吧：&apos;,not age &lt; 18 ) #True#not用来对某个条件进行否定。print(&apos;是否能进入网吧：&apos;,age &gt; 18 ) #True #3.赋值运算和位运算 ##3.1赋值运算符：= += -= /= *= %= //= **= 所有赋值符的左边必须是变量；组合的赋值运算符的左边的变量必须已经赋值；所有赋值运算符最终都会进行赋值操作 ###3.1.1 = – 直接将右边结果赋给左边的变量1num = 100 ###3.1.2 += -= *= /= %= //= **= 变量 += 值 –&gt; 相当于 变量 = 变量 + 值变量 -= 值 –&gt; 相当于 变量 = 变量 - 值变量 = 值 –&gt; 相当于 变量 = 变量 值变量 /= 值 –&gt; 相当于 变量 = 变量 / 值变量 %= 值 –&gt; 相当于 变量 = 变量 % 值变量 //= 值 –&gt; 相当于 变量 = 变量 // 值变量 = 值 –&gt; 相当于 变量 = 变量 值12345678910111213num1 = 1num1 += 10print(num1)num1 *= 3print(num1)num1 %= 2print(num1)num1 -= -100num1 //= 2print(num1) ##3.2运算符的优先级 数学运算符 &gt; 比较运算符 &gt; 逻辑运算符 &gt; 赋值运算符优先级高的先算。如果有括号，先算括号里面的。123456789101112num = 10 + 20 &gt; 25 and True &lt;2#num = 30 &gt; 25 and True &lt;2#num = True and True#num = Trueprint(num)num = 10 + (20 &gt; 25 and True &lt;2)#num = 10 + (False and True &lt; 2)#num = 10 + False#num = 10num = 10 + 2*3**2 # 28 ** &gt; * ##3.3位运算 符号： &amp;（按位与） |（按位或） ^（按位异或） ~(按位取反) &lt;&lt;(左移) &gt;&gt;(右移) 位运算是针对二进制中每一位进行的相关操作###3.3.1 &amp; 数字1 &amp; 数字2 —&gt; 对二进制数的每一位进行‘与’运算，运算时如果都为1结果就是1，否则为0。1 &amp; 1 = 11 &amp; 0 = 00 &amp; 1 = 00 &amp; 0 = 0与的特点： 一位上的数如果和1与，就会保留这一位上的数。如果和0与，就会将这一位，置0。11010 &amp; 00111 = 000103(原) = 0011 = 3（补）2（原）= 0010 = 2（补）-2（补）= 1110 00100010 与运算的应用：判断一个数是否是偶数（最优算法）二进制数末尾为1则为奇数 1101 &amp; 1 —&gt; 1 奇数二进制数末尾为0则为偶数 1100 &amp; 1 —&gt; 0 偶数将数字和1与，如果结果为0，则为偶数。将数字和1与，如果结果为1，则为奇数。12345print(3 &amp; 2)print(3 &amp; -2)print(88 &amp; 1) # 0print(99 &amp; 1) # 1 ###3.3.2 | 数字1 | 数字2 —&gt; 对二进制数的每一位进行‘或’运算，运算时如果都为0结果就是0；如果有一个为1，则为1。1 | 1 = 11 | 0 = 10 | 1 = 10 | 0 = 01101 | 1010 = 1111 3 | 2011 | 010 —&gt; 0113 | 20000011 | 010100 —&gt; 010111 补码-3 | 20111101 补码010100 —&gt; 111101补码 111100反码–&gt;100011原码–&gt;-312print(3 | 1)print(3 | 0) ###3.3.3 按位取反 ~ 数字 ：将每一位取反（0–&gt;1,1–&gt;0），对补码取反~2 010 101补码 100反码 111原码1print(~2) ###3.3.4 按位异或 数字1 ^ 数字2 – 每一位相同为0，不同为1。1 ^ 1 = 01 ^ 0 = 10 ^ 1 = 10 ^ 0 = 0 11 ^ 20 1011 ^ 0 0010 = 0 1001(补码)可用于判断两个值是否相等，相同为0，不同不为0。print(11 ^ 2) # 9 ###3.3.4 左移 数字1 &lt;&lt; n（位数） - 将数字1的二进制数的每一位向左移n位，移出多少位后面加多少个0。即在数字后面加n个0。10 &lt;&lt; 10000 1010（补码） —&gt; 0001 0100（补码）0001 0100结论：数字1 &lt;&lt; n = 数字1 * 2^n123456print(10 &lt;&lt; 1) # 20print(10 &lt;&lt; 2) # 40print(10 &lt;&lt; 3) # 80print(-10 &lt;&lt; 1) # -20print(-10 &lt;&lt; 2) # -40print(-10 &lt;&lt; 3) # -80 ###3.3.5 右移 数字1 &gt;&gt; n（位数） - 将数字1的二进制数的每一位向右移n位，移出多少位将低位删除指定的位数。12310 &gt;&gt; 10000 1010（补码） ---&gt; 0 101（补码） 5 结论：数字1 &gt;&gt; n = 数字1 // 2^n123456print(10 &gt;&gt; 1) #5print(10 &gt;&gt; 2) #2print(10 &gt;&gt; 3) #1print(-10 &gt;&gt; 1)print(-10 &gt;&gt; 2) # ？？print(-10 &gt;&gt; 3) #4.字符串 ##4.1 什么是字符串 字符串是python中一种常用的 有序 但是 不可变的 容器类的数据类型，可以同时存储多个字符。属于序列 字面量：使用单引号或者双引号将任意字符括起来，就是字符串常量。str1 = ‘都会死恢复到萨格fdsfdsfurui22’ 字符：指的是字符串中的每一个单元。注意，python中只有字符的概念，没有字符类型 ##4.2 字符串中的内容a.普通字符：包含数字字符、字母、普通符号：+ - () % # @ 中文 等 ‘123 ’ ‘味位’ b.转义字符：通过反斜杠将一些字符转换成有特殊功能或特殊意义的字符 \\n – 换行\\t –制表符\\ –\\\\’ –’\\” –” 注意：一个转义字符代表一个字符 c.阻止转义：在字符串最前面加r 或 R，可以阻止转义字符转义12345print(&apos;\\t abc\\n123&apos;) # abc 123print(&apos;abc\\&apos;123&apos;) #abc&apos;123print(r&apos;abc\\&apos;123&apos;) #abc\\&apos;123print(R&apos;\\t abc\\n123&apos;) #\\t abc\\n123","categories":[],"tags":[]},{"title":"","slug":"day2-python基础语法总结","date":"2018-12-21T01:34:21.336Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day2-python基础语法总结/","link":"","permalink":"http://yoursite.com/2018/12/21/day2-python基础语法总结/","excerpt":"","text":"#1、常用快捷键 添加或取消一行注释：ctrl+/（通用） ctrl+s 保存 ctrl+n 新建 ctrl+f 搜索 ctrl+r 搜索替换 ctrl+z 撤销 ctrl+shift+z 反撤销 ctrl+a ctrl+c trl+v ctrl+d 复制上一行代码到下一行 tab 补充代码程序中涉及到的所有的和语法相关的符号，都是英文输入法下对应的符号print是python内置函数，在控制台打印括号中的内容引号是字符串的标志12print(\"Hello world!\")print('Hello Hello Hello') 运行结果： #2、python基础语法 ##2.1注释 注释是程序中说明文字，不会参与程序的编译和执行，对程序和功能没有任何影响。 单行注释：在说明性文字前加# 多行注释，3’或3”括起来，来设置多行注释， 一般使用3个” ##2.2标识符 标识符是专门用来给变量、函数、类等命名的。要求：python中的标识符要求是由数字、字母和下划线组成，并且数字不能开头注意：1.在python3.x，标识符中可以包含非ASCII码字符，如汉字、日语、韩语、拉丁等。2.开发时不要使用非ASCII码字符。例： 123num = 100_num = 200__ = 300 1num = 400 错误，不能以数字开头 n - num = 500 错误，减号也不行，只能是数字、字母和下划线 ##2.3行与缩进 python中对代码里面的缩进有严格要求。同一级代码前面的缩进（空格/tab）的个数必须一致，否则报错。 用空格或tab都行，一般用tab 行的规范：要求声明函数和类的前后需要有两个空行。 #2.4分段（行）显示 一句代码很长，需要多行显示的时候，可以在需要换行的位置加\\，表示前后是一行，后面的行无缩进要求，建议对齐注意：加\\时，不能将一个数据，一个变量名给拆开。 12num = 28 + 3333333333333333333\\ + 23333 如果代码是列表、元组、字典、集合的字面量，可以直接换行，不用加\\ ##2.5一行显示多条语句 一般要求一条语句写一行，如果一行写多条语句它们之间需要加 ;例：1print(1);print(2);print(3) #2.6关键字（保留字） python中已经定义好有特殊功能和意义的一些标识符，就是python的关键字，命名时不能使用。12import keyword #导入模块print(keyword.kwlist) #打印python中关键字列表 输出结果：[‘False’, ‘None’, ‘True’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’,‘def’, ‘del’, ‘elif’, ‘else’, ‘except’,‘finally’, ‘for’, ‘from’, ‘global’,‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’匿名, ‘nonlocal’, ‘not’, ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’] #2.7print函数和input函数 print(内容)–在控制台中打印内容，内容必须是python数据 print(内容1，内容2)–在一行打印多个内容，显示时它们之间用空格隔开 默认情况下，一个print中的内容占一行（以换行结束）。一个print中的多个内容用空格隔开print(内容1，内容2，…,end=’换行标志’)print(内容1，内容2，…,seq=’分割标志’)例：12345_num = 200print(&apos;a&apos;,&apos;b&apos;,_num,end=&apos;------&gt;&apos;)print(1)print(2)print(&apos;a&apos;,&apos;b&apos;,_num,sep=&apos;-----&gt;&apos;) 输出结果： input()–从控制台输入一串内容，以回车结束。并将内容以字符串形式返回注意：程序执行到input的时候，程序会停下来，直到输入完成位置。input(‘提示信息’)–先打印提示信息，后执行input。例：123456789101112131415def f(x,y): sum = x + y return(sum)l=[]a = int(input(&quot;请输入第一个数字：&quot;))b = int(input(&quot;请输入第二个数字：&quot;))n = 0while n &lt; 100: c = f(a,b) l.append(c) a,b = b,c n = n+1print(l) 输出： #3.常用数据类型 ##3.1常见数据类型及其字面量（常量） python中常用数据类型有：整型：100，23，-122，333等，所有的整数浮点型：12.3，45.0，-0.123456 所有的小数布尔： True，False 首字母需大写字符串：’任’,”意”,’字’,”符” 由双引号或单引号括起来的内容列表： [12，’abc’,True]字典: {key1:value1,key2:value2,key3:value3} {‘a’:120,’b’:110,’c’:100}元组: (12，’abc’,True)集合:函数;等##3.2数字相关类型 python中和数字相关的类型：整型、浮点型、布尔、复数（虚数5j+1）1.整型（int）：整数对应的类型，包含所有整数。python3中整数对应的类名只有int，python2中除了int还有long型 python中的整数，可用十进制、二进制、八进制、十六进制来表示2.浮点型（float）：小数对应的类型，包含了所有的小数。支持科学计数法。3.布尔（bool）：只有两个值True和False，都是关键字，首字母大写，分别表示“真”和“假”。True实质是数字1，False实质是数字0。4.复数（complex）：表示所有的虚数对应的类型，用“数字+j”表示虚部，实部就是普通数字。12345print(2e4) # 2*10^4 = 20000print(3e-2) # 3*10^-2 = 0.03print(1+True,1+False) # 2 和 1print((1+2j)+(2-1j)) # 3-1j ##3.3type函数 type(数据)–获取数据的类型1print(type(666)) # int ##3.4isinstance函数 isinstance(数据，类型)–判断指定的数据是否是指定的类型，结果为bool值。12print(isinstance(100,float)) #判断100是否为浮点型，Falseprint(isinstance(100,int)) #判断100是否为浮点型，True #3.5类型的强制转换 目标类型名（需要转换的数据）–将指定的数据转换成目标类型,所有的类型都可以。 浮点型转换成整型：直接去掉小数部分 整型转换成浮点型：在整数后加.0 其他类型转布尔：bool(),所有的数据都能转成bool值。除了0转换成False，其他全为True。注意：复数不能转换成整型或浮点型，但能转换成布尔型。12345678b = int(12.5)print(b) # 12print(float(b)) # 12.0print(bool(b)) # Trueprint(bool(-b)) # Trueprint(float(True)) # 1.0print(complex(10)) # 10+0jprint(complex(-10)) # -10+0j #4.进制 ##4.1十进制 基数：0，1，2，3，4，5，6，7，8，9 进位：满10进1 位权：123 = 110^2 + 210^1 + 3*10^0 第n位的位权为 (10^(n-1)) 表示方式：所有的数字都是10进制（数字直接写）123203312 ##4.2二进制 基数：0，1 进位：满2进1 位权：1101 = 12^3 + 12^2 + 02^1 + 12^0 = 13 第n位的位权为 (2^(n-1))从1开始记位 表示方式：在二进制数前加前缀—-&gt; 0b或0B1230B110 + 0B011 # 10010B1 + 0B1 # 100B110 - 0B011 # 011 ##4.3八进制 基数：0，1，2，3，4，5，6，7 进位：满8进1 位权：123 = 18^2 + 28^1 + 3*8^0 第n位的位权为 (8^(n-1))从1开始记位 表示方式：在八进制前加前缀—-&gt; 0o或0O 大小写都可以10o12 + 0o26 #0o40 ##4.4十六进制 基数：0，1，2，3，4，5，6，7，8，9，a(10),b(11),c(12),d(13),e(14),f(15)(A-F) 大小写都可以进位：满16进1 位权：123 = 116^2 + 216^1 + 3*16^0 第n位的位权为 (16^(n-1))从1开始记位 表示方式：在十六进制前加前缀—-&gt; 0x或0X 大小写都可以123print(0x12a) #结果为10进制数print(0xabc12)print(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) ##4.5其他进制和十进制之间的转换 1.其他进制转十进制：每一位数*权值，再求和2.十进制转其他进制：累除 ##4.6二进制和八进制、十六进制互转1.二进制转八进制：每3位2进制转成1位八进制。 八进制转2进制：每1位八进制转成3位二进制|0b|001 |100 |100 |110 |010 |011 |100 |= |0o1446234||–: |–:|–:|–:|–:|–:|–:|–:|–:|–:| |表示|1 |4 |4 |6 |2 |3 | 4 二进制小数—————&gt;&gt;&gt;&gt;十进制小数“按权展开求和法”：例1：将101.111(2)转换成十进制数 1*(2^2) + 0*(2^1) + 1*(2^0) + 1*(2^(-1)) + 1*(2^(-2)) + 1*(2^(-3))=5.875 只要记住个位数是2的0次方，往右一次增加，往左一次减少，写出关系式之后各式相加就是所求 十进制小数————–&gt;&gt;&gt;&gt;二进制小数（十进制数的整数位是二进制数的整数位，十进制数的小数位是二进制数的小数位）“乘二取整法”（顺序排列）：假如我们有小数111.4（10），我们对他进行一下计算：首先取小数位0.4，对其进行“乘二取整法”0.42=0.8 取结果的的整数位置上的数是0 | 按 （取整法就是取整数位上的数字）0.82=1.6 取1 | 顺0.62=1.2 取1 | 序0.22=0.4 取0 | 写0.42=0.8 取0 | 出0.82=1.6 取1 |0.62=1.2 取1 |0.22=0.4 取0 |来到这了，我们发现出现了循环，因此可以推知小数点后的二进制是0.01100110……（循环0110）接下来是整数111我们这里用“除以2取余法，逆序排列”所以整数位是1101111最终结果是整数位和小数位合并1101111.01100110……（2）当我们对小数0.1（10） 0.2（10） 0.3（10） 0.4（10） 0.5（10） 0.6（10） 0.7（10） 0.8（10） 0.9（10）发现只有0.5(10)不会出现循环小数,他转换成二进制是0.1(2)其余的出现循环的小数 2.二进制转十六进制：每4位2进制转成1位十六进制。 十六进制转2进制：每1位十六进制转成4位二进制|0b |0110 |0100 |1100 |1001 |1100 |= |0x64c9c ||–: |–:|–:|–:|–:|–:|–:|–:| |表示|6 | 4 | c |9 |c | 0x6745 = 0b0110 0111 0100 01010xa12 = 0b1010 0001 0010 3.八进制转十六进制：先转为二进制。 ##4.7进制转换相应的函数–返回值是字符串 bin(数字)– 将其他进制的数转为二进制数 oct(数字)–将其他进制的数转为八进制数 hex(数字)–将其他进制的数转为十六进制所有进制计算时均会自动转换成十进制1234print(bin(0x6745)) #0b110011101000101print(bin(0o1446234)) #0b1100100110010011100print(oct(0x6745)) #0o63505print(hex(0o1446234)) #0x64c9c #5.原码、反码和补码 ##5.1计算机数据的存储 以下值均为二进制 计算机能直接存储的是数字，并且存的是数字的补码 ##5.2计算机内存大小单位 位（bit）1字节 = 8位1kb = 1024字节1mb = 1024kb1GB = 1024mb1TB = 1024Gb ##5.3原码 符号位+真值 （用最高位表示符号位，后面的即为数字的二进制）符号位： 0 ---&gt; 正，1---&gt; 负 真值： 数字对应的二进制值 10(原码) = 0 000 1010-10（原码）= 1 000 1010 ##5.4反码 正数的反码和原码一样。负数的反码是符号位不变，其他位上的数取反（0变1，1变0） 10(反码) = 0 000 1010-10（反码）= 1 111 0101 ##5.5补码： 正数的补码和原码一样。负数的补码是它的反码加1。 10(补码) = 0 000 1010-10（补码）= 1 111 0110 注意：数据存储和运算的时候采用的是补码。看结果看的是原码。单片机 只有加法和乘法器案例： 如果计算机存储的是原码：3：00112：00103+2 = 0101 = 5 原码：3-2 = 3+(-2) = 1101 = -53: 0011-2:1010 补码：3(补) = 0011-2(补) = 1101(反) = 1110(补)0011(补)+1110(补) = 0001(补) = 0001(原) = 1 2-32：0010（原）= 0010（补）-3：1011（原） = 1100（反）= 1101（补码）0010（补）+ 1101（补码） = 1111（补码）= 1110（反） = 1001 = -1","categories":[],"tags":[]},{"title":"","slug":"day17-作业","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day17-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day17-作业/","excerpt":"","text":"写一个正则表达式判断一个字符串是否是ip地址规则：一个ip地址由4个数字组成，每个数字之间用.连接。每个数字的大小是0-255255.189.10.37 正确256.189.89.9 错误 12345678910111213import re\"\"\"3位数：1\\d&#123;2&#125;|2[1-5]&#123;2&#125;2位数和1位数：[1-9]?\\d\"\"\"# re_str = r'(1\\d&#123;2&#125;[.]|2[1-5]&#123;2&#125;[.]|[1-9]?\\d[.])&#123;3&#125;(1\\d&#123;2&#125;[.]|2[1-5]&#123;2&#125;[.]|[1-9]?\\d)'# print(re.fullmatch(re_str, '255.189.10.37'))# print(re.fullmatch(re_str, '256.189.10.37'))re_str = r'(1\\d&#123;2&#125;[.]|2[1-5]&#123;2&#125;[.]|[1-9]?\\d[.])&#123;4&#125;'print(re.fullmatch(re_str, '255.189.10.37' + '.'))print(re.fullmatch(re_str, '256.189.10.37' + '.')) 计算一个字符串中所有的数字的和例如：字符串是：‘hello90abc 78sjh12.5’ 结果是90+78+12.5 = 180.5 123456789101112import rere_str = r&apos;\\d+[.]\\d+|\\d+&apos; # 注意短路sum1 = 0str1 = &apos;hello90abc 78sjh12.5ewed0.01&apos;str1_list = re.findall(re_str, str1)# print(str1_list)for items in str1_list: sum1 += float(items)print(sum1) # 180.51 验证输入的内容只能是汉字 12345678import rere_str = r'[\\u4e00-\\u9fa5]+'while 1: str1 = input('请输入：') if not re.fullmatch(re_str, str1): print('%s 不是中文' % str1) 电话号码的验证 12345import rere_str = r'(13\\d|14[597]|15[0-35-9]|166|17[1-35-8]|18\\d|19[89])\\d&#123;8&#125;'print(re.fullmatch(re_str, '18408266188')) 简单的身份证号的验证 123456import rere_str = r'5\\d&#123;5&#125;(198[4-9]|199\\d|200\\d|201[0-8])(0[1-9]|1[1-2])(0[1-9]|[12]\\d|3[0-1])\\d&#123;3&#125;\\w'# r'\\w*'print(re.fullmatch(re_str, '511621199412087533')) 二、不定项选择题 能够完全匹配字符串“(010)-62661617”和字符串“01062661617”的正则表达式包括（ ABD） A. “(?\\d{3})?-?\\d{8}”B. “[0-9()-]+”C. “[0-9(-)]\\d”D. “[(]?\\d*[)-]*\\d*” 能够完全匹配字符串“c:\\rapidminer\\lib\\plugs”的正则表达式包括（ B C）A. “c:\\rapidminer\\lib\\plugs”B. “c:\\rapidminer\\lib\\plugs”C. “(?i)C:\\RapidMiner\\Lib\\Plugs” ?i:将后面的内容的大写变成小写D. “(?s)C:\\RapidMiner\\Lib\\Plugs” ?s：单行匹配 能够完全匹配字符串“back”和“back-end”的正则表达式包括（ ABCD）A. “\\w{4}-\\w{3}|\\w{4}”B. “\\w{4}|\\w{4}-\\w{3}”C. “\\S+-\\S+|\\S+”D. “\\w\\b-\\b\\w|\\w*” 能够完全匹配字符串“go go”和“kitty kitty”，但不能完全匹配“go kitty”的正则表达式包括（ AD）:\\1就是重复前面第一个()/组合里面的内容：\\2就是重复前面第二个()/组合里面的内容A. “\\b(\\w+)\\b\\s+\\1\\b”B. “\\w{2,5}\\s*\\1”C. “(\\S+) \\s+\\1”D. “(\\S{2,5})\\s{1,}\\1” 能够在字符串中匹配“aab”，而不能匹配“aaab”和“aaaab”的正则表达式包括（BC ）A. “a*?b”B. “a{,2}b”C. “aa??b”D. “aaa??b”","categories":[],"tags":[]},{"title":"","slug":"day18-作业","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day18-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day18-作业/","excerpt":"","text":"作业： 客户端和服务器聊天，可以一直聊天，直到一方发送’拜拜’。然后就可以和下一个人一直聊服务器：1234567891011121314151617181920212223import socketserver = socket.socket()server.bind(('10.7.187.55', 8888))server.listen(100)print('开始监听。')while 1: conversation, address = server.accept() while 1: get_data = conversation.recv(1024) print('客户端：', get_data.decode('utf-8')) if get_data.decode('utf-8') == '拜拜': print('客户端已退出连接，等待下次客户端请求：', address) break send_data = input('服务器：') conversation.send(send_data.encode('utf-8')) if send_data == '拜拜': print('已断开本次连接，等待下次客户端请求：') break 客户端：123456789101112131415161718import socketclient = socket.socket()client.connect(('10.7.187.55', 8888))while 1: send_data = input('客户端：') client.send(send_data.encode('utf-8')) if send_data == '拜拜': print('已断开本次连接。') break get_data = client.recv(1024) print('服务器：', get_data.decode('utf-8')) if get_data.decode('utf-8') == '拜拜': print('服务器已断开本次连接。') break 2.客户端给服务器发送请求，请求成功后，客户端给服务发送‘1’，服务器就给客户端发送一张图片；客户端给服务发送‘2’，服务器就给客户端返回一个json文件中的内容;客户端给服务发送‘3’, 服务器返回’拜拜’,然后断开连接服务器：123456789101112131415161718192021222324252627282930import socketimport jsonserver = socket.socket()server.bind(('10.7.187.55', 8888))server.listen(200)print('开始监听：')while 1: conversation, adress = server.accept() while 1: get_data = conversation.recv(1024) print('客户端：', get_data.decode('utf-8')) if get_data.decode('utf-8') == '3': send_data = '拜拜！' conversation.send(send_data.encode('utf-8')) print('当前客户端已断开连接。', adress) break elif get_data.decode('utf-8') == '1': with open('王也.jpg', 'rb') as f: send_data = f.read() conversation.send(send_data) print('已发送图片。') elif get_data.decode('utf-8') == '2': with open('files/测试文件.json', 'r', encoding='utf-8') as f: content = json.load(f) conversation.send(str(content).encode('utf-8')) print('已发送文件。') 客户端：12345678910111213141516171819202122232425262728import socketclient = socket.socket()client.connect(('10.7.187.55', 8888))while 1: send_data = input('客户端：') client.send(send_data.encode('utf-8')) if send_data == '3': print('已退出连接。') break elif send_data == '1': content = bytes() while 1: get_data = client.recv(1024) content += get_data print(len(get_data)) # if len(get_data) == 39: if len(get_data) &lt; 1024: break with open('接收文件/图片1.jpg', 'bw') as f: f.write(content) print('接收图片成功。') elif send_data == '2': get_data = client.recv(1024) print('服务器：', get_data.decode())","categories":[],"tags":[]},{"title":"","slug":"day18-网络编程","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day18-网络编程/","link":"","permalink":"http://yoursite.com/2018/12/21/day18-网络编程/","excerpt":"","text":"#18.1 socket编程 socket又叫套接字，指的就是实现通信过程的两个端。等待请求的叫服务端套接字，发送请求的叫客户端 python中提供了socket模块来支持socket编程。1import socket 1.服务器套接字 1.创建套接字对象socket(family,type)family - 设置ip类型 AF_INET(默认值) - ipv4 AF_INET6 - ipv6type - 设置传输类型 SOCK_STREAM - tcp123# server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 创建一个基于ipv4和TCP的套接字对象server = socket.socket() # 都是默认值 2.绑定ip地址和端口bind((ip地址,端口号))ip地址 - 服务器对应的计算机的ip地址，字符串端口号 - 用来区分计算机上不同的服务(应用)；是一个数字，范围是0-65535，但是其中1024以下的是著名端口，用来表示一些特殊的应用或服务，一般不要用。同一时间一个端口只能对应一个服务1server.bind(('10.7.187.55', 8081)) 3.开始监听请求listen(最大监听数) - 用于设置服务器一次可以处理多少个请求12server.listen(100)print('开始监听') 4.让服务器一直处于启动状态1while True: 5.接收客户端发送的请求，返回请求地址和会话对象：注意，这段代码会阻塞线程（程序运行到这会停下来，直到有客户端给当前服务器发送请求为止。）123456# server.accept()conversation, addr = server.accept()print('接收到请求，%s%s' % (conversation, addr))# conversation, addr = server.accept()# print('接收到请求，%s%s' % (conversation,addr)) 6.接收消息（客户端发送给服务器消息） recv(缓存大小) - 获取客户端给服务器发送的数据，返回值是二进制 缓存大小 - 决定一次可以接收的最大字节数12re_data = conversation.recv(1024)print(re_data.decode('utf-8')) 7.发送数据 send（数据） - 将指定的数据发送给客户端 数据 - 要求是2进制。 字符串（str）转二进制（bytes） a.bytes（字符串，’utf-8’） b.str1.encode(encoding=’utf-8’) 二进制转字符串 a.str(二进制数据，’utf-8’) b.二进制.decode(‘utf-8’)123# message = 'HTTP/1.1 200 OK\\r\\n\\r\\n 111333！'message = '下午好！'conversation.send(bytes(message, 'utf-8')) 8.关闭连接1conversation.close() #18.2 客户端套接字1import socket 1.创建套接字对象1client = socket.socket() 2.链接服务器connect((ip,端口))1234client.connect(('10.7.187.55', 8081))# client.connect(('10.7.187.149', 8081))while 1: 3.发送消息123message = input('&gt;&gt;')client.send(message.encode('utf-8'))flag = False 4.接收消息123# client.recv(1024) # 超过会分段，因为TCP协议re_data = client.recv(1024)print(re_data.decode('utf-8')) #18.3 图片servers123456789101112131415161718192021222324252627import socket# 创建套接字对象server = socket.socket()# 绑定ip和端口server.bind(('10.7.187.55', 9090))# 监听server.listen(512)while True: # 接收请求 conversation, addr = server.accept() # 执行到这才链接 # 保持通话 while True: data = conversation.recv(1024) print('客户端：', data.decode('utf-8')) # 发送消息 message = input('服务器：') conversation.send(message.encode('utf-8')) # # 发送图片 # with open('', 'br') as f: # content = f.read() # conversation.send(content) conversation.close() #18.4 图片客户端12345678910111213141516171819202122232425import socketclient = socket.socket()# client.connect(('10.7.187.55', 9090))client.connect(('10.7.187.149', 9092))while True: # 发送消息 message = input('客户端：') client.send(message.encode('utf-8')) # 接收消息 data = client.recv(1024) print('服务器：', data.decode('utf-8'))# # 不断接收数据，直到接受完为止# # 创建一个空的二进制数据# data = bytes()# while True:# re_data = client.recv(1024)# data += re_data# if not re_data:# break## with open('new.png', 'bw') as f:# f.write(re_data) 18.5 网络请求1234567891011121314# url# 协议://主机地址/路径\"\"\"协议：不同\"\"\"\"\"\"python中做http请求需要第三方库requests\"\"\"import requests\"\"\"get(url,（参数字典）**kwargs) - 返回响应\"\"\" 1.向服务器发送get请求123456789# a.手动拼url# url = 'https://www.apiopen.top/satinApi?type=1&amp;page=1'# response = requests.get(url)# print(response)# b.自动拼接urlurl = 'https://www.apiopen.top/satinApi'response = requests.get(url, &#123;'type': 1, 'page': 1&#125;)print(response) # &lt;Response [200]&gt; 2.获取响应头12header = response.headersprint(header) 3.获取响应体 a.以二进制形式获取相应体12content = response.contentprint(content, type(content)) # byte b.获取json格式响应体 - 自动将json数据转换成python12json = response.json()print(json, type(json)) # dict c.获取字符串格式响应体12text = response.textprint(text, type(text)) # str 12345678# 应用 下载网络图片url = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1543395098&amp;di=2a5bbaa5600097b050ba69a688672de9&amp;src=http://p0.qhimgs4.com/t0112e7ebfdef7f923d.jpg'response = requests.get(url)image = response.contentwith open('王也.jpg', 'wb') as f: f.write(image)","categories":[],"tags":[]},{"title":"","slug":"day19-多线程","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day19-多线程/","link":"","permalink":"http://yoursite.com/2018/12/21/day19-多线程/","excerpt":"","text":"#19.1 耗时操作 一个进程默认有一个线程，这个线程叫主线程。默认情况下，所有的代码都是在主线程中执行的。1234567891011121314import time,datetimedef download(file_name): print('开始下载：%s' % file_name, datetime.datetime.now()) time.sleep(5) # 程序执行到这会停5秒，再执行后面的代码 print('%s下载结束' % file_name, datetime.datetime.now())# 在主线程中下载俩个电影download('小黄人')download('地心游记') #19.2 多线程 python中提供threading模块来支持多线程技术 默认创建的线程叫主线程，其它的线程叫子线程，如果希望代码在子线程中执行，必须手动创建线程对象。123456789101112131415import threadingimport time,datetimedef download(file_name): print('开始下载：%s' % file_name, datetime.datetime.now()) time.sleep(5) # 程序执行到这会停5秒，再执行后面的代码 print('%s下载结束' % file_name, datetime.datetime.now()) print(threading.current_thread()) # 当前线程# # 在主线程中下载俩个电影# download('小黄人') # &lt;_MainThread(MainThread, started 14148)&gt;## download('地心游记') # &lt;_MainThread(MainThread, started 14148)&gt; 1.创建线程对象a.Thread - 线程类b.Thread(target=函数名,args=参数列表) - 直接创建线程对象，返回线程对象函数名 - 需要在当前创建的子线程中执行的函数变量参数列表 - 元组，元组的元素是函数的参数元组，注意参数只要1个时别忘了逗号。12t1 = threading.Thread(target=download, args=('小黄人', ))t2 = threading.Thread(target=download, args=('地心游记', )) 2.在子线程中执行任务在这就是调用t1对应的线程中调用download函数，并传1个参数’小黄人‘12t1.start() # &lt;Thread(Thread-1, started 16228)&gt;t2.start() # &lt;Thread(Thread-2, started 15660)&gt; #19.3 线程类子类1from threading import Thread,current_thread 创建子线程除了直接创建Thread对象，还可以创建这个类的子类对象 注意：一个进程有多个线程，进程会在所有的线程结束后才结束12345678910111213141516171819202122# 1.声明一个类，继承Threadclass DownloadThread(Thread): # 想要给run方法传值，通过添加对象属性来传 def __init__(self, filename): super().__init__() self.filename = filename # 重写run方法 def run(self): # 这里的代码会在子线程中执行 print(&apos;run&apos;) print(current_thread())# 3.创建线程对象t1 = DownloadThread(&apos;789&apos;)# 4.通过线程对象调用start在子线程中执行run方法t1.start() # &lt;DownloadThread(Thread-1, started 17764)&gt;t1.run() # 主线程执行&lt;_MainThread(MainThread, started 18984)&gt; #19.4 join函数 线程对象.join（） - 等待线程对象执行完成123456789101112131415161718192021222324252627282930import time,datetime,randomfrom threading import Threadclass DownThread(Thread): def __init__(self, file_name): super().__init__() self.file_name = file_name def run(self): print('开始下载:%s' % self.file_name) t = random.randint(5, 12) time.sleep(t) print('结束下载:%s' % self.file_name) print('耗时%d秒' % t)if __name__ == '__main__': t1 = DownThread('小黄人') t2 = DownThread('黄人') time1 = time.time() t1.start() t2.start() t1.join() t2.join() # t1和t2都执行完成后才执行 time2 time2 = time.time() print('总用时%d秒' % (time2-time1)) #19.5 数据共享123import timefrom threading import Threadimport threading 当多个线程同时对一个数据进行操作时，可能会出现数据混乱 多个线程对一个数据进行操作，一个线程将数据读出来，还没来得及存进去，另一个线程又去调用该数据，这时可能产生数据安全隐患。 解决方式是给数据加锁 Thread - 创建子线程Lock - 锁；创建锁对象12345678910111213141516171819202122232425262728293031323334353637383940414243class Account(object): def __init__(self, balance, name): self.balance = balance # 余额 self.name = name self.lock = threading.Lock() # 创建锁对象 def save(self, num): print(self.name, '开始存钱') # 加锁 self.lock.acquire() old_balance = self.balance time.sleep(3) self.balance = old_balance + num # 解锁 self.lock.release() def draw(self, num): print(self.name, '开始取钱') # 加锁 self.lock.acquire() old_balance = self.balance time.sleep(3) self.balance = old_balance - num # 解锁 self.lock.release()account1 = Account(1000, '小黄人')# 支付宝存钱t1 = Thread(target=account1.save, args=(1000, ))# 银行卡取钱t2 = Thread(target=account1.draw, args=(500, ))t1.start()t2.start()t1.join()t2.join()print(account1.balance)","categories":[],"tags":[]},{"title":"","slug":"学生管理系统2-0","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/学生管理系统2-0/","link":"","permalink":"http://yoursite.com/2018/12/21/学生管理系统2-0/","excerpt":"","text":"#mymodule：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354def page(): \"\"\" 输出界面 :return: \"\"\" print('=' * 88, '\\n❀❀欢迎来到LOL小学生管理系统：\\n') dict1 = &#123;' 💗 1.': '添加学生', ' 💗 2.': '查看学生', ' 💗 3.': '修改学生信息', ' 💗 4.': '删除学生', ' 💗 5.': '返回', ' 💗 6.': '退出'&#125; for key in dict1: print(key, dict1[key]) print('=' * 88)def add_student(): \"\"\" 添加学生信息 :return: \"\"\" global stu_id dict0 = &#123;'学号': next(stu_id)&#125; value = input('请输入学生姓名：') dict0['姓名'] = value value = input('请输入学生年龄：') dict0['年龄'] = value value = input('请输入学生电话：') dict0['电话'] = value return dict0def get_students_id(): \"\"\" 生成学生学号 :return: \"\"\" id = 1 while 1: # str1.zfill(n) - 将str1返回为长度n的新字符串，以原字符串右对齐，前面填充0。 yield 'stu' + str(id).zfill(3) id += 1def tian_jia(): \"\"\" 添加学生 :return: \"\"\" global i dict0 = add_student() all_students.append(dict0) # 防止越界，扩展列表长度 all_students[i] = dict0 # 防止被覆盖 i += 1 print('🐕'*16, end='') print(\"\"\" ❀❀添加成功!❀❀ 💗 1. 继续 💗 2. 返回 ❀❀请选择(1-2):❀❀\"\"\") print('🐕'*16) while 1: n = input() if n == '2': bool3 = False return bool3 elif n == '1': bool3 = True return bool3 else: print('请输入1-2内的数字。\\n1. 继续\\n2. 返回') continuedef find_student(str1, n): \"\"\" 在学生总表中查找包含&#123;str1，n&#125;的学生 :param n: 输入的查找内容 :param str1: 查找的关键字 :return:下标列表 or -1 \"\"\" index_list = [] for index in range(len(all_students)): if n == all_students[index][str1]: # 找到相应位置 index_list.append(index) return index_listdef show_find_student(index_list: list): \"\"\" 打印查询到的所有学生，并编号 :return: \"\"\" print('符合条件的学生信息为：') print('=' * 32) for index in range(len(index_list)): print(str(index+1) + ' ', end='') for key in all_students[index_list[index]]: print(key + ':' + all_students[index_list[index]][key], end=' ') print() print('=' * 32)def look_over(str1, n): \"\"\" 在学生总表中查找并打印出包含&#123;str1，n&#125;的学生 :param n:输入的查找内容 :param str1:查找的关键字 :return: \"\"\" print('学生信息如下：') print('=' * 32) for index in range(len(all_students)): if n == all_students[index][str1]: # 找到相应位置 for key in all_students[index]: print(key + ':' + all_students[index][key], end=' ') print() print('=' * 32)def cha_kan(): \"\"\" 查看学生 :return: \"\"\" while 1: print('🐱' * 16, end='') print(\"\"\" 💗 1.查看所有学生 💗 2.按姓名查找 💗 3.按学号查找 💗 4.返回 ❀❀请选择(1-4):❀❀\"\"\") print('🐱' * 16) n = input() if n == '4': break elif n == '1': print('所有学生信息如下：') print('=' * 32) show_all() print('=' * 32) continue elif n == '2': n = input('请输入要查找的学生姓名：') str1 = '姓名' value = len(find_student(str1, n)) if value != 0: look_over(str1, n) # 注意自变量 else: print('查无此人！请核对输入信息！！') continue elif n == '3': n = input('请输入要查找的学生的学号：') str1 = '学号' value = len(find_student(str1, n)) if value != 0: look_over(str1, n) # 注意自变量 else: print('查无此人！请核对输入信息！！') continue else: print('请输入1-4内的数字。') continuedef revise_student(index, index_list): \"\"\" 依据不同的i值(编号)修改不同的学生 :param index: 需要修改的学生编号 :return: \"\"\" while 1: print('🐘'*22, end='') print(\"\"\" 请选择要修改的信息: 💗 1.修改学号 💗 2.修改姓名 💗 3.修改年龄 💗 4.修改电话 💗 5.修改下一个学生 💗 6.退出修改 ❀❀请选择（1-6）:❀❀\"\"\") print('🐘' * 22) n = input() if n == '5': break elif n == '6': bool2 = False return bool2 elif n == '1': n2 = input('请输入修改后的学号：') str1 = '学号' revise_student1(index_list[index], str1, n2) continue elif n == '2': n2 = input('请输入修改后的姓名：') str1 = '姓名' revise_student1(index_list[index], str1, n2) continue elif n == '3': n2 = input('请输入修改后的年龄：') str1 = '年龄' revise_student1(index_list[index], str1, n2) continue elif n == '4': n2 = input('请输入修改后的电话：') str1 = '电话' revise_student1(index_list[index], str1, n2) continue else: print('请输入1-6内的数字。') continuedef revise_student1(index, str1, n2): \"\"\" 在学生总表中找到下标为index的学生字典，并将key为str1的值改为n2 :param index: :param n2: :param str1: :return: \"\"\" all_students[index][str1] = n2 print(\"修改成功!修改后的信息为：\") print('=' * 32) for key in all_students[index]: print(key + ':' + all_students[index][key], end=' ') print() print('=' * 32)def xiu_gai(): \"\"\"修改学生\"\"\" bool2 = True while bool2: print('🐖'*16, end='') print(\"\"\" 💗 1.按学号修改 💗 2.按姓名修改 💗 3.返回 ❀❀请选择（1-3）：❀❀\"\"\") print('🐖' * 16) n = input() if n == '3': break elif n == '1': n1 = input('请输入要修改学生的学号：') # 学号只有一个 index_list = find_student('学号', n1) # 找出需要修改的字典 #print(index_list) if len(index_list) != 0: show_find_student(index_list) revise_student(0, index_list) else: print('查无此人！请核对输入信息！！') continue elif n == '2': n1 = input('请输入要修改学生的姓名：') index_list = find_student('姓名', n1) # print(index_list) if len(index_list) != 0: show_find_student(index_list) n2 = int(input('请选择要修改学生的编号：'))-1 revise_student(n2, index_list) else: print('查无此人！请核对输入信息！！') continuedef delete_student(): \"\"\" 删除学生 :return: \"\"\" while 1: print('🐮' * 16, end='') print(\"\"\" 💗 1.按学号删除 💗 2.按姓名删除 💗 3.返回 ❀❀请选择（1-3）：❀❀\"\"\") print('🐮' * 16) n = input() if n == '1': n1 = input('请输入要删除学生的学号：') str1 = '学号' index_list = find_student(str1, n1) if len(index_list) != 0: show_find_student(index_list) print('🐍'*16, end='') print(\"\"\" 请确认是否删除： 💗 1.确认删除 💗 2.返回上一层 ❀❀请选择（1-2）❀❀\"\"\") print('🐍' * 16) n3 = input() if n3 == '1': n2 = int(input('请输入要删除学生的编号：')) - 1 all_students.pop(index_list[n2]) print('=====删除成功!请继续=====') global i i -= 1 continue else: continue else: print('查无此人！请核对输入信息！！') continue elif n == '2': n1 = input('请输入要删除学生的姓名：') str1 = '姓名' index_list = find_student(str1, n1) if len(index_list) != 0: show_find_student(index_list) print('🐍' * 16, end='') print(\"\"\" 请确认是否删除： 💗 1.确认删除 💗 2.返回上一层 ❀❀请选择（1-2）❀❀\"\"\") print('🐍' * 16) n3 = input() if n3 == '1': n2 = int(input('请输入要删除学生的编号：')) - 1 all_students.pop(index_list[n2]) print('=====删除成功!请继续=====') i -= 1 continue else: continue else: print('查无此人！请核对输入信息！！') continue elif n == '3': break else: print('请输入1-2内的数字。') continuedef show_all(): \"\"\" 打印所有学生信息 :return: \"\"\" for index in range(len(all_students)): for key in all_students[index]: print(key + ':' + all_students[index][key], end=' ') # 空格隔开 print() # 每输出一个换行all_students = []stu_id = get_students_id()i = 0 程序：123456789101112131415161718192021222324import mymodulebool1 = Truewhile bool1: # show_all() mymodule.page() choice = input('请选择（1-6）：') if choice == '5': continue elif choice == '6': print('谢谢使用，欢迎下次再来！') break elif choice == '1': bool3 = True while bool3: bool3 = mymodule.tian_jia() elif choice == '2': mymodule.cha_kan() elif choice == '3': mymodule.xiu_gai() elif choice == '4': mymodule.delete_student() else: print('请输入1-5内的数字。') continue","categories":[],"tags":[]},{"title":"","slug":"day14-作业","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day14-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day14-作业/","excerpt":"","text":"0.定义一个学生类。有属性：姓名、年龄、成绩（语文，数学，英语)[每课成绩的类型为整数]方法： a. 获取学生的姓名：getname() b. 获取学生的年龄：getage()c. 返回3门科目中最高的分数。get_course()程序：123456789101112131415161718192021class Student: def __init__(self, name, age, *score): self.name = name self.age = age self.languages_score, self.math_score, self.english_score = score def get_name(self): print('该学生姓名为：',self.name) def get_age(self): print('%s的年龄为：%d' % (self.name, self.age)) def get_course(self): return max(self.languages_score, self.math_score, self.english_score)s1 = Student('小王', 88, 57, 58, 99)s1.get_name() # 该学生姓名为： 小王s1.get_age() # 小王的年龄为：88print('最高分数为：', s1.get_course()) # 最高分数为： 99 1.建立一个汽车类Auto，包括轮胎个数，汽车颜色，车身重量，速度等成员变量，并通过不同的构造方法创建实例。至少要求 汽车能够加速 减速 停车。 再定义一个小汽车类CarAuto 继承Auto 并添加空调、CD等成员变量 覆盖加速 减速的方法12345678910111213141516171819202122232425262728293031323334353637383940class Auto: def __init__(self, wheel_num, color, weight, speed): self.wheel_num = wheel_num self.color = color self.weight = weight self.speed = speed def up_speed(self): print('加速') def down_speed(self): print('减速') def stop(self): print('停车')class CarAuto(Auto): def __init__(self, wheel_num, color, weight, speed, air_conditioner, cd): super(CarAuto, self).__init__(wheel_num, color, weight, speed) self.air_conditioner = air_conditioner self.cd = cd def up_speed(self): print('超级加速') def down_speed(self): print('缓慢减速') def stop(self): print('停车')c1 = Auto(8, '黄色', '10t', '98km/h')ca1 = CarAuto(4, '黑色', '4t', '198km/h', '格力', '热情的沙漠')ca1.up_speed() # 超级加速ca1.down_speed() # 缓慢减速ca1.stop() # 停车print(ca1.cd) # 热情的沙漠 2.创建一个名为User 的类，其中包含属性firstname 和lastname ，还有用户简介通常会存储的其他几个属性。在类User 中定义一个名 为describeuser() 的方法，它打印用户信息摘要;再定义一个名为greetuser() 的方法，它向用户发出个性化的问候。管理员是一种特殊的用户。编写一个名为Admin 的类，让它继承User类。添加一个名为privileges 的属性，用于存储一个由字符串(如”can add post”、”can delete post”、”can ban user”等)组成的列表。编写一个名为show_privileges()的方法，它显示管理员的权限。创建一个Admin 实例，并调用这个方法。程序：1234567891011121314151617181920212223242526272829class User: def __init__(self, last_name, first_name='first'): self.first_name = first_name self.last_name = last_name def describe_user(self): print(self.__dict__) def greet_user(self): print('欢迎%s登录本系统。' % self.last_name)class Admin(User): def __init__(self, last_name, privileges=None): super().__init__(last_name) if privileges is None: privileges = ['can add post', 'can delete \\post', 'can ban user'] self.privileges = privileges def show_privileges(self): for item in self.privileges: print(self.last_name + 'you', item)a1 = Admin('老王')a1.greet_user()# a1.describe_user()a1.show_privileges() 结果： 3.创建一个Person类，添加一个类字段用来统计Perosn类的对象的个数程序：123456789101112131415161718class Person: object_counts = 0 def __init__(self): self.name = '老王' Person.object_counts += 1 @classmethod def objects(cls): print('创建了%s类的%d个对象' % (cls.__name__, cls.object_counts))p1 = Person()p1 = Person()p1 = Person()p1 = Person()Person.objects() 结果： (尝试)5.写一个类，其功能是：1.解析指定的歌词文件的内容 2.按时间显示歌词 提示：歌词文件的内容一般是按下面的格式进行存储的。歌词前面对应的是时间，在对应的时间点可以显示对应的歌词 [00:00.20]蓝莲花 [00:00.80]没有什么能够阻挡[00:06.53]你对自由地向往 [00:11.59]天马行空的生涯[00:16.53]你的心了无牵挂[02:11.27][00:21.95]穿过幽暗地岁月[02:16.51][00:26.83]也曾感到彷徨[02:21.81][00:32.30]当你低头地瞬间[02:26.79][00:37.16]才发觉脚下的路[02:32.17]心中那自由地世界[02:37.20]如此的清澈高远[02:42.32]盛开着永不凋零[02:47.83]蓝莲花 100s -程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Music: def __init__(self, files: str): self.files = files def __get_list(self): with open(self.files, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f: list1 = f.readlines() list5 = [] for index in range(len(list1)): list4 = [] list2 = list1[index].split(&apos;]&apos;) for index1 in range(len(list2)): list3 = list2[index1].split(&apos;[&apos;) list4.append(list3[-1]) list5.append(list4) list8 = [] for index in range(len(list5)): index1 = 0 list7 = [] while index1 &lt; len(list5[index]): if &apos;:&apos; in list5[index][index1]: list6 = list5[index][index1].split(&apos;:&apos;) time = float(list6[0])*60 + float(list6[1]) list7.append(time) # print(list6[0], list6[1]) index1 += 1 else: list7.append(list5[index][index1]) index1 += 1 list8.append(list7) return list8 def get_words(self, second): list10 = [] list9 = self.__get_list() for index in range(len(list9)): for index1 in range(len(list9[index])-1): list10.append(list9[index][index1]) list10.sort() for index in range(len(list10)): if second &lt;= list10[index]: for index1 in range(len(list9)): # if list10[index-1] in list9[index1]: if list10[index] in list9[index1]: print(list9[index1][-1]) break else: print(&apos;超出歌曲总时长！&apos;)blue_lotus = Music(&apos;files/blue_lotus.txt&apos;)blue_lotus.get_words(0.2) # 蓝莲花blue_lotus.get_words(5) # 你对自由地向往blue_lotus.get_words(10) # 天马行空的生涯blue_lotus.get_words(30) # 当你低头地瞬间blue_lotus.get_words(80) # 穿过幽暗地岁月blue_lotus.get_words(100) # 穿过幽暗地岁月blue_lotus.get_words(164) # 蓝莲花blue_lotus.get_words(168) # 超出歌曲总时长！","categories":[],"tags":[]},{"title":"","slug":"day17-正则表达式","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day17-正则表达式/","link":"","permalink":"http://yoursite.com/2018/12/21/day17-正则表达式/","excerpt":"","text":"#17.1 正则基本符号 1.什么是正则表达式 正则表达式就是字符匹配的工具，用来做正则匹配；是由正则符号和普通字符组成，来匹配不同规律的字符串。 2.python对正则表达式的支持 python中提供了一个re模块，用来支持正则表达式。 fullmatch(正则表达式，字符串) - 用正则表达式去完全匹配字符串，如果匹配成功返回一个结果，失败返回None。 python中的正则表达式的写法：将正则内容写在字符串中，一般这个字符串的最前面会加r或R用来阻止转义。12345import restr1 = &apos;dhsuwqy82r21r372cuefy12fgy1983r1y283781382g1f382321382r3g21&apos;str2 = &apos;18408266183&apos;str3 = &apos;zh@qq.com&apos; 1.普通字符普通字符在正则表达式中，代表字符本身。1234567# 匹配一个字符串，第一个字符是a，第二个字符是b，第三个字符也是最后一个字符是c。re_str = r'abc'result = re.fullmatch(re_str, 'abc')print(result) # &lt;_sre.SRE_Match object; span=(0, 3), match='abc'&gt;result1 = re.fullmatch(re_str, 'abcd')print(result1) # None . 匹配任意字符在正则表达式中，. 出现的位置可以匹配一个任意字符（char）注意：一个.只能匹配一个字符1234# 匹配一个长度为3的字符串。且第一个字符是a，最后一个字符是c，中间一个字符是任意一个字符。re_str = r'a.c'result = re.fullmatch(re_str, 'a$c')print(result) # &lt;_sre.SRE_Match object; span=(0, 3), match='a%c'&gt; \\w 匹配字母数字或下划线的符号在正则表达式中，\\w出现的位置，可以匹配一个任意的字母数字或下划线的符号（其实也可以匹配Unicode编码中除了Ascii码剩下的部分。）中文也能匹配1234# 匹配一个长度是5的字符串，并且字符串前两位是任意的字母数字或下划线符号,后3位是任意字符re_str = r'\\w\\w...'result = re.fullmatch(re_str, '小白a$c')print(result) # &lt;_sre.SRE_Match object; span=(0, 5), match='小白a$c'&gt; \\s 匹配一个空白字符空白字符：包括空格、制表符、换行符（空格，\\t,\\r,\\n）12345# 匹配一个长度是4的字符串，并且前两位是字母数字下划线或中文，中间一个空白符，最后# 以一个字母数字下划线或中文结尾。re_str = r'\\w\\w\\s\\w'result = re.fullmatch(re_str, '小白\\ne')print(result) # &lt;_sre.SRE_Match object; span=(0, 4), match='小白\\ne'&gt; \\d 匹配数字字符1234# 匹配一个长度是5的字符串，字符串的前三位是数字字符，后两位是任意字符re_str = r'\\d\\d\\d..'result = re.fullmatch(re_str, '123小白')print(result) # &lt;_sre.SRE_Match object; span=(0, 5), match='123小白'&gt; \\b 检测单词边界注意：\\b位置不会被用于匹配，只是检测该位置是否是单词边界，不会对字符进行匹配，不会记入字符串长度。当正则表达式中出现了\\b，匹配时去掉\\b匹配成功后再看\\b出现的位置是否是单词边界。 单词边界：字符串开头、字符串结尾、标点符号、空白符号等只要能将单词区分开的符号都属于单词边界。匹配前先把\\b去掉，再去匹配，匹配时再找满足条件的。1234567# 下句既要求helloworld又要求两单词分开re_str = r'hello\\bworld' # 没有任何一个字符串能和它匹配re_str1 = r'\\bhello,\\bworld' # 没有任何一个字符串能和它匹配result = re.fullmatch(re_str1, 'hello,world')print(result) # &lt;_sre.SRE_Match object; span=(0, 11), match='hello,world'&gt; ^ 检测字符串开头在math和fullmatch中没有意义，在search、findall等中有意义。1234# 匹配一个字符串前3个是The，后面俩个是任意字符re_str = r'^The..'result = re.fullmatch(re_str, 'The')print(result) $ 检测字符串结尾在math和fullmatch中没有意义，在search、findall等中有意义。1234# 匹配一个字符串只要3位，分别是The，并且e后结尾。所以在这无意义re_str = r'^The$'result = re.fullmatch(re_str, 'The')print(result) # &lt;_sre.SRE_Match object; span=(0, 3), match='The'&gt; \\W 匹配一个非字母数字下划线中文的字符\\大写字母 对应的功能是 \\小写字母 功能取反\\W 匹配一个非字母数字下划线中文的字符\\D 匹配一个非数字字符\\S 匹配一个非空白字符\\B 检测非单词边界12345# 匹配一个字符串，第一个是数字，第二个非数字，第三个是空白，第四个是数字字母下划线，最后# 一个是a，并且要求最后一个a前不是单词边界。re_str = r'\\d\\D\\s\\w\\Ba'result = re.fullmatch(re_str, '9H\\tAa')print(result) # &lt;_sre.SRE_Match object; span=(0, 5), match='9H\\tAa'&gt; [字符集] 匹配中括号中出现的任意一个字符 [普通字符集] 匹配中括号中出现的任意一个字符[abc] - 匹配一个字符是a或b或c 注意：a.一个中括号只能匹配一个字符b.正则中有特殊功能的单个符号例如：. $ ^ + * ? | 等。c.匹配字符的组合符号在中括号中保持原来的功能：如\\w \\d \\s \\W \\D \\S1234# 匹配一个长度是2的字符串，第一个字符是数字，第二个字符是b或c或dre_str = r'\\d[bcd\\d]'result = re.fullmatch(re_str, '22')print(result) # &lt;_sre.SRE_Match object; span=(0, 2), match='22'&gt; 2.[字符1-字符2] - 表示字符1到字符2（注意：要求字符1的编码值要小于字符2） [a-z] - 表示匹配所有的小写字母[A-Z] - 表示匹配所有的大写字母[a-zA-Z] - 表示匹配所有的字母 [1-7] - 表示数字字符1到7[\\u4e00-\\u9fa5] - 匹配所有的中文 [字符1字符2-] - 这儿的-表示减号本身12345# 匹配一个长度是3的字符串，第一个字符是数字字符1到7的一个，第二个字符是a、b、c、-# 中的一个，第三个是小写字母re_str = r'[1-7][abc-][a-z]'result = re.fullmatch(re_str, '3-z')print(result) # &lt;_sre.SRE_Match object; span=(0, 3), match='3-z'&gt; [^字符集] 匹配不在字符集中的任何一个字符，^ 要放在字符集前 [^abc] - 匹配除了abc以外的任意一个字符[^\\d] - 匹配除了数字字符以外的任意一个字符[^a-z] - 匹配除了小写字母以外的任意一个字符 [abc^d] - 匹配abcd或^中的任意一个字符。123re_str = r'[^abc]'result = re.fullmatch(re_str, '3')print(result) # &lt;_sre.SRE_Match object; span=(0, 1), match='3'&gt; #17.2 正则控制匹配次数1import re * 匹配0次或多次a - a连续出现0次或多次；’’,’a’,’aaa’, ‘ ‘\\d - 任意数字连续出现0次或多次。’’,’1’,’12’,’245432542354’都可以匹配[abc] - a或b或c连续出现0次或多次。[A-F] - A到F中任意字符出现0次或多次。 注意：在[]外面的*的前面需要一个字符或者一个匹配字符的符号12# &lt;_sre.SRE_Match object; span=(0, 10), match='aaaaaaaaab'&gt;print(re.fullmatch(r'a*b', 'aaaaaaaaab')) + 至少匹配1次 a+ - a至少匹配一次\\d+ - 数字至少1次12print(re.fullmatch(r'a+b', 'aaab'))# &lt;_sre.SRE_Match object; span=(0, 4), match='aaab'&gt; ? 出现0次或1次 a? - a出现0次或1次，’’和’a’可以匹配123# 写一个正则匹配一个整数（正负整数都行）， 123 10 +100 -100re_str = r'[+-]?[1-9]\\d*'print(re.fullmatch(re_str, '-100')) {} {N} - 匹配N次，如a{3} - 匹配3个’a‘{M，N} - 匹配M到N次，如a{3，5} - ‘aaa’ ‘aaaa’ ‘aaaaa’{,N} - 最多匹配N次，即0到N次。如a{,3} - ‘’,’a’,’aa’,’aaa’{M,} - 至少匹配M次，如a{3,} - ‘aaa’,’aaaa’…12345678print(re.fullmatch(r&apos;a&#123;,3&#125;&apos;, &apos; &apos;))# 密码由字母数字组成数字不开头，6-12位，给出提示password = input(&apos;密码：&apos;)re_str = r&apos;[a-zA-Z]&#123;1&#125;[a-zA-Z0-9]&#123;5, 11&#125;&apos;re_str = r&apos;[a-zA-Z][a-zA-Z0-9]&#123;5, 11&#125;&apos;if not re.fullmatch(re_str, password): print(&apos;错误。&apos;) #17.3 分支、捕获和贪婪1import re 1.分支条件1 | 条件2 - 匹配条件1或者条件2\\d{2} | [a-z] - 匹配俩个数字字符，或者一个小写字母a\\d{2}|\\w{2} - 匹配1个a后面2个数字，或者两个数字字母下划线。 注意：正则中分支也会短路，当条件1可以匹配，就不会再使用条件2匹配1234567891011121314151617181920212223242526272829# &lt;_sre.SRE_Match object; span=(0, 2), match='33'&gt;print(re.fullmatch(r'\\d&#123;2&#125;|[a-z]', '33'))# &lt;_sre.SRE_Match object; span=(0, 1), match='a'&gt;print(re.fullmatch(r'\\d&#123;2&#125;|[a-z]', 'a'))# &lt;_sre.SRE_Match object; span=(0, 3), match='a33'&gt;print(re.fullmatch(r'a\\d&#123;2&#125;|\\w&#123;2&#125;', 'a33'))# &lt;_sre.SRE_Match object; span=(0, 2), match='a3'&gt;print(re.fullmatch(r'a\\d&#123;2&#125;|\\w&#123;2&#125;', 'a3'))# 匹配所有的数字 100 -100 12.5 -12.5 0 0.012\"\"\"12,12.340.1230\"\"\"re_str = r'[+-]?[1-9][0-9]*|[+-]?[0-9]*[.][0-9]*|0'# re_str = r'[+-]?[1-9][0-9]*[.]?\\d*|[+-]?0[.]?[0-9]+|0' 老师print(re.fullmatch(re_str, '-12.5'))print(re.fullmatch(re_str, '-0.5989'))print(re.fullmatch(re_str, '0123'))print(re.fullmatch(re_str, '123'))print(re.fullmatch(re_str, '+123'))print(re.fullmatch(re_str, '0.012'))print(re.fullmatch(re_str, '+0.012'))print(re.fullmatch(re_str, '-0.012'))print(re.fullmatch(re_str, '0'))print(re.fullmatch(re_str, '-0.3')) 2.捕获和分组 a.分组 - 将括号中的内容作为一个整体r’abc\\d{3}|abc[A-Z]{3}’ = r’abc(\\d{3}|[A-Z]{3})’1234567# 匹配一个字符串，前3位是abc，后3位是数字或者大写字母# r'abc\\d&#123;3&#125;|abc[A-Z]&#123;3&#125;' = r'abc(\\d&#123;3&#125;|[A-Z]&#123;3&#125;)'# 匹配一个字符串，以‘数字小写字母’的形式出现3次re_str = r'(\\d[a-z])&#123;3&#125;'# &lt;_sre.SRE_Match object; span=(0, 6), match='1a2s3d'&gt;print(re.fullmatch(re_str, '1a2s3d')) b.捕获通过正则获取符合条件的子串时，可以在正则表达式中加括号，匹配后只获取括号里面匹配到的内容。例1：re.findall(正则表达式，字符串) - 在字符串中去获取符合正则表达式条件的所有子串，返回一个列表。123456789str1 = '32e23i1hr32hru392r3hu21re3u21hre32h1iufe3h2r'# ['32', '23', '1', '32', '392', '3', '21', '3', '21', '32', '1', '3', '2']print(re.findall(r'\\d+', str1))# 例1：# ['e23', 'e3', 'e32', 'e3']print(re.findall(r'e\\d+', str1))# ['23', '3', '32', '3']print(re.findall(r'e(\\d+)', str1)) c.重复匹配写一个带多个分组的正则表达式，可以在分组后面通过添加 \\数字 来重复前面第几个分组中匹配到的内容。 说明：\\数字 - 这里的数字代表前面第几个分组；\\1代表第一个分组，\\2代表第2个组123456re_str = r'\\d&#123;3&#125;([a-z]&#123;2&#125;)a\\1'# &lt;_sre.SRE_Match object; span=(0, 8), match='222sdasd'&gt;print(re.fullmatch(re_str, '222sdasd'))re_str = r'(\\d&#123;3&#125;)([a-z]&#123;2&#125;)a\\1\\2'print(re.fullmatch(re_str, '222sda222sd')) 3.贪婪匹配次数后加？就是贪婪匹配：*? +? ?? {M,N}? {M,}? 表示尽可能少的重复123456re_str = r'a.+b'str1 = 'xxxahdjbnnkbsssammmb'print(re.findall(re_str, str1)) # ['ahdjbnnkbsssammmb']re_str = r'a.+?b'print(re.findall(re_str, str1)) # ['ahdjb', 'ammmb'] 转义字符在正则表达式中可以在有特殊意义或者特殊功能的符号前加\\来取消其特殊功能\\w - 代表两个字符分别为反斜杠和w+ - 代表加号字符* - 代表*\\? - 代表?() - 表示（），类推[]及{} 注意：在中括号中，\\必须加\\表示反斜杠本身。\\^在最前面时，必须加\\表示^本身-在两个字符之间并在中括号里面时，必须加\\表示-本身1re_str = r'\\w-\\d&#123;3&#125;' #17.4 re模块1import re 1.compilecompile(正则表达式) - 将正则表达式转换成正则表达式对象12345678re_str = r&apos;\\d&#123;3&#125;&apos;re_obj = re.compile(re_str)# 调用模块中函数print(re.fullmatch(re_str, &apos;338&apos;))# 调用对象方法print(re_obj.fullmatch(&apos;338&apos;)) 2.match和fullmatch a.fullmattch(正则表达式，字符串) - 完全匹配，从字符串开头一直到结尾b.mattch(正则表达式，字符串) - 不完全匹配，只匹配字符串开头。1234567re_str = r'\\d[A-Z]&#123;2&#125;'# 完全匹配 &lt;_sre.SRE_Match object; span=(0, 3), match='6AD'&gt;print(re.fullmatch(re_str, '6AD'))# 不完全匹配 &lt;_sre.SRE_Match object; span=(0, 3), match='6AD'&gt;print(re.match(re_str, '6AD2签位尔特3ytuytjytj')) 匹配对象1.获取span - 匹配到内容在字符串中的范围（开始下标，结束下标），结束下标取不到匹配对象.span() - 获取整个正则表达式匹配到的范围匹配对象.span(n) - 获取正则表达式中第n个分组匹配到的范围，前提是有分组。12345678# (0, 3)print(re.match(re_str, '6AD2签位尔特3ytuytjytj').span())# (0, 1)print(re.match(r'(\\d)[A-Z]&#123;2&#125;', '6AD2签位尔特3ytuytjytj').span(1))# (1,3)print(re.match(r'(\\d)([A-Z]&#123;2&#125;)', '6AD2签位尔特3ytuytjytj').span(2)) 2.start和end - 获取匹配结果的开始下标和结束下标。匹配对象.start()/匹配对象.end() - 获取整个正则表达式匹配到的的开始下标和结束下标。匹配对象.start(n)/匹配对象.end(n) - 获取整个正则表达式第n个分组，匹配到的的开始下标和结束下标。 3.group - 获取匹配到的内容匹配对象.group() - 获取整个正则表达式匹配到的内容匹配对象.group(n) - 获取正则表达式第n个分组匹配到的内容 4.string - 获取用来匹配的原字符串匹配对象.string() 3.searchsearch(正则表达式，字符串) - 匹配字符串中第一个满足正则表达式的子串，如果匹配成功，返回匹配对象，否则返回None123str1 = r'abc123hkcajsa121df'result = re.search(r'\\d&#123;3&#125;[a-z]&#123;2&#125;', str1)print(result) # &lt;_sre.SRE_Match object; span=(3, 8), match='123hk'&gt; 4.spiltsplit(正则表达式，字符串) - 在字符串中按照满足正则表达式条件的子串对字符串进行切割。返回一个列表1234567str1 = 'ab+c7wewfwefewff79wfqe9fwq9qw0e*f'# ['ab+c', 'wewfwefewff', 'wfqe', 'fwq', 'qw', 'e*f']print(re.split(r'\\d+', str1))# ['ab', 'c', 'wewfwefewff', 'wfqe', 'fwq', 'qw', 'e', 'f']print(re.split(r'\\d+|[+*-]+', str1)) 5.subsub(正则表达式，新子串，字符串) - 用新子串替换字符串中满足正则表达式的子串，返回一个替换后的字符串12str1 = 'i32h1e32jirh32iu1ej321eji'print(re.sub(r'\\d+', '$', str1)) # i$h$e$jirh$iu$ej$eji 6.findallfindall(正则表达式，字符串) - 在字符串中获取满足正则表达式的所有的字符，返回一个列表，列表元素就是字符串。 注意：如果此处正则表达式中有一个分组，结果是列表中只取括号中匹配到的字符串，如果分组大于1，结果是一个列表，列表元素是元组，元组中元素为每个括号中匹配到的字符串。（先匹配整个再取括号中内容！）123456str1 = 'sdad434w2rsdvsvds34==='print(re.findall(r'\\d+', str1)) # ['434', '2', '34']str1 = 'sdad434w2rsdvsvds34==='print(re.findall(r'(\\d+)(\\w)', str1)) # [('434', 'w'), ('2', 'r'), ('3', '4')] 7.finditerfinditer(正则表达式，字符串) - 在字符串中获取满足正则表达式的内容，返回一个迭代器，迭代器元素是匹配对象。12345678910111213str1 = 'sdad434w2rsdvsvds34==='print(re.finditer(r'\\d+', str1))# 写一个自己的finditerdef my_finditer(pattern, string): re1 = re.search(pattern, string) while re1: yield re1 string = string[re1.end():] # 考虑对正则取反（think） re1 = re.search(pattern, string)","categories":[],"tags":[]},{"title":"","slug":"登录注册","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/登录注册/","link":"","permalink":"http://yoursite.com/2018/12/21/登录注册/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192def login_page(): print(\"\"\"************************************************************************************************************** 欢迎来到LOL小学生管理系统 **** 💗 1.登录 **** 💗 2.注册 **** 💗 3.退出 **************************************************************************************************************\"\"\")def show_aap(): list1 = [] with open('account_and_password.txt', 'r', encoding='utf-8') as aap: list0 = aap.read().splitlines() # 按换行符切割，默认不保留换行符 for item in list0: list1.append(item.split('/', 1)) return list1bool1 = Truewhile bool1: login_page() choice = input('请选择（1-3）：') if choice == '1': bool2 = True # 写在这用于更新 while bool2: account = str(input('请输入账号名：')) password = str(input('请输入密码：')) if len(show_aap()) == 0: print('账号不存在，请先注册！') break else: aap_dict = dict(show_aap()) # print(account, password) for key in aap_dict: # print(aap_dict) if account == key and password == aap_dict[key]: print('登录成功！') bool1 = bool2 = False break else: while True: print(\"\"\"==============================账号或密码错误，请选择(1-2):💗 1.继续输入💗 2.返回==============================\"\"\") choice2 = input() if choice2 == '1': break elif choice2 == '2': bool2 = False break else: continue elif choice == '2': while True: account = input('请输入账号名：') if len(show_aap()): password = input('请输入密码：') check_password = input('请确认密码：') if check_password == password: with open('account_and_password.txt', 'a', encoding='utf-8') as aap: aap.write(account + '/' + password + '\\n') print('注册成功！请继续！！') break else: aap_dict = dict(show_aap()) for key in aap_dict: if key == account: print('该账号已被注册，请重新输入！') break else: password = input('请输入密码：') check_password = input('请确认密码：') if check_password == password: with open('account_and_password.txt', 'a', encoding='utf-8') as aap: aap.write(account + '/' + password + '\\n') print('注册成功！请继续！！') break else: print('两次密码不一致，请重新设置！') continue elif choice == '3': print('再见！') break else: continue","categories":[],"tags":[]},{"title":"","slug":"day13-作业","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day13-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day13-作业/","excerpt":"","text":"1.声明⼀个电脑类: 属性:品牌、颜⾊、内存⼤小 方法:打游戏、写代码、看视频a.创建电脑类的对象，然后通过对象点的⽅方式获取、修改、添加和删除它的属性b.通过attr相关⽅方法去获取、修改、添加和删除它的属性程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Conputer: \"\"\"电脑类\"\"\" def __init__(self, brand, color, ram): self.brand = brand self.color = color self.ram = ram def play_game(self): print('玩游戏') def write_code(self): print('写代码') def watch_video(self): print('看视视频')cp1 = Conputer('华硕', '宝石蓝', '4g')# a# 获取print(cp1.brand) # 华硕# 修改cp1.brand = 'apple'print(cp1.brand) # apple# 添加cp1.price = 2000print(cp1.price) # 2000# 删除del cp1.price# print(cp1.price) # AttributeError: 'Conputer' object has no attribute 'price'print('='*88)# b# 获取print(getattr(cp1, 'brand')) # apple# 修改setattr(cp1, 'brand', '华硕')print(cp1.brand) # 华硕# 添加setattr(cp1, 'price', 3000)print(getattr(cp1, 'price')) # 3000# 删除delattr(cp1, 'price')print(cp1.__dict__) # &#123;'brand': '华硕', 'color': '宝石蓝', 'ram': '4g'&#125; 2.声明⼀个人的类和狗的类:狗的属性:名字、颜色、年龄狗的方法:叫唤人的属性:名字、年龄、狗人的⽅方法:遛狗a.创建⼈人的对象⼩小明，让他拥有⼀一条狗大黄，然后让小明去遛⼤黄12345678910111213141516171819202122class Person: def __init__(self, name, age, dog): self.name = name self.age = age self.dog = dog def walk_the_dog(self): print(&apos;%s在遛他的狗:%s&apos; % (self.name, self.dog))class Dog: def __init__(self, name, color, age): self.name = name self.age = age self.color = color def shout(self): print(&apos;%s:汪汪汪&apos; % self.name)p1 = Person(&apos;小明&apos;, 8, &apos;大黄&apos;)p1.walk_the_dog() 3.声明⼀一个圆类:1234567891011121314151617class Circle: \"\"\"一个圆类,包含求面积和周长的方法\"\"\" pi = 3.141592653589793 def __init__(self, radius): self.radius = radius def area(self): return Circle.pi*self.radius**2 def per(self): return 2*Circle.pi*self.radiusc1 = Circle(3)print('面积为:%.2f' % c1.area()) # 面积为:28.27print('周长为:%.2f' % c1.per()) # 周长为:18.85 4.创建⼀一个学⽣生类:属性:姓名，年龄，学号方法:答到，展示学⽣生信息创建⼀一个班级类:属性:学⽣生，班级名方法:添加学⽣生，删除学生，点名, 求班上学生的平均年龄12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Student: \"\"\"学生类\"\"\" def __init__(self, name, age, stu_id): self.name = name self.age = age self.stu_id = stu_id def show_stu(self): # print('$$$$$$$$$$$$', len(self.__dict__)) for key in self.__dict__: print(key + ':' + self.__dict__[key], end=' ')class Class: \"\"\"班级类\"\"\" def __init__(self, class_name): self.stu = [] self.class_name = class_name def add_stu(self): stu_name = input('请输入要添加学生的姓名:') stu_age = input('请输入要添加学生的年龄:') stu_id = input('请输入要添加学生的学号:') # self.stu.append(Student(stu_name, stu_age, stu_id).__dict__) self.stu.append(Student(stu_name, stu_age, stu_id)) print('添加成功') def del_stu(self, name: str): print('----', self.stu) index = i = 0 # for index in range(len(self.stu)-i): while index &lt; len(self.stu)-i: # print('7777', self.stu[index].name) if name == self.stu[index].name: self.stu.pop(index) print('删除成功') i += 1 break else: print('查无此人,删除失败!') return None def cal_stu(self, name): for index in range(len(self.stu)): if name == self.stu[index].name: self.stu[index].show_stu() break else: print('查无此人,点名失败!') return None def aver_stu_age(self): sum1 = 0 for index in range(len(self.stu)): sum1 += int(self.stu[index].age) return sum1/len(self.stu) def show_all(self): for index in range(len(self.stu)): self.stu[index].show_stu() print()c1 = Class('火箭')while 1: print('1.添加学⽣生\\n2.删除学生\\n3.点名\\n4.求班上学生的平均年龄') choice = input() if choice == '1': c1.add_stu() continue elif choice == '2': del_name = input('请输入要删除学生的姓名:') c1.del_stu(del_name) continue elif choice == '3': cal_name = input('请输入要点学生的姓名:') c1.cal_stu(cal_name) break elif choice == '4': aver_age = c1.aver_stu_age() print(aver_age) continue","categories":[],"tags":[]},{"title":"","slug":"day14-类和对象2","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day14-类和对象2/","link":"","permalink":"http://yoursite.com/2018/12/21/day14-类和对象2/","excerpt":"","text":"#14.1 类方法和静态方法类中方法分为：对象方法，类方法和静态方法 1.对象方法a.直接声明在类中b.有默认参数selfc.通过对象调用 2.类方法a.在声明前添加@classmethodb.有默认参数cls,调用时不需要给cls传参，系统会自动将调用当前类方法的类传给clscls最终指向的是一个类，类可以做的，cls都可以做。c.通过类去调用：类.类方法（） 3.静态方法a.在声明前添加@staticmethodb.没有默认参数,c.通过类去调用：类.类方法（） 4.对对象方法、类方法和静态方法的选择a.什么时候使用对象方法：当实现函数功能需要用到对象属性时，就使用对象方法。b.什么时候使用类方法：实现函数功能不需要用到对象属性，但是需要类的时候就使用类方法。c.什么时候使用静态方法：实现函数功能，既不需要对象属性，也不需要类的时候，就使用静态方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Person: pi = 3.1415926 def __init__(self, name): self.name = name # 对象方法 def eat(self, food): print('%s在吃%s' % (self.name, food)) # 类方法 @classmethod def destroy(cls): print('人类破坏环境。') # 可以用cls来创建对象 p1 = cls('老王') p1.eat('牛肉') # 使用类的字段 print(cls.pi) # 使用cls调用类相关方法 # 静态方法 @staticmethod def hit_animal(): print('人类殴打小动物！')Person.destroy() # 人类破坏环境。 老王在吃牛肉 3.1415926Person.hit_animal() # 人类殴打小动物！# 练习：# 数学类，属性：pi 功能：求两数和，求一个圆的面积# class Circle:# def __init__(self, r):# self.r = r## def area(self, pi):# return pi*self.r**2### class MyMath:# pi = 3.1415926## @staticmethod# def sum1(n1, n2):# return n1 + n2## @classmethod# def circle_area(cls, other):# return other.area(cls.pi)class MyMath: pi = 3.1415926 @staticmethod def sum1(n1, n2): return n1 + n2 @classmethod def circle_area(cls, r): return cls.pi*r**2print(MyMath.sum1(1, 4)) # 5print(MyMath.circle_area(4)) # 50.2654816 #14.2 私有化 1.私有化在类中，可以通过在属性名或方法名前加__（注意：不能以__结尾），那么这个属性或方法会变成私有的，那么私有的属性和方法都不能在外部使用。 123456789101112131415161718class Person: num = 100 __num = 200 # 私有属性 __num__ = 300 # 不是私有属性 def __init__(self): self.name = 1 def show_name(self): print('内部使用：', Person.__num) print(self.name)p1 = Person()print(Person.num)# print(Person.__num)# AttributeError: type object 'Person' has no attribute '__num'print(p1.show_name()) 2.私有化原理python中没有真正的私有化，不能从访问权限上控制属性和方法的使用，只是在名字前有_但是没有以__结尾的名字前再加了一个’类名’，导致不能通过原属性和方法名进行访问。#14.3 对象属性的getter和setter 1.getter和setter如果希望在获取对象属性前做点别的事情，就给这个属性添加getter；如果希望给对象赋值前做点别的事情，就给这个属性添加setter 2.添加gettera.属性命名时属性名前加一个下划线（_属性名）如：self._age = 0b.声明一个函数，函数名是属性名（不要下划线），不需要额外参数；并且函数前使用@property修饰，这个函数的返回值就是获取属性的结果。c.当需要获取属性时，通过 对象.一个不带下划线的属性，如：对象.age 123@propertydef age(self): return 年龄相关值 3.给对象属性添加setter想要给对象属性添加setter，必须先给它添加gettera.属性命名时属性名前加一个下划线（_属性名）如：self._age = 0b.声明一个函数，函数名是属性名（不要下划线），需要一个额外的参数；不用返回值，并且函数前使用@getter名.setter来修饰c.当需要给属性赋值时，通过 对象.不带下划线的属性来赋值；如：对象.age = 100例如： 1234@age.setterdef age(self, age): 其它操作 self._age = age 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class Person: def __init__(self, name, age): self.name = name self._age = age self.sex = '男' # 这儿的age属性就是属性__age的getter方法。 @property def age(self): if self._age &lt; 1: return '婴儿' elif self._age &lt; 18: return '未成年' else: return 'LOL' # 这儿的age函数就是属性_age的setter @age.setter def age(self, age): if not isinstance(age, int): print('年龄必须是整数！') raise ValueError if not 0 &lt;= age &lt;= 100: print('年龄超出范围') raise ValueError self._age = agep1 = Person('666', 100)p2 = Person('666', 16)# print(p1.age) # 希望取到的不是年龄，而是年龄对应的阶段# p1.age = -12 # 存0# p1.age = 200 # 存150# 这儿实质是在调用__age的getter方法。print(p1.age) # LOLprint(p2.age) # 未成年# 这儿实质是在调用_age的setter方法p1.age = 88print(p1.age) # LOL# p1.age = 888# print(p1.age) # 年龄超出范围# 练习：声明一个时间类，有一个属性以秒的形式保存时间# 不断的输入时间：以'xx:xx'分秒的形式输入。并且将这些时间对象保存到列表中，直到# 输入end，为止。 10:20 --&gt; time.秒 = 620class Time: # time_list = [] def __init__(self, str1:str): self._str1 = str1 @property def str1(self): list1 = self._str1.split(':') second = int(list1[0])*60 + int(list1[1]) # Time.time_list.append(second) return second @str1.setter def str1(self, str1): self._str1 = str1 \"\"\" 补充：打印自己声明的类的对象时，默认打印的是：&lt;模块名.类名 object at 对象地址&gt; 如果不希望以默认方式打印对象，可以用以下魔法方法实现。打印对象时，就会打印这个 魔法方法的返回值，必须是字符串。 \"\"\" # def __repr__(self): # return '转换后为：' + str(self.str1) def __repr__(self): return '&gt;&gt;' + self.__class__.__module__ + self.__class__.__name__ + \\ ' object at ' + hex(id(self)) + '&lt;&lt;'time_list = []t1 = Time('10:20')print(t1.str1)t1.str1 = '1:20' # 620print(t1.str1) # 80while True: value = input('时间：') if value == 'end': break else: t = Time(value) time_list.append(t)print(time_list) #14.4 类的继承 1.继承pyhon中类支持继承，并且支持多继承。python中类默认情况下是继承自object（object是pyhon中所有类的基类。） a.什么是继承一个类可以继承另外一个类，继承者叫子类，被继承者叫父类。继承就是让子类直接拥有父类中的内容。 b.可以继承哪些内容所有的属性和方法都可以继承1.对象属性2.类的字段3.对象方法4.类方法… 123456789101112131415161718192021222324class Person: num = 61 # 注意：__slots__对应的值不会被继承 __slots__ = ('name', 'age', 'sex') __num = 16 def __init__(self, sex): self.name = '119' self.age = 0 self.sex = sex def show_message(self): print('%s你是119吗' % self.name)# Student类继承Person类class Student(Person): passs1 = Student('男')print(s1.name) # 119print(Student.num) # 61s1.show_message() # 119你是119吗 #14.5 添加属性和方法子类除了拥有从父类继承下来的属性和方法，还拥有属于自己的属性和方法 1.在子类中添加方法 a.添加一个新的方法直接在子类中声明其他方法;添加后子类可以调用自己的方法，也可以调用父类的方法，但是父类不能调用子类的方法。 b.重写父类的方法：重新实现父类方法完全重写 - 覆盖父类功能 - 直接在子类中重写父类方法部分重写 - 保留父类功能，添加新的功能 - 在子类中实现父类方法时，通过super()去调用父类方法，再添加新功能。 注意：可以在子类方法中通过super()去调用父类对象方法。注意：子类静态方法中不能使用此方法，会报错：没有参数，静态方法是没有默认参数self的。super(类，对象) - 获取对象中父类的部分（要求对象是这个指定类的对象） c.类中方法的调用过程通过对象调用方法时，先看当前类中是否声明过此方法，如果声明过就直接调用当前类对应的方法。如果当前类中没有声明过，会去找父类中有没有声明过此方法，声明过就调用父类方法。如果父类也没有声明，就去找父类的父类。。以此类推，直到object中也没有，程序崩溃。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person: num = 61 def __init__(self, sex): self.name = '119' self.age = 0 self.sex = sex def show_message(self): print('%s你是119吗' % self.name) @staticmethod def info(): print('我是人类。')class Student(Person): def study(self): print('%s在学习' % self.name) # 完全重写 @classmethod def message(cls): print('我是学生。') @staticmethod def info(): print('我是学生。') # 保留父类功能 def show_message(self): super().show_message() print('我去上小学')s1 = Student('男')p1 = Person('女')# p1.study() AttributeError: 'Person' object has no attribute 'study'Student.info() # 我是学生。Person.info() # 我是人类。s1.show_message() # 119你是119吗 我去上小学p1.show_message() # 119你是119吗 #14.6 添加属性 1.添加类的字段直接在子类中添加新的字段 2.添加对象属性子类的对象属性是通过继承父类对象属性init方法来的 如果想要在保留父类继承下来的对象属性的前提下，添加新的对象属性，需要在子类init方法中，通过super（）去调用父类的init方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Person: num = 61 def __init__(self, sex): self.name = '119' self.age = 0 self.sex = sex def show_message(self): print('%s你是119吗' % self.name) @staticmethod def info(): print('我是人类。')class Student(Person): number = 100 def __init__(self, sex): # 注意此处父类参数。 super().__init__(sex) self.study_id = 9999 def study(self): print('%s在学习' % self.name) # 完全重写 @classmethod def message(cls): print('我是学生。') @staticmethod def info(): print('我是学生。') # 保留父类功能 def show_message(self): super().show_message() print('我去上小学')print(Student.num, Student.number) # 61 100# 练习：动物类，有属性：年龄，颜色，类型。要求创建动物对象时，类型和颜色必需赋值# 年龄可以赋值，可以不赋值# 声明一个猫类，有属性：年龄，颜色，类型，爱好# 要求创建猫对象时，颜色必须赋值，年龄，爱好可以赋值，可以不赋值，类型不能赋值。class Animal: def __init__(self, color, type1, age=99): self.type1 = type1 self.color = color self.age = ageclass Cat(Animal): def __init__(self, color, age=99, like='eat'): super().__init__(color, 'cat', age) self.like = likean1 = Animal('犬科', '白色')cat1 = Cat('黑色')","categories":[],"tags":[]},{"title":"","slug":"day15-面向对象和pygame","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day15-面向对象和pygame/","link":"","permalink":"http://yoursite.com/2018/12/21/day15-面向对象和pygame/","excerpt":"","text":"#15.1 多继承 1.多继承多继承：让一个类同时继承多个类注意：实际开发时，一般不使用多继承。 123456789101112131415161718192021222324252627282930313233class Animal: num = 88 def __init__(self, name='', age=0, color=''): self.name = name self.age = age self.color = colorclass Fly: num = 61 def __init__(self, distance=0, speed=0): self.distance = distance self.speed = speed @staticmethod def show(): print('飞飞飞')# 让bird同时继承Animal和Flyclass Bird(Animal, Fly): passprint(Bird.num) # 88b1 = Bird()print(b1.name)print(b1.speed) # 报错，应为对象属性初始化只能继承第一个Animal类# 两个类的方法都能继承# 俩个类不同名字的字段都能继承，重名的只能继承第一个Animal类 2.多态类的特点：封装、继承、多态封装：可以对多条数据（属性）和功能（方法）进行封装继承：可以让一个类拥有另外一个类的属性和方法多态：有继承就有多态（一个事物的多种形态）#15.2 运算符重载 1.函数重载c++/java声明函数的语法：返回值类型 函数名（参数类型1 参数名1，参数类型2 参数名2）{ 函数体}int func1(){}pyhon中不支持函数重载,因为python中函数是变量 2.运算符重载python中使用运算符的时候，实质是在调用相应的魔法方法（python中每个运算符都对应一个魔法方法） 运算符重载：在不同的类中实现同一个运算符对应的魔法方法，来让类的对象支持相应的运算。123456789101112131415161718192021222324252627282930313233343536373839404142class Student: def __init__(self, name='1', score=0, age=0): self.name = name self.score = score self.age = age # + 重载 \"\"\" 数据1 + 数据2 - 数据1传给self，数据2传给other \"\"\" def __add__(self, other): # self + other return self.score + other.score # - 减法 def __sub__(self, other): return self.age - other.age # 注意：&gt;和&lt;一般只需要重载一个，另一个自动支持，除非比较的原素不一样 # 小于运算 def __lt__(self, other): return self.score &lt; other.score def __repr__(self): return '&lt;' + str(self.__dict__)[1:-1] + '&gt;'s1 = Student('3')s2 = Student('4', 99)s3 = Student('5', 67)s4 = Student('6', 100)s5 = Student('7', 33)print(s1 + s2) # class Student# 1 + 2 # class int# 'a' + 2 # class str# 4 &lt; 7list1 = [s1, s2, s3, s4, s5]print(max(list1)) # 大于小于重载只需要一个，系统会自动取反list1.sort()print(list1)print(s1 == s2) # 基类object，则都支持 #15.3 内存管理机制 1.堆和栈内存区域分堆区间和栈区间；栈区间的内存的开辟和释放是自动的，堆区间内存是手动开辟和手动释放的。内存管理，管理的是堆区间的内存 2.数据的存储 a.python中所有的数据都是对象，都是保存在堆中的。b.python中所有的变量存储的都是存在堆中的数据的地址，存了对象地址的变量又叫对象的引用。c.默认情况下创建对象就会在堆区间去开辟空间存储数据，并且将地址返回，如果对象是数字或字符串，会做缓存，每次使用时会去缓存中看是否使用过相同的数字或字符串，如果有就返回之前的数据的地址，没有才开辟新的空间存储数据。 3.数据的销毁python中通过‘垃圾回收机制’来管理内存的释放。原理：看一个对象（数据）是否销毁，就看这个对象的引用计数是否为0.为0就销毁，不为0就不销毁。引用计数：对象引用的个数。不是时刻检测，隔一段时间检测一次，回收掉引用计数为0的对象。1234567891011121314151617181920212223242526272829303132333435from sys import getrefcount as g\"\"\"getrefcount(对象) - 获取对象的引用计数\"\"\"# 1.增加引用计数：使用变量存对象地址list1 = [1] # [1]是一个对象 list1是它的引用 此时对象引用计数为1print(g(list1)) # 引用记数为2，因为g函数也引用了1次。并且函数# 结束后计数-1，因为被销毁list2 = list1 # 此时对象引用计数为2print(g(list1)) # 引用记数为3，因为g函数也引用了1次。list3 = [list1, 100] # 此时对象引用计数为3print(g(list1)) # 引用记数为4，因为g函数也引用了1次。# 减少引用计数\"\"\"a.删除引用b.让当前对象的引用成为别的对象的引用\"\"\"print(id(list3[1]))del list3[0]print(g(list1)) # 引用记数为2 + 1list2 = 100print(g(list1)) # 引用记数为1 + 1print('====================')print(id(list2))print(g(100)) # 2 + 1 可能其它地方用过#list1 = [1, 2] #15.4 pygame游戏最小系统1import pygame 1.游戏初始化 pygame.init() 2.创建游戏窗口 set_mode(窗口大小) - 窗口大小是一个元组，有两个元素：width，heightset_mode((宽度，高度))宽度和高度单位是像素 1window = pygame.display.set_mode((300, 600)) fill(颜色) - fill((r,g,b)) r,g,b都在0-255计算机颜色：3原色 - 红绿蓝（简称rgb） 颜色值就是由3个数字组成，分别代表红绿蓝，数字范围为：0-255 pyhon中的颜色是一个元组，元组中是3个颜色，分别为r，g，b（255，255，255） - 白色（0，0，0） - 黑色（255，0，0） - 红色123456789101112131415# 将窗口填充成指定的颜色window.fill((255, 255, 255))# 将窗口展示在屏幕上pygame.display.flip()# 3.创建游戏循环while True: # 4.检测事件 for event in pygame.event.get(): # 区分不同的事件，做出不一样的反应 # print(event) 打印窗口所有事件 # 关闭按钮点击事件是否发生 pygame.display.flip() if event.type == pygame.QUIT: # 结束线程 exit() #15.5 在窗口上显示图片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import pygamepygame.init()window = pygame.display.set_mode((400, 600))window.fill((255, 255, 255))# =========显示图片============# 1.加载图片\"\"\"pygame.image.load(图片地址) - 加载指定路径图片，返回一个图片对象\"\"\"image_obj = pygame.image.load('files/1.jpg')# 2.渲染图片\"\"\"blit(渲染对象，位置)渲染对象 - 图片对象（要显示的东西）位置 - 元组（坐标）（x，y）\"\"\"# window.blit(image_obj, (0, 0))# 3.获取图片的大小\"\"\"对象.get_size（） - 获取对象大小，返回值是一个元组：（width，height）\"\"\"image_w, image_h = image_obj.get_size()window.blit(image_obj, ((400-image_w)*0.5, (600-image_h)*0.5)) # 居中# 4.图片缩放和旋转a.缩放pygame.transform.scale(图片对象，大小) - 缩放；将指定的图片缩放到指定的大小并返回一个新的图片。可能会变形！！\"\"\"# new_image_obj = pygame.transform.scale(image_obj, (400,200))# window.blit(new_image_obj, (0, 0))\"\"\"b.旋转缩放pygame.transform.rotozoom(图片对象，旋转角度，缩放比例) 不会变形,可做旋转\"\"\"for i in range(1000): new_image_obj = pygame.transform.rotozoom(image_obj, i*30, 1) window.blit(new_image_obj, ((400 - image_w) * 0.5, (600 - image_h) * 0.5)) # window.blit(new_image_obj, (0, 0)) pygame.display.update()# pygame.display.flip()while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: exit() #15.5 在窗口上显示文字1234567891011121314151617181920212223242526272829303132333435363738394041424344import pygamepygame.init()window = pygame.display.set_mode((1000, 600))window.fill((255, 255, 255))# ======显示文字========# 1.创建字体对象（选笔）\"\"\"a 系统字体font = pygame.font.SysFont(字体名，字体大小，是否加粗=False，是否倾斜=False)- 返回一个字体对象（系统字体只能支持英文显示）b 自定义字体ttf - 字体文件格式，可在程序中使用。\"\"\"# a 系统字体# font = pygame.font.SysFont('Times', 100)# b 自定义字体font = pygame.font.Font('files/aa.ttf', 100)# 2.根据字体创建文字对象\"\"\"render(文字内容，是否平滑，文字颜色)text, antialias, color\"\"\"text = font.render('中文', True, (255, 0, 0))text1 = font.render('回手，掏！！', True, (255, 0, 0))text2 = font.render('走位，走位，走位！！！', True, (255, 0, 0))text3 = font.render('诶！打不到我！！', True, (255, 0, 0))text4 = font.render('诶！打不到我！！', True, (255, 0, 0))# 3.把文字渲染到窗口上window.blit(text, (0, 100))window.blit(text1, (0, 0))window.blit(text2, (0, 200))window.blit(text3, (0, 300))window.blit(text4, (0, 400))pygame.display.flip()while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: exit() #15.7 在窗口上显示图形1234567891011121314151617181920212223242526272829303132333435363738394041424344import pygamefrom color import Colorimport math# 游戏最小系统pygame.init()window = pygame.display.set_mode((1000, 600))window.fill((255, 255, 255))# ====显示图形====# 1.画直线\"\"\"pygame.draw.line(画在哪儿，线的颜色，起点，终点, 线宽)\"\"\"pygame.draw.line(window, Color.green, (0, 0), (100, 100), 10)\"\"\"pygame.draw.lines(画在哪儿，线的颜色,是否闭合，点列表，线宽）依次链接点列表中所有的点，是否闭合决定是否链接起点和终点\"\"\"list1 = [(0, 0), (100, 0), (100, 200), (0, 200)]pygame.draw.lines(window, Color.red, True, list1, 5)# 2.画圆\"\"\"pygame.draw.circle(画在哪儿，颜色，圆心坐标，半径，线宽=0)线宽=0 是实心的圆\"\"\"# pygame.draw.circle(window, Color.yellow, (400, 400), 200, 150)# 3.画弧线\"\"\"arc(画在哪，颜色，矩形（Rect），起始弧度，终止弧度，线宽=1)矩形（Rect） - （x,y,width,height）;x,y是矩形左上角坐标，width和height是矩形的宽和高\"\"\"pygame.draw.arc(window, Color.blue, (400, 400, 200, 100), math.pi/4*5, math.pi/4*7, 20)pygame.draw.arc(window, Color.blue, (400, 400, 200, 100), 0, math.pi, 20)pygame.display.flip()while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: exit() 15.8椭圆、矩形、多边形12345678910111213141516171819202122232425import pygamefrom color import Colorimport math# 游戏最小系统pygame.init()window = pygame.display.set_mode((1000, 600))window.fill((255, 255, 255))# 弧度\"\"\"arc(Surface, color, Rect, start_angle, stop_angle, width=1)\"\"\"pygame.draw.arc(window, Color.rand_color(), (0, 0, 200, 100), 0, 2*math.pi, 20)# 椭圆\"\"\"ellipse(Surface, color, Rect, width=0)\"\"\"pygame.draw.ellipse(window, Color.rand_color(), (300, 300, 200, 100), 0)pygame.display.flip()while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: exit() #15.9 事件和动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import pygamefrom color import Colorpygame.init()window = pygame.display.set_mode((400, 600))window.fill((255, 255, 255))# 在这儿写的代码是静态的(界面上的内容)x = 100y = 100width = 100height = 80pygame.draw.rect(window, Color.green, (x, y, width, height))pygame.display.flip()while True: y += 3 # width -= 2 window.fill(Color.white) # 覆盖原来的状态 pygame.draw.rect(window, Color.rand_color(), (x, y, width, height)) pygame.display.update() # 重新显示 # 有事件产生的时候才会进入for循环 for event in pygame.event.get(): # 1.type属性 \"\"\" 不同的type值对应不同类型的事件 QUIT - 关闭按钮被点击事件 a.鼠标相关事件 - 按的位置 MOUSEMOTION - 鼠标移动 MOUSEBUTTONDOWN - 鼠标按下 MOUSEBUTTOUP - 鼠标弹起 event.pos - 获取鼠标事件产生的位置 b.键盘事件 - 按的是哪个键 KEYDOWN - 按键按下 KEYUP - 按键弹起 event.key - 被按的键对应的字符的编码值 \"\"\" if event.type == pygame.QUIT: exit() elif event.type == pygame.MOUSEMOTION: # print('鼠标移动', event.pos) # pygame.draw.circle(window, Color.rand_color(), event.pos, 30) # pygame.display.flip() pass elif event.type == pygame.MOUSEBUTTONDOWN: # 鼠标按下要做什么就写在这儿 print('鼠标按下', event.pos) pygame.draw.circle(window, Color.rand_color(), event.pos, 30) pygame.display.flip() elif event.type == pygame.MOUSEBUTTONUP: print('鼠标弹起!', event.pos) elif event.type == pygame.KEYDOWN: print('按键按下') print(event.key, chr(event.key)) elif event.type == pygame.KEYUP: print('按键弹起') print(event.key, chr(event.key))","categories":[],"tags":[]},{"title":"","slug":"学生管理系统1-0","date":"2018-12-21T01:34:21.326Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/学生管理系统1-0/","link":"","permalink":"http://yoursite.com/2018/12/21/学生管理系统1-0/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209def huan_ying(): '''输出界面''' print('=' * 88, '\\n❀❀欢迎来到LOL小学生管理系统：\\n') dict1 = &#123;' 💗 1.': '添加学生', ' 💗 2.': '查看学生', ' 💗 3.': '修改学生信息', ' 💗 4.': '删除学生', ' 💗 5.': '返回', ' 💗 6.': '退出'&#125; for key in dict1: print(key, dict1[key]) print('=' * 88)# 5 是否多余# 学生信息--字典# 学生信息修改--字典增加、查找、修改# 多个学生的信息--列表 zong_biao# 列表增加、查找、修改def cha_zhao(n, str1): \"\"\"在学生总表中查找包含&#123;key：str1， value：n&#125;的学生，有则返回该学生字典 对应的下标，没有则返回-1\"\"\" for index in range(len(zong_biao)): if n == zong_biao[index][str1]: # 找到相应位置 return index return -1def san_chu(n, str1): \"\"\"在学生总表中删除包含&#123;key：str1， value：n&#125;的学生\"\"\" index = 0 while index &lt; len(zong_biao): if n == zong_biao[index][str1]: # 找到相应位置 zong_biao.pop(index) print('删除成功！') print('=' * 20) index -= 1 index += 1def xiu_gai(index, n2, str1): \"\"\"在学生总表中找到下标为index的学生字典，并将key为str1的值改为n2\"\"\" zong_biao[index][str1] = n2 print(\"修改成功!修改后的信息为：\") print('=' * 20) for key in zong_biao[index]: print(key + ':' + zong_biao[index][key]) print('=' * 20)def da_yin(): \"\"\"打印所有学生信息\"\"\" for index in range(len(zong_biao)): for key in zong_biao[index]: print(key + ':' + zong_biao[index][key], end=' ') # 空格隔开 print() # 每输出一个换行def cha_kan(n, str1): for i in range(len(zong_biao)): if n == zong_biao[i][str1]: # 找到相应位置 print('该学生信息如下： ') print('=' * 20) for key in zong_biao[i]: print(key + ':' + zong_biao[i][key]) # 空格隔开 print('=' * 20)zong_biao = []bool1 = Truewhile bool1: da_yin() huan_ying() xuan_ze = input('请选择（1-5）：') if xuan_ze == '1': i = 0 while 1: dict0 = &#123;&#125; value = input('请输入学生学号：') dict0['学号'] = value value = input('请输入学生姓名：') dict0['姓名'] = value value = input('请输入学生年龄：') dict0['年龄'] = value value = input('请输入学生电话：') dict0['电话'] = value zong_biao.append(dict0) # 防止越界，扩展列表长度 zong_biao[i] = dict0 # 防止被覆盖 i += 1 print('添加成功！\\n1. 继续\\n2. 返回\\n请选择(1-2):') n = input() if n == '1': continue elif n == '2': break else: print('请输入1-2内的数字。') continue # print(zong_biao) elif xuan_ze == '2': while 1: print('1.查看所有学生\\n2.按姓名查找\\n' '3.按学号查找\\n4.返回\\n请选择(1-4):') n = input() if n == '1': print('所有学生信息如下：') print('=' * 20) da_yin() print('=' * 20) continue elif n == '2': n = input('请输入要查找的学生姓名：') str1 = '姓名' value = cha_zhao(n, str1) if value != -1: cha_kan(n, str1) # 注意自变量 else: print('查无此人！请核对输入信息！！') continue elif n == '3': n = input('请输入要查找的学生的学号：') str1 = '学号' value = cha_zhao(n, str1) if value != -1: cha_kan(n, str1) # 注意自变量 else: print('查无此人！请核对输入信息！！') continue elif n == '4': break else: print('请输入1-4内的数字。') continue elif xuan_ze == '3': bool2 = True while bool2: n1 = input('请输入要修改学生的学号：') # 学号只有一个 value = cha_zhao(n1, '学号') if value != -1: i = cha_zhao(n1, '学号') # 找出需要修改的字典 else: print('查无此人！请核对输入信息！！') continue while 1: n = input('请选择要修改的信息：\\n' '1.修改学号\\n2.修改姓名\\n' '3.修改年龄\\n4.修改电话\\n' '5.修改下一个学生\\n6.退出修改\\n请选择（1-6）:') if n == '1': n2 = input('请输入修改后的学号：') str1 = '学号' xiu_gai(i, n2, str1) continue elif n == '2': n2 = input('请输入修改后的姓名：') str1 = '姓名' xiu_gai(i, n2, str1) continue elif n == '3': n2 = input('请输入修改后的年龄：') str1 = '年龄' xiu_gai(i, n2, str1) continue elif n == '4': n2 = input('请输入修改后的电话：') str1 = '电话' xiu_gai(i, n2, str1) continue elif n == '5': break elif n == '6': bool2 = False break else: print('请输入1-6内的数字。') continue elif xuan_ze == '4': while 1: n = input(('1.按学号删除\\n2.按姓名删除\\n3.返回\\n请选择（1-3）：')) if n == '1': n = input('请输入要删除学生的学号：') # 学号只有一个 str1 = '学号' value = cha_zhao(n, str1) if value != -1: san_chu(n, str1) else: print('查无此人！请核对输入信息！！') continue elif n == '2': n = input('请输入要删除学生的姓名：') str1 = '姓名' value = cha_zhao(n, str1) if value != -1: san_chu(n, str1) else: print('查无此人！请核对输入信息！！') continue elif n == '3': break else: print('请输入1-2内的数字。') continue elif xuan_ze == '5': continue elif xuan_ze == '6': print('谢谢使用，欢迎下次再来！') break else: print('请输入1-5内的数字。') continue","categories":[],"tags":[]},{"title":"","slug":"day10-函数3","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day10-函数3/","link":"","permalink":"http://yoursite.com/2018/12/21/day10-函数3/","excerpt":"","text":"#10.1 变量的作用域 1.变量的作用域 变量在程序中能使用的范围 2.全局变量 a.声明在函数或类的外部的变量都是全局变量（python中）b.全局变量的作用域是从声明开始到整个py文件结束，任何位置都可以使用（作用域：从声明开始到文件结束） 3.局部变量 a.声明在函数或类的内部的变量都是局部变量（形参是局部变量）b.局部变量的作用域从声明开始到函数结束函数内任何位置都可使用（作用域：从声明开始到函数结束） 1234567891011121314151617# 全局变量a = 10 # 全局变量for x in range(10): # 全局变量 y = 20 # 全局变量 print(x)print(x, y) # 9 20 全局变量if True: b = 10 # 全局变量# 局部变量def func2(num1, num2): print(num1, num2) aa = 1 # num1 num2 aa 都是局部变量 global的使用 语法：global 变量名变量名 = 值 global - 关键字；只能在函数中使用，用来在函数中声明一个全局变量在函数中声明一个全局变量，如果函数已被调用则外部可使用该全局变量;可用于修改或创建全局变量（在函数中）。12345678910111213141516171819# 声明一个全局变量a1a1 = 100def test(): # 声明一个局部变量a1 # a1 = 200 # print(a1) global a1 # 声明全局变量 a1 = 200 global b1 b1 = 99 # 在函数中声明全局变量b1 print(a1)# test() # 200# print(a1) # 100test() #200print(a1) #200 5.nonlocal nonlocal只能在函数中使用当需要在局部1的局部中修改局部1变量的值，就使用nonlocal 1234567891011121314151617181920212223242526272829303132333435363738394041424344def func1(): # 声明一个局部变量a2 a2 = 'abc' # python中函数可声明函数 def func2(): # func2也只能在func1中使用 a2 = 'python' print(a2) a3 = 111 # 此时a3作用域在func2中 func2() # python #print(a3) print(a2) # abcfunc1() # python abcprint('*'*88)def func1(): # 声明一个局部变量a2 a2 = 'abc' # python中函数可声明函数 def func2(): # func2也只能在func1中使用 nonlocal a2 # 定义局部的局部变量 a2 = 'python' print(a2) a3 = 111 # 此时a3作用域在func2中 func2() # python # print(a3) print(a2) # pythonfunc1() # python pythonfunctions = []for x in range(5): # 全局变量x = 4,固定了 functions.append(lambda a: a*x) # 循环时未调用函数则不执行 # functions = [lambda a:x*a, lambda a:x*a, lambda a:x*a, lambda a:x*a]t1 = functions[0] # x*at2 = functions[2] # x*a# 当调用时 全局变量x=4,则t1 = t2 = lambda a:4*aprint(t1(2), t2(2)) # 8 8 #10.2 函数作为变量 python中，声明函数其实就是声明一个类型是function的变量。函数名就是变量名 函数名作为变量除了用来调用函数获取返回值外，普通变量能做的，它都能做。1234567891011121314# 声明int类型变量a = 10# 声明list类型变量b = [1, 2, 3]# 声明function类型的变量cc = lambda x:x*xprint(type(c)) # &lt;class 'function'&gt;# 声明function类型的变量func1def func1(x): return x*xprint(type(func1)) # &lt;class 'function'&gt; 1.变量1给变量2赋值1234567891011list1 = [1, 2, 3]list2 = list1 # 赋值print(list2[0]) # 1；使用# 声明一个函数变量func1def func1(): print('我是函数1')f1 = func1 # 函数变量func1给f1变量赋值f1() # 我是函数1;将f1当作函数使用 2.将变量作为列表元素或字典的值1234567891011121314list1 = ['我是列表1第一个元素', 2, 3]list2 = [list1, 4]print(list2[0][0]) # 我是列表1第一个元素# 声明一个函数变量func2def func2(): print('我是函数2')# 将函数变量作为列表元素list3 = [func2, 100]print(list3[0]()) # 我是函数2 None 3.将变量作为函数参数将函数1作为实参，传递给函数2，这里的函数2就是一个（实参）高阶函数。12345678910111213141516def test(x): print('test:', x) if not isinstance(x, int): x()a = 10test(a) # 将a作为test的实参 10def test2(): print('我是测试函数2')test(test2) # test: &lt;function test2 at 0x000001D02F328378&gt; # 我是测试函数2 3.1 sort，max，min函数，都是高阶函数 def sort(key=None, reverse=False): key - 类型为函数;确定排序的时候以什么值为标准来排序（默认情况下，以列表的元素的大小为标准来排序）；需要传一个函数，函数需要1个参数1个返回值。这里的参数是列表的元素。reverse - 是否降序排序，需要传一个bool值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#list2.sort(reverse=True)# list2.sort(reverse=True)\"\"\"[1, 34, 20, 89, 8] -&gt; [1, 8, 20, 34, 89]index = 0 [1, 34, 20, 89, 8]index = 1 [1, 8, 34 ,89, 20]index = 2 [1, 8, 20, 89, 34]...\"\"\"def yt_sort(list1, key=None): # list1 = my_list2; key = get_age if key == None: # 直接对列表元素进行排序 for index in range(len(list1)): for index2 in range(index+1, len(list1)): current = list1[index] behind = list1[index2] if behind &lt; current: list1[index], list1[index2] = list1[index2], list1[index] else: for index in range(len(list1)): for index2 in range(index+1, len(list1)): current = key(list1[index]) behind = key(list1[index2]) if behind &lt; current: list1[index], list1[index2] = list1[index2], list1[index]my_list = [1, 34, 20, 89, 8]yt_sort(my_list)# my_list.sort()print(my_list)my_list2 = [ &#123;'name': '张三', 'age': 18&#125;, &#123;'name': '李四', 'age': 30&#125;, &#123;'name': '王五', 'age': 10&#125;]# my_list2.sort() # TypeError: '&lt;' not supported between instances of 'dict' and 'dict'# yt_sort(my_list2) # TypeError: '&lt;' not supported between instances of 'dict' and 'dict'def get_age(x): return x['age']yt_sort(my_list2, get_age)print(my_list2)my_list2 = [ &#123;'name': '张三', 'age': 18, 'score': 90&#125;, &#123;'name': '李四', 'age': 30, 'score': 80&#125;, &#123;'name': '王五', 'age': 10, 'score': 89&#125;]# 取最大年龄对应的字典max_age = max(my_list2, key=lambda x: x['age'])print(max_age)# 取最大成绩对应的字典max_score = max(my_list2, key=lambda x: x['score'])print(max_score)# 练习：要求将按列表中元祖的第二个元素，获取最大值。my_list3 = [('z', 10), ('b', 30), ('c', 20)]print(max(my_list3, key=lambda item: item[1]))# maxdict1 = &#123;'a': 10, 'b': 5, 'c': 8&#125;list3 = [('z', 10), ('b', 30), ('c', 20)]print(max(list3, key=lambda x: x[1])) # ('b', 30) 4.变量作为函数的返回值返回值是函数的函数，也叫高阶函数（返回值高阶函数）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# int类型变量作为返回值def test2(n): s = 1 for i in range(1, n+1): s *= i return sre = test2(5) + 10 # 130# 函数类型变量作为返回值def get_operation(char): # 返回值高阶函数 \"\"\" 根据不同的符号返回不同的功能（函数功能的描述） :param char: 运算符符号 :return: 不同运算符对应的功能的函数 \"\"\" if char == '+': return my_sum elif char == '*': return mul elif char == '-': return diff else: print('暂时不支持这个运算符')def diff(*args, **kwargs): \"\"\" 求差 :param args: 元组类型数据 :param kwargs: 字典类型数据 :return: 所有数据的累差 \"\"\" diff1 = 2*args[0] for item in args: diff1 -= item return diff1 # diff1 = 2*kwargs[] # for key in kwargs: # sum1 *= kwargs[key] # return sum(args)*sum1def mul(*args, **kwargs): \"\"\" 求积 :param args: 元组类型数据 :param kwargs: 字典类型数据 :return: 所有数据的积 \"\"\" sum1 = 1 for key in kwargs: sum1 *= kwargs[key] return sum(args)*sum1def my_sum(*args, **kwargs): \"\"\" 求和 :param args: 元组类型数据 :param kwargs: 字典类型数据 :return: 所有数据的和 \"\"\" sum1 = 0 for key in kwargs: sum1 += kwargs[key] return sum(args)+sum1print(get_operation('+')(1, 2, 3)) # 6re1 = get_operation('+') # 函数print(re1(1, 2, 3)) # 6 调用求和函数获取返回值re1 = get_operation('*') # 函数print(re1(1, 2, 3)) # 6 调用求积函数获取返回值re1 = get_operation('-') # 函数print(re1(1, 2, 3)) # -4 调用求累差函数获取返回值 #10.3 迭代器 1.什么是迭代器（iter）迭代器是python中的容器类的数据类型，可以同时存储多个数据。取迭代器中的数据只能一个一个取，而且取出来的数据，在迭代器中就没有了。 2.迭代器中数据来源 a.将其他序列转换成迭代器b.使用生成式、生成器产生数据 1.将数据转换成迭代器所有的序列都能转成迭代器1234567891011# 将字符串转换成迭代器iter1 = iter('abcd')print(iter1) # &lt;str_iterator object at 0x000002237329B4E0&gt;# 将列表转成迭代器iter2 = iter([1, 2, 3, 4])print(iter2) # &lt;list_iterator object at 0x000002237329B550&gt;# 将字典转成迭代器iter3 = iter(&#123;'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5&#125;)print(iter3) # &lt;dict_keyiterator object at 0x000002237143B4A8&gt; 2.获取迭代器中的数据a.next(迭代器)或者迭代器.__next__() - 取出迭代器中第一个元素（已经取出的元素再也回不到迭代器中了）。当迭代器是空时，使用next获取元素，会出现异常StopIteration12345678910print(next(iter1)) # aprint(next(iter1)) # bprint(next(iter1)) # cprint(next(iter1)) # d#print(next(iter1)) # StopIterationprint(iter2.__next__()) # 1print(iter2.__next__()) # 2# print(iter2.__next__()) # 3# print(iter2.__next__()) # 4 b.通过for循环取出迭代器中每个元素12for x in iter2: print('===', x) # 3 4 #10.4 生成器 1.什么是生成器生成器就是迭代器；迭代器不一定是生成器生成器就是带有yield关键字的函数的结果 2.生成器怎么产生数据调用带有yield关键字的函数，拿到的结果就是一个生成器。生成器中元素就是yield关键字后面的值。只要函数中有yield关键字，调用函数就不会再执行函数体及获取返回值，而是创建一个生成器。当获取生成器元素时，才会执行函数的函数体，执行到yield语句为止，并且将yield后面的值作为结果返回；并且保存当前执行的位置获取下一个元素时，就从上次结束位置接着往下去执行函数，如果函数结束了，就出现StopIteration，直到函数结束或遇到yield为止。 生成器对应的函数，执行完成遇到yield的次数决定了生成器能产生数据的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104def func(): i = 0 while i &lt; 10: yield i i += 1print(next(func())) # 0for item in func(): print(item) # 0 1 2 3 4 5 6 7 8 9def func1(): print('abc') yield 100 return 10# 只要函数中有yield关键字，调用函数就不会再执行函数体及获取返回值，而是创建一个生成器。re = func1()print(func1()) # &lt;generator object func1 at 0x00000150A4686938&gt; 生成器# next(re) # abc；执行re对应的函数的函数体，将yield关键字作为结果。# StopIteration: 10print('===', next(re)) # abc === 100 获取的是yield后面的值gener1 = func() # 要先用一个变量接收，后面才会一个一个迭代print(next(gener1)) # 0print(next(gener1)) # 1print(next(gener1)) # 2def nums(): for i in range(101): yield igener = nums()print(next(gener)) # 0print(next(gener)) # 1print(next(gener)) # 2# 生成无限个不重复学号def xue_hao(): x = 1 while 1: yield 'stu' + str(x) x += 1stu_xue = xue_hao()print(next(stu_xue)) # 1print(next(stu_xue)) # 2print(next(stu_xue)) # 3print(next(stu_xue)) # 4for _ in range(5): print(next(stu_xue)) # 5 6 7 8 9print(next(stu_xue)) # 10# 写一个生成器可以不断产生斐波那契数列：1，1，2，3，5，8，13，21。。。def f_s(): x1 = x2 = 1 yield x1 yield x2 while 1: t = x1 + x2 yield t x1, x2 = x2, tdef f_s1(n): pre_1 = 0 pre_2 = 1 for _ in range(n): yield pre_2 pre_1, pre_2 = pre_2, pre_1 + pre_2nums = f_s()print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))nums = f_s1(20)print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))print(next(nums))","categories":[],"tags":[]},{"title":"","slug":"day13-类和对象","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day13-类和对象/","link":"","permalink":"http://yoursite.com/2018/12/21/day13-类和对象/","excerpt":"","text":"#13.1 编程思想 1.编程思想： 1.面向过程编程 - 逻辑、算法遇到问题考虑直接把逻辑思维转换成代码，解决问题2.函数式编程 - 函数遇到问题想到用函数解决。考虑是否有这种功能的函数。3.面向对象编程 - 类和对象遇到问题，就考虑是否有一个对象能帮我解决这个问题 2.类和对象1.定义类：就是拥有相同属性和功能的对象的集合(类是抽象的)对象：类的实例（对象是具体的）2.从生活的角度考虑类的对象如果‘人’是一个类，余婷是一个对象，骆老师也是一个对象。 #13.2 类的声明 1.类的声明123语法：class 类名（父类列表）： 类的内容 说明：class - 声明类的关键字类名 - 标识符，不能是关键字；采用驼峰式命名，并且首字母大写；见名知义。（父类列表） - 继承语法；可以省略，省略时相当于（objct）即基类（祖宗类）。类的内容 - 主要包含属性和方法 补：驼峰式命名：名字由多个单词组成，通过单词首字母大写来区分不同的单词。 方法:python中声明在类中的函数叫方法。 2.类的属性和方法类中的属性 - 指的是在类中声明的变量；分为类的字段和对象属性类中的方法 - 指的是在类中声明的函数；分为对象方法，类方法和静态方法。1234567891011121314# 声明了一个Person类class Person: \"\"\"人类\"\"\" num = 61 # 类的字段 age = 61 # 对象属性 name = 123 # 方法 def eat(self): print('%s在吃饭。' % Person.name)# Person是类（类就是类型）print(Person) # &lt;class '__main__.Person'&gt; 3.创建对象1类名（）- 创建类对应的对象 12345xiao_ming = Person()# 创建Person类的对象xiao_mingprint(xiao_ming) # &lt;__main__.Person object at 0x000001D82796B8D0&gt;xiao_ming.eat() # 123在吃饭。print(xiao_ming.name) # 123 #12.3 对象方法 1.什么是对象方法直接声明在类中，并且自带一个叫self的参数的函数，就是对象方法。 2.对象方法的调用 - 通过对象调用对象方法对象.对象方法（） 3.self（当前对象）通过对象调用对象方法时，对象方法中第一个参数self不用传参，系统会自动将当前对象传给self。哪个对象调用的self就指向谁。 注意：当前类的对象能做的事情，self都能做。123456789101112131415161718192021222324# 创建一个Person类class Person: \"\"\"人类\"\"\" def __init__(self): self.name = '' # 声明了一个对象方法sleep def sleep(self): print('self', self) print('%s睡觉！' % self.name) self.run() # 对象能做的，self都能做；当前对象 def run(self): print('跑')# 创建person对象p1p1 = Person()print('p1', p1) # p1 &lt;__main__.Person object at 0x0000017DADA7B4E0&gt;p1.sleep() # self &lt;__main__.Person object at 0x0000017DADA7B4E0&gt;p2 = Person()p2.name = '小花'p2.sleep() # 小花睡觉！ 跑 #12.4 init方法和构造方法 0.魔法方法：python类中，用__开头及结尾的方法，就是魔法方法，魔法方法不需要主动调用，都会自动调用。 1.__init__方法a.是对象方法，可用对象调用b.不需要自己调用，会被自动调用c.在创建对象后，专门用来对对象做初始化。 2.构造方法概念：函数名和类名一样的函数，就是构造方法。用于创建对象。当我们创建类时，系统会自动创建这个类的构造方法，用来创建对象。当我们通过构造方法创建对象时，系统会自动调用init方法来对创建好的对象进行初始化。 注意：当init方法中除了self以外如果需要别的参数，那么这些参数是通过构造方法传入的。只要调用了构造方法，就会产生新的对象。想要对象，就要用构造方法。12345678910111213141516171819202122232425262728293031323334353637class Person(object): def __init__(self, name, age=0): print('self', self) print('init方法', name)\"\"\"def Person(*args, **kwargs): 在堆中开辟空间创建对象 对象.__init__(*args, **kwargs) return 对象\"\"\"p0 = Person('abc', 10)p1 = Person('abc', 10)print('p1:', p1)p2 = Person('123', age=20)print('p2:', p2)# p3 = Person()p3 = p1# 模拟构造方法和init方法def __init__(a, b): print('自己实现', a, b)def Person1(*args, **kwargs): # args = (10, 20) print('创建对象') __init__(*args, **kwargs) print('返回对象')Person1(10, 20)# 注意tuple1 = (10, 20)print(*tuple1) # 10 20 #13.5 对象属性 1.什么是对象属性a.声明在__init__方法中b.self.属性名 = 值c.通过对象使用: 对象.属性d.不同的对象,属性可能不一样 语法:self.变量名 = 值说明:变量名就是属性名,这个变量就是对象属性 2.什么样的属性应该声明成对象的属性如果属性值会因为对象不同而不一样,那这样的属性就应该声明成对象属性.反之声明成类的字段.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# 情况1:所有对象属性创建时都使用一个固定的默认值class Person: def __init__(self): # 这里的name和age就是Person类的对象属性. self.name = '' self.age = 0# 创建对象p1 = Person()# 使用对象属性p1.name = 'ZH'print(p1.name) # ZHprint(p1.age) # 0p2 = Person()p2.name = 'Z'print(p1.name) # ZHprint(p2.name) # Zprint(p1.age) # 0print('='*88)# 情况2:创建对象时,决定对象属性值class Person: def __init__(self, name, age=1): # 这里的name和age就是Person类的对象属性. self.name = name self.age = age# 创建对象p1 = Person('ZH')# 使用对象属性# p1.name = 'ZH'print(p1.name) # ZHprint(p1.age) # 1p2 = Person('Z')# p2.name = 'Z'print(p1.name) # ZHprint(p2.name) # Zprint(p1.age) # 1# 修改对象属性值p1.name = '流浪法师'print(p1.name) # '流浪法师'# 练习,声明一个矩形类\"\"\"属性:长和宽方法:求面积和求周长\"\"\"class Retangle: def __init__(self, length, width): self.length = length self.width = width # 一个对象方法,需不需要除了self以外的其他参数,看实现这个函数的功能需不需要除 # 了属性以外的其他数据. def area(self): return self.width*self.length def perimeter(self): return (self.width+self.length)*2j1 = Retangle(30, 20)print(j1.area()) # 600print(j1.perimeter()) # 100# 练习:声明一个point类,拥有属性x,y坐标.拥有的功能是求一个点到另一个点的距离class Point: def __init__(self, x, y): self.x = x self.y = y # def distance(self, x1, y1): # return ((self.x-x1)**2 + (self.y-y1)**2)**0.5 def distance(self, other): return ((self.x-other.x)**2 + (self.y-other.y)**2)**0.5p1 = Point(1, 2)p2 = Point(4, 6)# p1_p2 = p1.distance(p2.x, p2.y)# print(p1_p2) # 5.0print(p1.distance(p2)) # 5.0 #13.6 对象属性的增删改查12345678class Dog: def __init__(self, name, color, type): self.name = name self.color = color self.type = typedog1 = Dog('旺财', '黄色', '二哈') 1.查(获取对象属性的值) 获取指定对象指定的属性a.对象.属性名 - 属性不存在时会报错b.getattr(对象,’属性名’,默认值) - 当属性不存在时,如果设置了默认值,不会崩溃,会返回默认值. 12345print(dog1.name) # 旺财# print(dog1.name1) # AttributeError: 'Dog' object has no attribute 'name1'print(getattr(dog1, 'name')) # 旺财print(getattr(dog1, 'name1', '菜菜')) # 菜菜 2.增\\改 a.对象.属性 = 值b.setattr(对象,属性名,值)注意:属性存在时,对应的功能是修改属性值.当属性不存在时,是添加属性. 123456789dog1.name = '大黄'print(dog1.name) # 大黄;改dog1.sex = '母'print(dog1.sex) # 母;增setattr(dog1, 'name', 'hotdog')print(dog1.name) # hotdog;改setattr(dog1, 'name2', 'roudog')print(dog1.name2) # roudog;增 3.删除 a.del 对象.属性b.delattr(对象, 属性名) 12del dog1.name# print(dog1.name) # AttributeError: 'Dog' object has no attribute 'name' 注意:对象属性的增删改查都是针对指定的那一个对象,不会影响其他对象 4.slot魔法1__slots__是用来约束当前这个类有哪些对象属性 12345678910111213class Student: # Student类的对象只能有name age id sex这几个只能少,不能多 __slots__ = ('name', 'age', 'id', 'sex') # 限制类的属性 def __init__(self, name, age): self.name = name self.id = '001' self.age = agestu1 = Student('小明', 18)# stu1.neme = '666' # 因为有slots魔法,所以不能添加stu1.sex = '666' # 可以添加,且不影响其他对象 #13.6 类的字段和内置类属性 1.类的字段a.声明在类中且在函数外的变量,叫做类的字段.b.类的字段需要通过类来使用:类.字段 - 不论是在类中还是类外,都需要。类的字段：不会因为对象不同而不一样的数据就声明为类的字段 123456789class Person: # 声明了一个字段number number = 61 def show_number(self): print('人类的数量:%d' % Person.number)print(Person.number) # 61 2.内置类属性内置属性就是声明类的时候,类中已经声明好的属性(包含类的字段和对象属性), 123456789101112131415161718192021222324252627class Dog: \"\"\"说明文档:傻狗\"\"\" # 类的字段 type = '犬科' # 声明对象属性 def __init__(self, name, color, age): self.name = name self.color = color self.age = age # 对象方法 def eat(self, food): print('%s在吃%s' % (self.name, food)) # 类方法 @classmethod def shout(cls): print('汪汪汪~') # 静态方法 @staticmethod def bite(): print('狗咬人!!')dog1 = Dog('小黑', 3, '黑色') a.__name__类.__name__ - 获取类的名字(字符串)1print(Person.__name__) # Person;获取类的名字 b.__class__对象.__class__ - 获取对象对应的类(结果是一个类,类能做的它都可以做)123456print(Person.__class__) # &lt;class 'type'&gt;print(dog1.__class__) # &lt;class '__main__.Dog'&gt;dog1 = Dog('小黑', 3, '黑色')dog2 = dog1.__class__('小黑', 3, '黑色') # 可以创建对象print(dog1.__class__.__name__) # 有一个类的对象,可以获取到类的名字 c.__dict__(了解)类.__dict__ - 获取当前类的所有字段及其对应的值(重点)对象.__dict__ - 将当前对象所有的对象属性及其值转换成字典,key是属性名,value是属性值.(数据本地化必须操作)12print(Dog.__dict__) # 获取类的所有字段和其地址组成的字典print(dog1.__dict__) # &#123;&apos;name&apos;: &apos;小黑&apos;, &apos;color&apos;: 3, &apos;age&apos;: &apos;黑色&apos;&#125; d.__bases__类.__bases__ - 获取当前类的父类(以元组形式返回,元组中的元素就是类的父类名)1print(Dog.__bases__) # (&lt;class &apos;object&apos;&gt;,)元组;python支持多继承,所以为元组 e.__module__类名.__module__ - 获取当前类所在模块的模块名1print(Dog.__module__) # __main__ f.__doc__类.__doc__ - 获取类的说明文档1print(Dog.__doc__) # 说明文档:傻狗","categories":[],"tags":[]},{"title":"","slug":"day12-json和异常捕获","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day12-json和异常捕获/","link":"","permalink":"http://yoursite.com/2018/12/21/day12-json和异常捕获/","excerpt":"","text":"#12.1 json数据 1.什么是json数据json是一种数据格式，满足json格式的数据就是json数据。文件后缀是‘.json’，且文件中内容满足json格式。 2.json格式一个json中只有一个数据；并且这个数据是json支持的数据类型的数据 json支持的数据类型数字类型 - 包含所有的数字，包括整数和小数，如：100，20，12.5，-20字符串 - 使用双引号括起来的字符集，例如：“abc123”，“123”布尔 - true和false数组 - 相当于python中的列表，使用[]括起来，括号里面是json支持的任意类型的数据。例如：[“ab”, 12, [1, 2]]字典 - 相当于python中的字典，使用{}括起来，里面是键值对，键一般是字符串，值可以是json支持的任意类型的数据。null - 相当于python中的None，表示空。 3.python中有个内置模块叫json，用来支持对json数据的处理：jsona.将json数据转成python数据b.将python数据转换成json数据1import json 1.将json数据转换成python数据json.loads(字符串) - 将json格式数据转换成python格式数据。注意：这儿的字符串内容必须是json格式数据。内容！！如：’”abc”‘ json python 数字 整型/浮点型 字符串 字符串（双引号会变单引号） 布尔 布尔（ture&gt;Ture;false&gt;False） 数字 列表 字典 字典 null None 123456789101112131415161718192021222324252627282930313233343536373839#json.loads(&apos;abc&apos;) # JSONDecodeError# a.数字转int/floatpy1 = json.loads(&apos;100&apos;) # 100，intprint(py1, type(py1))# b.字符串py2 = json.loads(&apos;&quot;abc&quot;&apos;)print(py2, type(py2)) # abc &lt;class &apos;str&apos;&gt;# c.布尔# d.数组py4 = json.loads(&apos;[1,2,3,4,&quot;a&quot;,null]&apos;) # [1, 2, 3, 4, &apos;a&apos;, None]print(py4)# e.字典py5 = json.loads(&apos;&#123;&quot;a&quot;:[1,2],&quot;b&quot;:[23,32]&#125;&apos;)print(py5) # &#123;&apos;a&apos;: [1, 2], &apos;b&apos;: [23, 32]&#125;# 例：# with open(&apos;data.json&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as js:# j = js.read()# print(j)# py6 = json.loads(&apos;j&apos;)js0 = &apos;&#123;&quot;data&quot;:[&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18&#125;,\\&#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 20&#125;,&#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 19&#125;],\\&quot;code&quot;: 200,&quot;messages&quot;: null&#125; &apos;py7 = json.loads(js0)print(py7)print(py7[&apos;data&apos;][2][&apos;age&apos;])with open(&apos;data.json&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as js: j = js.read()py8 = json.loads(j)print(py8)print(py8[&apos;data&apos;][2][&apos;age&apos;]) # 19 2.将python数据转换成json数据注意：最终结果是字符串！！！json.dumps(python数据) - 将指定的pyhon数据转换成内容符合json格式的字符串。 python json int/float 数字 字符串 字符串（单引号会变双引号） 布尔 布尔（ture&lt;Ture;false&lt;False） 列表/元组 数组 字典 字典 1234567891011121314151617181920212223242526272829303132333435363738394041# a.int/floatpy1_str = json.dumps(100)print(py1_str, type(py1_str)) # &apos;100&apos; &lt;class &apos;str&apos;&gt;# b.字符串js2 = json.dumps(&apos;hello hahaha&apos;)print(js2) # &apos;&quot;hello hahaha&quot;&apos;# c.布尔js3 = json.dumps(True)print(js3) # &apos;true&apos;# d.列表/元组js4 = json.dumps([&apos;a&apos;, &apos;b&apos;, 4])js5 = json.dumps((&apos;a&apos;, &apos;b&apos;, 4))print(js4) # &apos;[&quot;a&quot;, &quot;b&quot;, 4]&apos;print(js5) # &apos;[&quot;a&quot;, &quot;b&quot;, 4]&apos;# e.字典js6 = json.dumps(&#123;&apos;a&apos;: None, &apos;b&apos;: 123, 12: &apos;abc&apos;&#125;)print(js6) # &apos;&#123;&quot;a&quot;: null, &quot;b&quot;: 123, &quot;12&quot;: &quot;abc&quot;&#125;&apos;# 练习2：以字典保存学生信息（姓名，年龄，电话）,且上次添加的信息不会删除下次再添# 加的时候，是在上次基础上添加的，保存到json文件中# with open(&apos;lian_xi2.json&apos;, encoding=&apos;utf-8&apos;) as l_x:# # 读出文件# content = l_x.read()# # 转成列表# list1 = json.loads(content)# for index in range(5):# dict1 = &#123;&apos;姓名&apos;: input(&apos;请输入姓名：&apos;), &apos;年龄&apos;: input(&apos;请输入年龄：&apos;),# &apos;电话&apos;: input(&apos;请输入电话：&apos;)&#125;# list1.append(dict1)# # list1[index] = dict1# print(&apos;写入成功！请选择是否继续：\\n1.继续\\n2.退出&apos;)# n = input()# if n == &apos;1&apos;:# continue# else:# with open(&apos;lian_xi2.json&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as l_x:# content = json.dumps(list1)# l_x.write(content)# break 3.json文件操作相关方法 load(文件对象) - 将文件对象中的数据读出来，并且转换成python对应的数据（文件对象中的内容必须是json格式的数据，可以是列表，文本文件等） dump(数据，文件对象) - 将python数据转换成json格式的字符串再写入文件对象中。12345678# load(文件对象)with open('lian_xi2.json', encoding='utf-8') as l: content = json.load(l) print(content)# dump(数据，文件对象)with open('lian_xi2.json', 'w', encoding='utf-8') as f: json.dump([1, 2, 4], f) 1234567891011121314# 作业：封装自己的load方法，要求传入文件地址，就将文件对应的数据读出并转换成python数据。import jsondef my_load(files): with open(files, 'r', encoding='utf-8') as m: content = json.load(m) return contentpy0 = my_load('mu_biao.json')print(py0)# for key in py0['response']['data'][0]:# print(py0['response']['data'][0][key]) #12.2 json和异常捕获 1.什么是异常程序执行过程中出现错误，也叫异常。 2.异常捕获让本来会出现异常的位置，不出现异常，而是自己去处理异常出现的情况。 3.怎么捕获异常 结构一：捕获所有的异常 12345a.语法：try： 代码段1（需要捕获异常的代码段）except： 代码段2 b.执行过程：执行代码段1，如果代码段1中出现异常，不会崩溃，而是马上执行代码段2.如果代码段1无异常，不会执行代码段2。12345678try: print('出现异常前') print([1, 2, 3][3]) print('出现异常后') # 出现异常马上执行代码段2，所以此句不会执行except: print('出现异常！')print('=====') 情况二：捕获指定的异常12345a.语法：try: 代码段1except 错误类型名： 代码段2 b.执行过程：执行代码段1，当代码段1出现指定类型的异常后不崩溃，而是执行代码段2。1234567891011121314151617# try:# print(int('出现ValueError异常'))# print([1, 2, 3][3])# print('出现IdexError异常')# except IndexError:# print('出现异常！')## print('=====') # 直接崩溃，因为不捕获ValueError异常try: print(int('出现ValueError异常')) print([1, 2, 3][3]) print('出现IdexError异常') # 不会执行except ValueError: print('出现异常！')print('=====') 情况三：同时捕获多个异常，对不同的异常做出相同的反应。1234try： 代码段1except （错误类型1，错误类型2，错误类型3。。。）： 代码段2 执行过程：执行代码段1，当代码段1中出现了指定的异常，不崩溃，然后执行代码段2。12345try: # print([1, 2, 3][3]) print(&#123;1: 2&#125;[3])except (IndexError, KeyError, ValueError, FileExistsError, StopIteration): print('出现多个异常中的一种。') 情况四：同时捕获多个异常，对不同的异常做出不同的反应。12345678try： 代码段1except 错误类型1： 代码段2except 错误类型2： 代码段3except 错误类型3： 代码段4 执行过程：执行代码段1，当代码段1中出现了指定的异常，不崩溃，然后执行代码段2。1234567try: # print([1, 2, 3][3]) print(&#123;1: 2&#125;[3])except IndexError: print('IndexError')except KeyError: print('KeyError') 4.try-except-finally123456try: 代码段1except： 代码段2finally： 代码段3 不管代码段1是否出现异常，也不管异常是否能捕获到，程序崩溃前，finally后的代码段3都会执行。常在代码段3中做数据备份，防止游戏突然崩溃！！12345678# 输入学生成绩直到输入正确为止while 1: try: score = float(input('输入成绩：')) break except ValueError: print('输入有误！请输入数字：') 什么时候使用异常捕获：明明知道某段代码可能出现异常，但是又没办法避免，就使用异常捕获。1234567891011121314151617# 封装一个函数，功能是获取指定文件中的内容# 从封装角度：越简单越方便越好。def my_read(files): try: with open(files, encoding='utf-8') as f: content = f.read() return content except FileNotFoundError: print('输入文件地址错误，请核对地址！')while 1: files = input('请输入要打开的文件地址：') str1 = my_read(files) print('文件内容为：', str1) #12.3 抛出异常抛出异常：主动让程序出现异常 语法：raise 错误类型 - 程序执行到raise语句时，程序直接抛出异常 注意：错误类型必须是一个类，并且这个类是Exception的子类12345# 输入年龄，如果输入年龄范围不在0-100，程序崩溃while 1: age = int(input('请输入年龄：')) if age &lt; 0 or age &gt; 100: raise ValueError","categories":[],"tags":[]},{"title":"","slug":"day8-函数基础知识总结","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day8-函数基础知识总结/","link":"","permalink":"http://yoursite.com/2018/12/21/day8-函数基础知识总结/","excerpt":"","text":"#8.1 字典相关方法 1.clear字典.clear() - 清空字典（删除字典中所有的键值对）123dict1 = &#123;'a': 100, 'b': 200 &#125;dict1.clear()print(dict1) # &#123;&#125; 2.copy字典.copy() - 复制字典中所有的键值对产生一个新的字典(浅拷贝)1234567dict1 = &#123;'a': 100, 'b': 200 &#125;dict2 = dict1print(dict2) # &#123;'a': 100, 'b': 200 &#125;dict1 = &#123;'a': 100, 'b': 200 &#125;dict2 = dict1.copy() # 这会产生新的地址，改变1不会影响2print(dict2) 3.fromkeys通过字典类型来调用，是类方法，静态方法dict.fromkeys(序列，值) - 以序列中元素作为key，值作为所有key对应的默认值，创建一个字典。12dict3 = dict.fromkeys('abc', 100)print(dict3) # &#123;'a': 100, 'b': 100, 'c': 100&#125; 4.get字典.get（key） - 获取key对应的值，如果key不存在，返回None。字典.get（key， 值1） - 获取key对应的值，如果key不存在，返回值1。值1可以是任意类型。12print(dict3.get('d')) # Noneprint(dict3.get('d', 0)) # 0 5.keys,values,items字典.keys() - 获取字典所有的key（返回一个序列，序列中元素就是字典的key）字典.values() - 获取字典所有的值（返回一个序列，序列中元素就是字典的value）字典.items() - 获取字典所有的键值对（返回一个序列，序列中元素是元组，元组中元素有两个，分别为key和value）12345678dict1 = &#123;'a': 100, 'b': 200, 'c':120&#125;keys = dict1.keys()print(keys, type(keys)) # dict_keys(['a', 'b', 'c']) &lt;class 'dict_keys'&gt;#只是一个单纯的序列，可遍历(for i in keys:)，但若要单独取则需要先转换成列表或元组等。for i in keys: print(i) # a b cprint(dict1.items()) # dict_items([('a', 100), ('b', 200), ('c', 120)])生成式 6.setdefault(key, value)字典.setdefault(key, value) - 给字典添加键值对，如果字典中已存在key则不会修改相应的值。12345dict1 = &#123;'a': 100, 'b': 200, 'c':120&#125;dict1.setdefault('a', 300)print(dict1) # &#123;'a': 100, 'b': 200, 'c': 120&#125;dict1.setdefault('d', 300)print(dict1) # &#123;'a': 100, 'b': 200, 'c': 120, 'd': 300&#125; #8.2 集合基本操作 1.什么是集合（set）集合是python内置的一个容器类数据类型，是可变、无序的字面量 - 使用{}括起来，里面有多个元素，多个元素之间用逗号隔开{1， 2， 3}元素 - 不是键值对；必须是不可变的，而且是唯一的。可用于列表去重！！123456789set1 = &#123;1, 'hello', (1, 2, 3)&#125;#set2 = &#123;1, 'hello', [1, 2, 3]&#125; # TypeError: unhashable type: 'list'set3 = &#123;1, 'hello', (1, 2, 3), True, 1&#125;print(set3) # &#123;'hello', 1, (1, 2, 3)&#125;set4 = &#123;&#125;print(type(set4)) # &lt;class 'dict'&gt;set4 = set() # 创建一个空的集合print(type(set4)) # &lt;class 'set'&gt; 2.集合的增删改查 a.查（获取集合元素）不能直接获取集合中单独的某个元素，只能遍历。12for item in set3: print(item) #1 hello (1, 2, 3) b.增（添加元素）集合.add（元素） - 将指定的元素添加到集合中集合.update（序列） - 将序列中的每个元素添加到集合中12set3.add(333)set3.update([222, 3333, 2323]) c.删（集合中只有remove）集合.remove（元素） - 删除集合中指定的元素1set3.remove(333) d.集合不能修改元素的值，无序的拿不到，只能增加set(序列) - 将序列转换成集合 #8.3 数学集合运算python中的集合支持数学相关的集合运算 包含关系集合1 &gt;= 集合2 判断集合1中是否包含集合2（判断集合2是否是1的子集）集合1 &lt;= 集合2 判断集合2中是否包含集合1（判断集合1是否是2的子集）12print(&#123;1, 2, 3&#125; &gt;= &#123;1, 2&#125;) # Trueprint(&#123;1, 2, 3&#125; &gt;= &#123;1, 10&#125;) # False 求并集集合1 | 集合2 - 将两个集合中的元素合并在一起产生一个新的集合123set1 = &#123;1, 2, 3, 4, 5, 6&#125;set2 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;print(set1 | set2) # &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 求交集集合1 &amp; 集合2 - 使用两集合的公共元素创建一个新的集合1print(set1 &amp; set2) # &#123;1, 2, 3, 4, 5, 6&#125; 求差集集合1 - 集合2 – 使用集合1中除了（1和2共有的部分）集合2的部分以外的元素，创建一个新的集合 1print(set2 - set1) # &#123;8, 9, 7&#125; 求补集补集 = 并集 - 交集集合1 ^ 集合2 - 将俩个集合中除了公共部分以外的元素，创建为一个新的集合1print(set1 ^ set2) # &#123;8, 9, 7&#125;集合无序 #8.4 认识函数 函数的定义定义：函数就是对实现某一特定代码段的封装。分类：函数可以分为python内置函数和自定义函数内置函数：python已经声明好了，程序员直接调用的函数。print函数，input函数等。max和min函数等。相当于已经造好的机器，程序员只需要知道使用方法。自定义函数：程序员自己声明，自己实现功能的函数。可以提供给别人用，也可以自己用。相当于自己设置和创建机器。 函数的声明语法：def 函数名（形参列表）： “””‘函数说明文档’””” 函数体说明：def - python中声明函数的关键字函数名 - 自己命名；要求：标识符，不能是关键字。PEP8规范（名字中的字母小写，多个单词之间用下划线隔开），见名知意（ 看到函数名，大概知道函数的功能） （） - 固定写法形参列表 - 一个或多个参数也可以没有参数。作用：从函数外部向函数内部传递数据 ： - 固定写法函数说明文档 - 用来对函数功能进行说明的注释。需要用3个”引起来。函数体 - 实现函数功能的代码段 初学者函数声明步骤：1.确定函数功能2.根据函数功能，确定函数名3.确定参数，看实现函数功能需不需要向内部传递额外的数据。需要几个数据就需要几个参数。4.实现函数功能5.确定返回值前后两行。123456789101112131415161718192021222324252627282930# 声明一个函数求两数和,并打印def add(num1, num2): \"\"\"求两个数的和\"\"\" return num1 + num2print(add(4, 5))# 声明一个函数,打印10个‘*’def print_star(): print('*' * 10)print_star()# 声明一个函数,求1+2+3+。。。+ndef sum1(num1): sum2 = 0 for i in range(1, num1 + 1): sum2 += i return sum2print(sum1(10)) 函数的调用（重点）函数在声明时不会执行函数体，只有在调用时才会执行语法：函数名（实参列表）说明：函数名 - 必须是已经声明好的函数（） - 固定写法实参列表 - 给形参赋值（需要传递给函数内部的数据）目前，形参有多少个，实参就需多少个。","categories":[],"tags":[]},{"title":"","slug":"day9-作业","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day9-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day9-作业/","excerpt":"","text":"0.写一个匿名函数，判断指定的年是否是闰年程序：123456# 0.写一个匿名函数，判断指定的年是否是闰年leap_year = lambda years: '是闰年' if (years % 4 == 0 and years % 100 != 0) \\ or years % 400 == 0 else '不是闰年'print(leap_year(2000))print(leap_year(2018)) 结果： 1.写一个函数将一个指定的列表中的元素逆序( 如[1, 2, 3] -&gt; [3, 2, 1])(注意:不要使列表自带的逆序函数)程序：12345678910111213def reverse_list1(l:list): \"\"\"输出列表l的逆序\"\"\" for index in range(len(l)//2): l[index], l[len(l) - index - 1] = l[len(l) - index - 1], l[index] return llist1 = [1, 2, 3] reverse_list1(list1)print(list1)list2 = [1, 2, 3, 4, 'y']reverse_list1(list2)print(list2) 结果： 2.写一个函数，提取出字符串中所有奇数位上的字符程序：1234567891011# 2.写一个函数，提取出字符串中所有奇数位上的字符def extract(str1: str): \"\"\"返回字符串str1所有奇数位上的字符\"\"\" str2 = str1[1::2] return str2str1 = '012346789'print(extract(str1))str2 = 'abcdefghi'print(extract(str2)) 结果： 3.写一个函数，统计指定列表中指定元素的个数(不用列表自带的count方法)程序：12345678910111213# 3.写一个函数，统计指定列表中指定元素的个数(不用列表自带的count方法)def my_count(l: list, item1): \"\"\"返回列表l中值为item1元素的个数\"\"\" count = 0 for item in l: if item1 == item: count += 1 return countlist1 = ['a', 'b', 1, 1, 1, 'c', 'j', 'c', 'j', 'c']print('list1中c字符的个数为：', my_count(list1, 'c'))print('list1中1的个数为：', my_count(list1, 1)) 结果： 4.写一个函数，获取指定列表中指定元素的下标(如果指定元素有多个，将每个元素的下标都返回)例如: 列表是：[1, 3, 4, 1] ,元素是1, 返回:0,3程序：1234567891011121314151617181920# 4.写一个函数，获取指定列表中指定元素的下标(如果指定元素有多个，将每个元素的下标都返回)# 例如: 列表是：[1, 3, 4, 1] ,元素是1, 返回:0,3def get_index(l: list, item): \"\"\"获取列表l中元素值为item的元素下标\"\"\" index_l = [] for index in range(len(l)): if item == l[index]: index_l.append(index) str1 = '' for item1 in index_l: str1 += str(item1) return ','.join(str1)list1 = ['a', 'b', 1, 'a', 1, 'c', 'j', 'c', 'j', 'c']print('list1中值为字符b的元素下标有：', get_index(list1, 'b'))print('list1中值为1的元素下标有：', get_index(list1, 1))print('list1中值为a的元素下标有：', get_index(list1, 'a')) 结果： 5.写一个函数，能够将一个字典中的键值对添加到另外一个字典中(不使用字典自带的update方法)程序：12345678910111213141516# 写一个函数，能够将一个字典中的键值对添加到另外一个字典中(不使用字典自带的update方法)def my_update(dict1: dict, dict2: dict): \"\"\"将字典dict2中的键值对添加到字典dict1中，如果dict1中已有dict2中的key， 则更新其对应的值。完成后打印出更新后的字典dict1\"\"\" for key2 in dict2: for key1 in dict1: if key1 == key2: dict1[key1] = dict2[key2] dict1[key2] = dict2[key2] print(dict1)dict1 = &#123;'a': 1, 'b': 2, 'c': 3&#125;dict2 = &#123;'c': 'j', 'd': 4, 'e': 5&#125;my_update(dict1, dict2) 结果： 6.写一个函数，能够将指定字符串中的所有的小写字母转换成大写字母；所有的大写字母转换成小写字母(不能使用字符串相关方法)程序：123456789101112131415161718192021# 6.写一个函数，能够将指定字符串中的所有的小写字母转换成大写字母；所有的大写字母# 转换成小写字母(不能使用字符串相关方法)def my_swapcase(str1: str): \"\"\"将字符串str1中的所有的小写字母转换成大写字母； 所有的大写字母转换成小写字母\"\"\" str2 = '' for item in str1: if 'a' &lt;= item &lt;= 'z': str2 += chr(ord(item)-32) elif 'A' &lt;= item &lt;= 'Z': str2 += chr(ord(item) + 32) else: str2 += item print(str2)str1 = 'aha2312sduhdsASKDkddlad'my_swapcase(str1) 结果： 7.写一个函数，能够将指定字符串中的指定子串替换成指定的其他子串(不能使用字符串的replace方法)例如: func1(‘abcdaxyz’, ‘a’, ‘\\’) - 返回: ‘\\bcd\\xyz’程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445# 7.写一个函数，能够将指定字符串中的指定子串替换成指定的其他子串(不能使用字符串# 的replace方法)例如: func1('abcdaxyz', 'a', '\\') - 返回: '\\bcd\\xyz'# 1def my_replace(str1: str, item1, item2): \"\"\"将str1中值为item1的字符换为item2输出\"\"\" if len(item1) == 1: str2 = '' for item in str1: if item1 == item: str2 += item2 else: str2 += item else: str2 = '' d = len(item1) index = 0 while index &lt; len(str1): if item1 == str1[index:index+d]: str2 += item2 index += d else: str2 += str1[index] index += 1 print(str2)str1 = 'aha2312sahadduhdsahaASKDkddlahad'my_replace(str1, 'ah', '\\\\')my_replace(str1, 'aha', '\\\\')my_replace(str1, 'a', '\\\\')# 2def my_replace(str1: str, item1, item2): \"\"\"将str1中值为item1的字符换为item2输出\"\"\" str_list = str1.split(item1) strstr = str_list[0] for index in range(1,len(str_list)): strstr += item2 + str_list[index] return strstrstr1 = 'aha2312sduhdsASKDkddlad'print(my_replace(str1, 'a', '\\\\')) 结果： 8.实现一个输入自己的items方法，可以将自定的字典转换成列表。列表中的元素是小的列表，里面是key和value (不能使用字典的items方法)例如:{‘a’:1, ‘b’:2} 转换成 [[‘a’, 1], [‘b’, 2]程序： # 8.实现一个输入自己的items方法，可以将自定的字典转换成列表。列表中的元素是小的 # 列表，里面是key和value (不能使用字典的items方法) # 例如:{'a':1, 'b':2} 转换成 [['a', 1], ['b', 2] def my_items(dict1: dict): \"\"\"将字典dict1转成列表。列表中的元素是小的 列表，里面是key和value，并打印出改列表\"\"\" list1 = [] i = 0 for key in dict1: list2 = [] list2.append(key) list2.append(dict1[key]) list1.append(list2) list1[i] = list2 i += 1 print(list1) my_items({'a': 1, 'b': 2}) my_items({'a': 1, 'b': 2, 'c': 3}) 结果：","categories":[],"tags":[]},{"title":"","slug":"day8-作业","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day8-作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day8-作业/","excerpt":"","text":"编写⼀个函数，求1+2+3+…+N程序：1234567891011# 1. 编写⼀个函数，求1+2+3+...+Ndef sum1(N):\"\"\"求1+2+3+...+N\"\"\" sum2 = 0 for i in range(1, N + 1): sum2 += i print(sum2)sum1(10)sum1(11) 结果： 编写⼀个函数，求多个数中的最⼤值程序：12345678910111213141516#2. 编写⼀个函数，求多个数中的最⼤值def my_max(list1):\"\"\"求多个数中的最⼤值\"\"\" print('需要比较的数为：', list1) print('它们中最大值为：', max(list1))list1 = []while 1: float1 = input('请输入需要比较的数字，输入None表示输入完成：') if float1 != 'None': list1.append(float(float1)) else: breakmy_max(list1) 结果： 编写⼀个函数，实现摇⾊⼦的功能，打印n个⾊⼦的点数和程序：123456789101112131415#3. 编写⼀个函数，实现摇⾊⼦的功能，打印n个⾊⼦的点数和import randomdef roll_dice():\"\"\"生成随机数1-6，即摇⾊⼦\"\"\" return random.randint(1, 6)list1 = []n = int(input('请输入摇色子的次数：'))for _ in range(n): list1.append(roll_dice())print('所有的点数为：', list1)print('它们的和为：', sum(list1)) 结果： 编写⼀个函数，交换指定字典的key和value。例如:{‘a’:1, ‘b’:2, ‘c’:3} —&gt; {1:’a’, 2:’b’, 3:’c’}程序：123456789101112131415161718#4. 编写⼀个函数，交换指定字典的key和value。# 例如:&#123;'a':1, 'b':2, 'c':3&#125; ---&gt; &#123;1:'a', 2:'b', 3:'c'&#125;def exchange(dict1): \"\"\"交换dict1的key和value值,仅适用于value值不等的情况\"\"\" list_key = list(dict1.keys()) list_value = list(dict1.values()) list2 = [] for index in range(len(list_key)): list1 = [list_value[index], list_key[index]] list2.append(list1) print(dict(list2))dict1 = &#123;'a': 1, 'b': 2, 'c': 3&#125;exchange(dict1) 结果： 编写⼀个函数，三个数中的最⼤值程序：1234567891011#5. 编写⼀个函数，求三个数中的最⼤值def my_max(num1, num2, num3): \"\"\"取3数中最大值\"\"\" print(max(num1, num2, num3))my_max(77, 44, 66)my_max(45, 34, 23)my_max(12, 33, 22) 结果： 编写⼀个函数，提取指定字符串中的所有的字⺟，然后拼接在⼀起后打印出来例如： ‘12a&amp;bc12d–’ —&gt; 打印’abcd’程序：123456789101112131415161718192021222324252627282930313233343536#6. 编写⼀个函数，提取指定字符串中的所有的字⺟，然后拼接在⼀起后打印出来#'12a&amp;bc12d--' ---&gt; 打印'abcd'#1def extract_the_letters(str1): \"\"\"提取字符串str1中的字母并打印\"\"\" list1 = list(str1) list2 = [] for index in range(len(list1)): if list1[index].isalpha(): # 判断是否为字母 list2.append(list1[index]) str2 = '' for index in range(len(list2)): str2 += list2[index] print(str2)str1 = '12a&amp;bc12d--'extract_the_letters(str1)#2def extract_the_letters(str1): \"\"\"提取字符串str1中的字母并打印\"\"\" str2 = '' for char1 in str1: if char1.isalpha(): # 判断是否为字母 str2 += char1 print(str2)str1 = '12a&amp;bc12d--'extract_the_letters(str1) 结果： 写⼀个函数，求多个数的平均值程序：1234567891011121314#7. 写⼀个函数，求多个数的平均值def average(list1): print('它们的平均值为:%.3f' %(sum(list1)/len(list1)))list1 = []while 1: float1 = input('请输入需要求平均值的数字，输入None表示输入完成：') if float1 != 'None': list1.append(float(float1)) else: breakaverage(list1) 结果： 写⼀个函数，默认求10的阶层，也可以求其他数的阶乘程序：123456789101112131415161718# 8. 写⼀个函数，默认求10的阶层，也可以求其他数的阶乘# 8. 写⼀个函数，默认求10的阶层，也可以求其他数的阶乘def factorial(num1=10): # 设置默认参数 \"\"\"求num1的阶乘，默认为10\"\"\" factorial1 = 1 i = 1 while i &lt;= num1: factorial1 *= i i += 1 print('%d的阶乘为：%d' % (num1, factorial1))factorial()factorial(11)factorial(12) 结果： 写⼀个函数，可以对多个数进⾏不同的运算例如: operation(‘+’, 1, 2, 3) —&gt; 求 1+2+3的结果operation(‘-‘, 10, 9) —&gt; 求 10-9的结果operation(‘‘, 2, 4, 8, 10) —&gt; 求 24810的结果程序：1234567891011121314151617181920212223242526272829303132333435363738#9. 写⼀个函数，可以对多个数进⾏不同的运算# 例如: operation('+', 1, 2, 3) ---&gt; 求 1+2+3的结果# operation('-', 10, 9) ---&gt; 求 10-9的结果# operation('*', 2, 4, 8, 10) ---&gt; 求 2*4*8*10的结果def operation(*tuple1): # 传入多个参数 \"\"\"根据输入的参数进行相应的运算\"\"\" operation1, *nums = tuple1 if operation1 == '+': sum1 = 0 for item in nums: sum1 += item print(sum1) elif operation1 == '-': sub1 = 2*nums[0] for item in nums: sub1 -= item print(sub1) elif operation1 == '*': mul1 = 1 for item in nums: mul1 *= item print(mul1) elif operation1 == '/': div1 = nums[0]**2 for item in nums: div1 /= item print(div1) else: print('运算符输入错误！')operation('+', 1, 2, 3)operation('+', 1, 2, 3, 4)operation('-', 10, 9, -2)operation('*', 2, 4, 8, 10)operation('/', 8, 4, 2, 1, 0.1) 结果：","categories":[],"tags":[]},{"title":"","slug":"day11-文件操作","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day11-文件操作/","link":"","permalink":"http://yoursite.com/2018/12/21/day11-文件操作/","excerpt":"","text":"#11.1 生成式迭代器：是一个容器，类型为iter；可以同时存取多个数据，取的时候只能一个一个取，并且取过的数据在容器中就不存在了。 生成器：就是迭代器，数据是通过调用函数获取yield后面的值产生的。数据只会在获取的时候产生。调用一个带yield关键字的函数，就是创建一个生成器。调用时不会执行，只有当获取生成器中数据时才会执行函数。 1.什么是生成式 格式1： 结果是一个生成器（迭代器）（值1（表达式） for 变量 in 序列）展开： 123def func(): for 变量 in 序列： yield 值1（表达式） 注意：表达式结果就是每次循环生成器产生的数据 这儿的for循环可以控制生成器产生的个数和值1234#1.格式1gen1 = (10 for x in range(10)) # 一个生成器，装有10个元素，每个元素都是10gen2 = (10*x for x in range(10)) # 一个生成器，装有10个元素，0，10，20.。。 格式2：(表达式 for 变量 in 序列 if 条件语句)展开：1234def func(): for 变量 in 序列： if 条件语句： yeild 表达式 1234567891011#2.格式2gen3 = (x for x in range(10) if x % 2) # 元素为1，3，5，7，9re = list(x for x in range(10) if x % 2 == 0) # 列表，元素为0，2，4，6，8# 交换字典的键值对：dict1 = &#123;'a': 1, 'b':2&#125;dict1 = &#123;'a': 1, 'b':2&#125;dict2 = dict((dict1[key], key) for key in dict1)dict3 = dict((value, key) for key, value in dict1.items())print(dict2) # 交换后&#123;1: 'a', 2: 'b'&#125; #11.2 模块使用 1.什么是模块python中一个py文件就是一个模块 2.怎麽关联多个模块 方法1：import 模块名 - 将指定的模块导入到当前模块中（模块名就是py文件的文件名） 说明：a.执行import的时候，实质会进入到指定的模块对应的py文件中，去执行里面的代码b.import导入模块时会检查当前模块是否已经导入过，如果已经导入过则不会再导入（执行）c.通过import去导入一个模块后，可以通过 模块名.全局变量 去使用被导入的模块中的内容12345import test1 # text1 我是模块1;当导入时会执行test1，要加__name__=来判断a = test1.test1_aprint(a) # 100；调用test1中的全局变量test1.test1_func1() # 我是模块1;调用test1中的全局函数 方法2：from 模块名 import 变量名/函数名 - 导入指定变量和函数 说明：a.执行到导入模块语句时，还是会执行指定模块中的所有语句b.通过from-import导入时，还是会查重c.使用时只能使用import后面的变量或函数，用时不用在前面加模块名d.import后面可以使用逗号将多个变量/函数隔开。也可以使用*将模块中所有的全局变量一起导入。123456789# from test2 import * # 将模块2中所有的全局变量一起导入。from test2 import test2_a, test2_func1 # test2 # 我是模块2a = test2_aprint(a) # 100test2_func1() # 我是模块2from random import randintrandint(10, 30) 函数 - 对功能进行封装 - 获取当前时间对应的代码封装到函数中模块 - 对多个功能和多个数据进行封装；对函数和变量封装 - 将所有和时间相关的函数或变量放到一个py文件中 例：math模块装得都是和数学相关的函数和变量包 - 对多个模块进行封装 - 将所有和时间相关的py文件放到一个文件夹中什么是包：含有__init__.py文件的文件夹 3.重命名 import 模块名 as 新的模块名from 模块名 import 变量名 as 新的变量名 123456import test1 as test1_1from test import test1a = test1_1.test1_a # 100b = test1.test1_a # 2000print(a, b) 4.包的导入 import 包名 - 会直接执行包中的__init__.py文件中的代码import 包名.模块名 - 导入指定包中指定的模块，使用方式：包名.模块名.变量名from 包名 import 模块名 - 使用方式：模块名.变量名from 包名.模块名 import 变量名 - 使用方式：变量名 #11.3 选择性导入 在模块中将不需要其他模块导入和执行的代码写到if __name__ == ‘__main__’:语句中，就可防止被直接使用。 12345if __name__ == &apos;__main__&apos;: # 不想导入或执行的代码或变量 # 声明在这的变量也不会被其它模块使用 a = 100 print(&apos;&apos;) 原理： 每个py文件（模块）都有一个属性__name__,默认值为模块名；只有当直接使用模块文件时__name__值才为__main__。可以用print（__name__）来证明。 #11.4 文件操作 1.数据本地化 将数据以文件形式，存储到本地磁盘中。（程序中变量保存的数据都是存在内存中的，当程序运行结束之后内存中的数据会销毁。） 常见的数据本地化方式：二进制文件（包含音频、视频、压缩包等），普通文本文件，json和xml文件，数据库文件等。 2.文件操作（读、写）文件操作的固定步骤：打开文件（新建文件） - 文件操作（读、写） - 关闭文件 3.打开文件open(file, mode=’r’,… ,encoding=None) - 返回的是被打开的文件对象（文件句柄）文件对象（文件句柄）需要调用相关方法才能操作文件 说明：file - 字符串；需要打开的文件的路径（可以是绝对路径，也可以是相对路径） 绝对路径：完整的路径（一般不使用）。 例：open(‘F:\\桌面\\汇总\\cj.txt’) 缺点是不能跟着项目走 相对路径：（相对当前py文件对应的目录） aaa.txt 或者 ./aaa.txt 注：如果文件不带扩展名则不用加扩展名 ./ – 当前目录（可以省略） ../ – 当前目录的上层目录（不可省） …/ –当前目录的上上层目录（不可省） mode - 打开方式；打开文件后不同的操作，对应的打开方式不一样 ‘r’ - 默认值，以读的方式打开文件，只读，读出来的是字符串 ‘w’- 以写的方式打开文件 ‘rb、br’-以读的方式打开，读出来的是2进制，可用于读音频、视频文件等。 ‘wb、bw’-以写的方式打开，写的是2进制，写进2进制文件中。 ‘a’ - 以写的方式打开，追加 ‘+’ - 以读写方式打开 encoding - 文本文件编码方式，一般赋值为‘utf-8’ utf-8 - 能对中文编码，显示 gbk - 不支持中文编码，能存，不能显示1234567891011121314# re = open('F:\\桌面\\汇总\\cj.txt') # 局限性在于不能跟着项目走# print(re.read()) # 读取全部# re.close() # 打开后需要关闭，重置下标位置# print('='*88)# re = open('F:\\桌面\\汇总\\cj.txt') # 关闭后需要再次打开# print(re.read()) # 读取全部# re.close()re1 = open('aaa')re3 = open('aaa.txt') # open('./aaa.txt')省略# 以读的形式打开一个文本文件，保存到变量re2中。对re2进行操作# ，就是对被打开的文件进行操作。# re2 = open('files/cj', 'r', encoding='utf-8') # open('./files/cj')省略 4.文件的读操作 文件句柄（文件对象）.read() - 从文件读写位置开始获取到文件结尾（默认就是获取文件中所有的内容） 文件句柄（文件对象）.readline() - 读一行内容**123456789101112131415161718192021222324252627# content = re2.read()# print(content)# content = re2.readline() # 第一行# print(content)# content = re2.readline() # 第二行# print(content)# 将文件中内容读完，要求一行一行的读# 法1def content(): while 1: yield re2.readline()re2 = open('files/cj', 'r', encoding='utf-8')print(content().__next__()) # 第一行print(content().__next__()) # 第二行print(next(content())) # 第三行# 法2content = (re2.readline() for _ in range(10)) # 只能for循环print(content.__next__()) # 第四行print(content.__next__()) # 第五行print(next(content)) # 第六行 5.文件写操作 文件对象.write(字符串) - 将字符串中的内容写入到文件中（会完全覆盖原文件内容） ‘w’ - 完全覆盖，常用‘a’ - 在原文件后添加 1234567f = open('aaa.txt', 'w', encoding='utf-8')f.write('第一次写！') # 第一次写！f.write('第二次写！') # 第一次写！第二次写！f.close()f = open('aaa.txt', 'w', encoding='utf-8')f.write('第三次写！') # 第三次写！ 6.关闭文件 文件句柄（文件对象）.close() - 关闭指定的文件 1f.close() #11.5 二进制文件读取 open方法的另外一种写法：12with open(文件路径，读写方式，encoding=编码方式) as 文件对象： 文件操作 功能：打开文件，将文件存在文件对象中。当文件操作完成会自动关闭，所以经常用此写法。123with open(&apos;files/cj&apos;, encoding=&apos;utf-8&apos;) as f: print(f.read())print(f.closed) # True,已关闭 普通的文本文件也可以以二进制形式读和写。 2.二进制文件的读 只要将读写方式设置为‘rb/br’就可以了。读出来的就是二进制数据。注意：二进制操作不能设置编码方式 1234567891011with open(&apos;files/cj&apos;, &apos;rb&apos;) as f: # 不能设置编码方式 content = f.read() print(content, type(content)) # bytes,二进制类with open(&apos;files/小狐狸.png&apos;, &apos;rb&apos;) as f: # 打开图片 content = f.read() print(content)with open(&apos;小狐狸new.jpg&apos;, &apos;wb&apos;) as f: # 在当前目录写入图片，要先获取到图片2进制数据 f.write(content) 123456# 图片下载import requests # 需下载response = requests.get(&apos;图片网络地址&apos;)with open(&apos;下载.jpg&apos;, &apos;wb&apos;) as f: f.write(response.content()) 3.文件不存在 当以读方式打开一个不存在的文件，会报错。当以写的方式打开一个不存在的文件，不会报错，会在当前目录下创建它。 #11.6 文件操作的运用12345678# 写一个程序统计当前程序执行的次数。第一次运行控制台打印1，第二次打印2.。with open('记数本.txt', 'r', encoding='utf-8') as f: count = int(f.read()) # 存的是字符串 print('第%d次进入程序。' % count)print('运行程序！')count += 1with open('记数本.txt', 'w', encoding='utf-8') as f: f.write(str(count)) # 写的是字符串 指导思想： 1.使用数据的时候去本地文件中取数据 2.数据修改后，将新的数据更新到本地文件中","categories":[],"tags":[]},{"title":"","slug":"day6-列表","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day6-列表/","link":"","permalink":"http://yoursite.com/2018/12/21/day6-列表/","excerpt":"","text":"#6.1 认识列表 ##6.1.1 列表（list）1.列表是python内置的可变并且有序的容器类数据类型（序列） 有序：说明可以通过下标获取元素 可变：指的是列表中元素的个数，元素的值以及元素的位置可变(列表支持增、删、改)。 2.列表字面量：中括号括起来，里面有多个元素，元素之间用逗号隔开[元素1，元素2，元素3。。。] 元素：可以是任何类型的数据；同一个列表，不同元素的类型可以不一样。123456789score = 90list1 = [10, 'a', 97, [1, 2, 3]]print(list1[3][1]) # 2# 空列表list2 = []# 用一个变量保存一个班的学生成绩score2 = [33, 44, 66, 88] #6.2 列表的增删改查 ##6.2.1 查（获取列表的元素） a.获取单个元素列表[下标] - 获取指定下标对应的元素列表一旦确定，列表中每个元素都对应一个下标；下标范围：0~列表长度-1；-1~-列表长度下标不能越界12films = [&apos;战狼2&apos;, &apos;喜羊羊与灰太狼&apos;, &apos;小猪佩奇&apos;]films[-1] # 小猪佩奇 b.获取多个元素（切片） - 结果是列表列表[开始下标:结束下标:步长]列表[开始下标:结束下标]1print(films[0:3:2]) #[&apos;战狼2&apos;, &apos;小猪佩奇&apos;] c.遍历列表（将列表中元素一个一个取出）for 变量 in 列表 —&gt; 用变量获取列表中的元素12345678# 方法1：直接获取列表元素l3 = ['小明', '123', '121231321']for j in l3: print(j)# 方法2：通过遍历下标获取列表元素（适用于需要下标的情况）for index in range(len(l3)): print(l3[index]) ##6.2.2 增（添加元素） a. 列表.append(元素1) - 在指定的列表末尾添加指定元素1123456789101112films.append(&apos;电锯惊魂&apos;) # 不会产生新的列表，不用接收# 练习，录入学生成绩，保存到一个列表中。（录入时不断输入，直到输入end为止）l1 = []while 1: score = input(&apos;请输入学生成绩：&apos;) if score == &apos;end&apos;: break else: l1.append(int(score))print(l1, sum(l1)) b. 列表.insert(下标,元素) - 在指定的下标前插入指定的元素123456789101112131415161718films = ['海贼王', '火影忍者', '进击的巨人', '一拳超人']films.insert(2, '将夜')print(films, films[2])# ['海贼王', '火影忍者', '将夜', '进击的巨人', '一拳超人'] 将夜# 练习：一个有序的数列[1,7,34,67,100]。输入任意一个数字插入到数列中，要求插入后#数列还是有序的。l2 = [1, 7, 34, 67, 100]#while 1:num1 = int(input('请输入一个数字:'))for i in range(5): if num1 &lt;= l2[i]: l2.insert(i, num1) breakelse: l2.append(num1) # 遍历完成都没有，则添加到最后print(l2) ##6.2.3（删）删除列表元素 a.del 列表[下标] - 删除列表中指定下标对应的元素del - 关键字，可以删除任何内容123films = [&apos;海贼王&apos;, &apos;火影忍者&apos;, &apos;进击的巨人&apos;, &apos;一拳超人&apos;]del films[-1]print(films) # [&apos;海贼王&apos;, &apos;火影忍者&apos;, &apos;进击的巨人&apos;] b. 列表.remove(元素) - 直接删除指定列表中指定的元素；如果指定的元素在列表中有多个，只删除最前那一个。12films.remove(&apos;火影忍者&apos;)print(films) # [&apos;海贼王’, &apos;进击的巨人&apos;] c.列表.pop() - 取出列表中最后一个元素。列表.pop(下标) - 弹出列表中指定下标对应的元素12345678910111213141516171819202122232425l4 = [2, 3, 4]n = l4.pop() # 将最后一个元素取出并用n去接收# 练习：有个列表，列表中有数字和字符串两种类型的元素。要求将这列表中的字符串全部#放到另一个列表中。[1,&apos;ab&apos;,303,&apos;hello&apos;,89,9,90]l5 = [1, &apos;ab&apos;, 303, &apos;hello&apos;, 89, 9, 90]l6 = []count = 0&quot;&quot;&quot;for i in range(len(l5)): #注意：列表是一直在变的,可用while解决 if isinstance(l5[i], int): l6.append(l5.pop(i)) count += 1print(l5, l6)&quot;&quot;&quot;i = 0while i &lt; (len(l5)): if isinstance(l5[i], int): l6.append(l5.pop(i)) #continue # 弹出后下标不加一，控制循环从现下标开始 i -= 1 i += 1print(l5, l6) ##6.2.4 改（修改列表元素的值） 列表[下标] = 新值 - 将列表中指定下标对应的元素修改成新值 123list1 = [1, 2, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]list1[2] = 3print(list1) # [1, 2, 3, &apos;b&apos;, &apos;c&apos;] #6.3 列表相关运算 ##6.3.1 + 列表1 + 列表2 ：将列表2中所有元素添加在列表1的末尾，形成一个新的列表。 ##6.3.2 * 列表*n(正整数) ： 将指定列表中的元素重复n次，产生一个新的列表。 ##6.3.3 in 和 not in 元素 in 列表 ：判断指定的元素，是否在指定的列表中元素 not in 列表 ：判断指定的元素，是否不在指定的列表中12print([1, 2] in [[1, 2], 3, 4]) # Trueprint([1, 2] in [1, 2, 3, 4]) # False ##6.3.4 len len（列表） ： 获取列表元素个数。 ##6.3.5 list list(数据) ： 将其他数据转换成列表注意：此处的数据只能是序列。（所有的序列都能转成列表–将序列中的每一个元素作为列表的每一个元素） ##6.3.6 max和min max(列表) ：获取列表中元素的最大值min(列表) ：获取列表中元素的最小值 注意,列表有要求： a.列表中元素的类型一样b.元素对应的类型支持比较运算符12print(max([&apos;1&apos;, &apos;a&apos;, &apos;A&apos;])) # aprint(min([&apos;1&apos;, &apos;a&apos;, &apos;A&apos;])) # 1","categories":[],"tags":[]},{"title":"","slug":"day9-函数2","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day9-函数2/","link":"","permalink":"http://yoursite.com/2018/12/21/day9-函数2/","excerpt":"","text":"#9.1 函数的调用函数在声明时不会执行函数体，只有在调用函数的时候才会执行函数体 函数的调用过程（重点！） a.物理过程1.回到函数声明位置2.用实参给形参赋值（传参），需要保证每个形参都有值。3.执行函数体4.获取返回值5.回到函数调用位置，接着往后执行 b.函数调用过程是一个压栈的过程当函数调用时，系统会自动地在内存中的栈区间开辟空间，存储函数调用过程中产生的数据（这里的数据包括参数和在函数中声明的变量）。当函数调用完成后，对应的内存空间会自动销毁。12345678def exchange(a1, b): # 同名会有灰色波浪线 a1, b = b, a1 print('函数中：', a1, b)a, b = 10, 20exchange(a, b) # 函数中： 20 10print('函数外：', a, b) # 函数外： 10 20 #9.2 函数的参数 1.根据实参分为位置参数和关键字参数 a.位置参数让实参位置和形参位置一一对应 12345def fun1(a, b, c): print('a:%d b:%d c:%d' % (a, b, c))fun1(10, 20, 66) # a:10 b:20 c:66 b.关键字参数实参以”形参名=值“的形式来传参1fun1(c=66, a=10, b=20) # a:10 b:20 c:66 c.位置参数和关键字参数混合使用前提：保证每个参数都有值且位置参数要放在关键字参数前。1fun1(10, c=66, b=20) # a:10 b:20 c:66 从函数声明角度又有：参数默认值，不定长参数，参数类型说明 a.参数默认值声明函数时，可以给参数设置默认值，语法：参数名 = 默认值设置默认值的参数需要放在未设置默认值参数的后面。注意：设置默认值可给参数赋一个默认值，也常用于说明需要传入参数的类型 12345678# 声明函数，并给参数c赋默认值1# 有的参数有默认值，有的参数没有；有默认值的参数一定要放在后面。def fun2(a, b, c=1): print(a, b, c)# 如果函数声明时参数有默认值，调用函数时，有默认值的参数可不赋值fun2(10, 20) # 10 20 1 3.不定长参数不定长参数：声明函数时，函数的参数不确定。 a.在声明函数时，参数名前加一个*，会将这个参数变成元组，来获取多个参数的值。通过位置参数调用 1234567# 声明一个函数，功能是求多个数的和def my_sum(*num): print(sum(num))# 调用参数是不定长参数的时候，不定长参数对应的位置，可以传任意个实参my_sum(1, 2, 3, 3, 5, 7, 8, 9, 40) # 78 集合才是无序可变且不重复 b.在声明函数时，参数名前加两个*，会将这个参数变成字典，来获取多个实参的值。必须使用关键字参数1234567def fun4(**kwargs): print(kwargs) # 字典# fun4(1, 2, 4) 位置参数调用，报错# 如果是调用不定长参数，调用时关键字可以随便命名。fun4(a=1, b=3, c=8, j=9) # &#123;'a': 1, 'b': 3, 'c': 8, 'j': 9&#125; c.（args, kwargs） - 用来表示不定长参数，调用时更灵活，可用位置参数也可用关键字参数或两者一起传参数。 注意：*args 必须放在 **kwargs之前，应为前者为位置参数，后者为关键字参数。1234567891011121314151617181920212223def func5(*args, **kwargs): print(args, kwargs)func5() # () &#123;&#125;func5(6, 7, 8) # (6, 7, 8) &#123;&#125;func5(a=6, b=7, c=8) # () &#123;'a': 6, 'b': 7, 'c': 8&#125;func5(6, 7, 8, a=6, b=7, c=8) # (6, 7, 8) &#123;'a': 6, 'b': 7, 'c': 8&#125;# 练习：求多个数的和，要求调用函数时可以多样性（位置，关键字）def my_sum(*args, **kwargs): sum1 = 0 for key in kwargs: sum1 += kwargs[key] print(sum(args)+sum1)my_sum() # 0my_sum(6, 7, 8) # 21my_sum(a=6, b=7, c=8) # 21my_sum(6, 7, 8, a=6, b=7, c=8) # 42 4.参数类型说明参数类型说明只是对参数类型进行提示，并不能限制参数类型。可弹出语法提示。 a.设置默认值 b.参数名：类型名注意：类型说明除了说明类型外，还可以做相应类型对应的语法提示。12345def func7(a: str, b=''): # 都能给类型说明 print(a, b)func7(1, '2') # 只能提示，不能限制。 #9.3 函数的返回值 1.返回值 a.函数的返回值就是return关键字后面表达式的值，就是函数调用表达式的值。 b.python中所有函数都有返回值，默认为None。return - 关键字；用来返回返回值；结束函数（当函数在执行过程中遇到了return就会结束函数），如果函数体中没有return，函数会在函数体执行完成后将None作为返回值。函数调用表达式 - 就是调用函数的语句（如：func1(1, 2)）；当函数调用完成后，函数调用表达式的结果就是函数返回值。看一个函数返回值，就是看return后面的值，没有return则为None。123456789101112131415161718def func1(m, n): print(m, n) # 将100作为函数func1的返回值 return 100 # return - 关键字 100 - 返回值def func2(m, n): return m + ndef func3(m, n): return # 相当于return None；将None作为返回值 print() # 执行不到func2(1, 2) # 3,需要被接收或直接使用print(func1(1, 2)) # None 即返回值 返回值作用：就是将函数内产生的数据传递出来，防止在函数调用完成后被销毁。什么时候使用返回值：如果实现函数功能后需要获取产生的数据则需要返回。 2.同时返回多个值 python中支持返回多个值，实质是以元组形式返回。元组的功能它都有。return 返回值1，返回值2，返回值3… 12345678910111213# 求多个数的和以及平均值def func7(*args): # sum1 = 0 # for item in args: # sum1 += item sum1 = sum(args) aver = sum1/len(args) return sum1, aversum1, aver = func7(1, 2, 3, 4, 5) # 常用print('和为%d，平均值为%.2f' % (sum1, aver)) # 和为15，平均值为3.00print('和为%d，平均值为%.2f' % func7(1, 2, 3, 4, 5)) # 和为15，平均值为3.00 #9.4 返回值的应用返回值能做的事情，函数调用表达式都可以做。123456789101112131415161718192021222324252627282930313233343536373839#1.用函数调用表达式给变量赋值def func1(): return 'hello'str1 = func1()# 2.通过函数调用表达式使用相应的方法。def func2(): return [1, 2, 3]item1 = func2()[0] # 1item2 = func1()[0] # hitem3 = func2().append(3) # None，获取的是append函数的返回值list1 = func2()list1.append(3)print(list1) # [1, 2, 3]# 3.将函数调用表达式作为容器的元素，函数的参数，函数的返回值def func3(): return 100def func4(x): print(x)# 作为函数实参func4(func3()) # 100re = func4(func3()) # 返回None之前要打印一次func3()print(re)# 作为列表元素# 作为字典的key和value# 作为函数返回值 #9.5 匿名函数匿名函数还是函数，除了声明语法以外，函数其他语法匿名函数都支持。 匿名函数声明 语法：函数名（变量名） = lambda 参数列表：返回值 说明：函数名 - 变量名lambda - 关键字参数列表 - 和普通函数参数列表作用和要求是一样的，但此处至少要1个参数返回值 - 相当于普通函数return关键字后面的表达式。注意：匿名函数中冒号后的语句属于函数体。在声明时不会执行匿名函数调用和普通函数一模一样。123456789101112# 匿名函数求两数和my_sum = lambda x, y: x + yprint(my_sum(1, 2))print(my_sum(y=2, x=3)) # 5 关键字参数# sort()函数定制# 写一个函数，求两数中最大值my_max = lambda x, y: max(x, y)print(my_max(1, 2)) # 2 补充：python中的3目运算符 c语言： 条件语句？值1：值2 - 条件语句为True则整个表达式结果为值1，反之。 python中三目： 值1 if 条件语句 else 值2 - 条件语句为True则整个表达式结果为值1，反之。123456789x, y = 10, 20max1 = 10 if x &gt; y else yprint(max1)# 写一个匿名函数，获取字典中指定key对应的值dict1 = &#123;'a': 1&#125;my_get_value = lambda key, dict2: dict2.get(key)print(my_get_value('a', dict1))","categories":[],"tags":[]},{"title":"","slug":"day5-提升作业","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day5-提升作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day5-提升作业/","excerpt":"","text":"1.控制台输入年龄，根据年龄输出不同的提示(例如:老年人，青壮年，成年人，未成年，儿童)年龄段程序：123456789101112131415161718192021222324#1.控制台输入年龄，根据年龄输出不同的提示(例如:老年人，青壮年，成年人，未成年，儿童)\"\"\"1、童年。0岁-6岁(周岁，下同) (1)婴儿期0-3周月;(2)小儿期4周月-2、5岁; (3)幼儿期2、5岁后-6岁;2、少年。7岁-17岁。(1)启蒙期7岁-10岁; (2)逆反期11岁-14岁; (3)成长期15岁-17岁。3、青年。18岁-40岁。(1)青春期18-28岁; (2)成熟期29-40岁;4、中年。41-65岁。(1)壮实期41-48岁; (2)稳健期49-55岁;(3)调整期56-65岁;5、老年。66岁以后。(1)初老期67-72岁;(2)中老期73-84岁;(3)年老期85岁以后。\"\"\"age = int(input('请输入要查询的年龄：'))if 0 &lt;= age &lt;= 6: print('儿童')elif age &lt;= 17: print('未成年')elif age &lt;= 40: print('青年')elif age &lt;= 65: print('中年')else: print('老年') 结果： 2.计算5的阶乘 5!的结果是程序：1234567#2.计算5的阶乘 5!的结果是num = 5jie_cheng = 1for _ in range(1, 5): jie_cheng *= num num -= 1print('5!的结果是:', jie_cheng) 结果： 3.求1+2!+3!+…+20!的和 1.程序分析：此程序只是把累加变成了累乘。程序：12345678910#3.求1+2!+3!+...+20!的和 1.程序分析：此程序只是把累加变成了累乘。sum1 = 0for i in range(1, 21): jie_cheng = 1#每计算一次阶乘需要将累计的阶乘重置，否则变为1！+2！*1！+1！*2！*3*+。。。 for j in range(1, i+1): jie_cheng *= j #print(jie_cheng) 测试每次输出的阶乘值 sum1 += jie_chengprint('1+2!+3!+...+20!的和为：\\n', sum1) 结果： 4.计算 1+1/2!+1/3!+1/4!+…1/20!=？程序：123456789#4.计算 1+1/2!+1/3!+1/4!+...1/20!=？sum1 = 0for i in range(1, 21): jie_cheng = 1 #每次初始化 for j in range(1, i+1): jie_cheng *= j sum1 += 1/jie_chengprint('1+1/2!+1/3!+1/4!+...1/20!= %.3f' %(sum1)) 结果： 5.循环输入大于0的数字进行累加，直到输入的数字为0，就结束循环，并最后输出累加的结果。程序：1234567891011#5.循环输入大于0的数字进行累加，直到输入的数字为0，就结束循环，并最后输出累加的结果。l = []sum1 = 0n = float(input('请输入一个数字：'))while n: if n &gt; 0: l.append(n) sum1 += n n = float(input('请输入一个数字：'))print('输入数字中大于0的有：\\n', l, '他们的和为：', sum1) 结果： 6.求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 1.程序分析：关键是计算出每一项的值。程序：1234567891011121314151617\"\"\"6.求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。 1.程序分析：关键是计算出每一项的值。\"\"\"n = int(input('请输入需要相加的数字个数（正整数）：'))a = int(input('请输入一个a的值（正整数）：'))sum1 = 0 # 放外面，防止初始化l = []for j in range(1, n+1): dan_xiang = 0 # 每次求出单项值需要初始化 for i in range(1, j+1): dan_xiang += a*10**(i-1) # 求出每一项的值 l.append(dan_xiang) sum1 += dan_xiang # 计算总和print('此时算式各单项如下：\\n', l, '它们的和为：', sum1) 结果： 7.输入三个整数x,y,z，请把这三个数由小到大输出。程序：1234567891011#7.输入三个整数x,y,z，请把这三个数由小到大输出。x = int(input('请输入第一个整数：'))y = int(input('请输入第二个整数：'))z = int(input('请输入第三个整数：'))list1 = [x, y, z]for i in range(0, 3): for j in range(0, 2-i): # 比较次数为长度减1再减去已比较过的次数 if list1[j] &gt; list1[j+1]: list1[j], list1[j+1] = list1[j+1], list1[j] #互换print(list1) 结果： 8.控制台输出三角形 1234567891011121314a.根据n的值的不同，输出相应的形状n = 5时 n = 4***** ******** ****** **** **b.根据n的值的不同，输出相应的形状(n为奇数)n = 5 n = 7 * * *** ******** ***** ******* 程序a：12345#a.根据n的值的不同，输出相应的形状n = int(input('请输入一个正整数：'))while n: print('*'*n) n -= 1 结果：程序b：123456#b.根据n的值的不同，输出相应的形状(n为奇数)n = int(input('请输入一个奇数：'))hang = (n+1)//2 # 注意结果不能为浮点数for i in range(1, hang+1): print(' '*(hang-i), '*'*(2*i-1))print() 结果： 9.输出9*9口诀。 1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。程序：12345#9.输出9*9口诀。 1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。for i in range(1, 10): for j in range(1, i+1): print((str(j)+'×'+str(i)+'='+str(i*j)),end='\\t') print() 结果： 10.这是经典的”百马百担”问题，有一百匹马，驮一百担货，大马驮3担，中马驮2担，两只小马驮1担，问有大，中，小马各几匹？程序：12345678910#10.这是经典的\"百马百担\"问题，有一百匹马，驮一百担货，大马驮3担，中马驮2担，两只# 小马驮1担，问有大，中，小马各几匹？print('所有可能的情况如下：')for big_horse in range(0, 33): for small_horse in range(0, 101): for mid_horse in range(0, 49): if (big_horse + small_horse + mid_horse == 100 and 6*big_horse + 4*mid_horse + small_horse == 200): print('大马%d,中马%d,小马%d' %(big_horse, mid_horse, small_horse)) 结果： 11.我国古代数学家张邱建在《算经》中出了一道“百钱买百鸡”的问题，题意是这样的： 5文钱可以买一只公鸡，3文钱可以买一只母鸡，1文钱可以买3只雏鸡。现在用100文钱买100只鸡，那么各有公鸡、母鸡、雏鸡多少只？请编写程序实现。程序：123456789101112\"\"\"11.我国古代数学家张邱建在《算经》中出了一道“百钱买百鸡”的问题，题意是这样的：5文钱可以买一只公鸡，3文钱可以买一只母鸡，1文钱可以买3只雏鸡。现在用100文钱买100只鸡，那么各有公鸡、母鸡、雏鸡多少只？请编写程序实现。\"\"\"print('所有可能的情况如下：')for gong_ji in range(0, 20): for xiao_ji in range(0, 101): for mu_ji in range(0, 33): if (gong_ji + xiao_ji + mu_ji == 100 and 15*gong_ji + 9*mu_ji + xiao_ji == 300): print('公鸡%d,母鸡%d,雏鸡%d' %(gong_ji, mu_ji, xiao_ji)) 结果： 12.小明单位发了100元的购物卡，小明到超市买三类洗化用品，洗发水（15元），香皂（2元），牙刷（5元）。要把100元整好花掉，可如有哪些购买结合？程序：1234567print('所有可能的情况如下：')for xi_fa_shui in range(1, 7): #(100-2-5)/15 for xiang_zao in range(1, 41): #(100-15-5)/2 for ya_shua in range(1, 17): #(100-15-2)/5 if 15*xi_fa_shui + 5*ya_shua + 2*xiang_zao == 100: print('洗发水%d,牙刷%d,香皂%d' %(xi_fa_shui, ya_shua, xiang_zao)) 结果： 所有可能的情况如下：洗发水0,牙刷16,香皂10洗发水0,牙刷14,香皂15洗发水0,牙刷12,香皂20洗发水0,牙刷10,香皂25洗发水0,牙刷8,香皂30洗发水0,牙刷6,香皂35洗发水0,牙刷4,香皂40洗发水1,牙刷15,香皂5洗发水1,牙刷13,香皂10洗发水1,牙刷11,香皂15洗发水1,牙刷9,香皂20洗发水1,牙刷7,香皂25洗发水1,牙刷5,香皂30洗发水1,牙刷3,香皂35洗发水1,牙刷1,香皂40洗发水2,牙刷12,香皂5洗发水2,牙刷10,香皂10洗发水2,牙刷8,香皂15洗发水2,牙刷6,香皂20洗发水2,牙刷4,香皂25洗发水2,牙刷2,香皂30洗发水3,牙刷9,香皂5洗发水3,牙刷7,香皂10洗发水3,牙刷5,香皂15洗发水3,牙刷3,香皂20洗发水3,牙刷1,香皂25洗发水4,牙刷6,香皂5洗发水4,牙刷4,香皂10洗发水4,牙刷2,香皂15洗发水5,牙刷3,香皂5洗发水5,牙刷1,香皂10","categories":[],"tags":[]},{"title":"","slug":"day7-容器类型","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day7-容器类型/","link":"","permalink":"http://yoursite.com/2018/12/21/day7-容器类型/","excerpt":"","text":"#7.1 列表相关方法 ##7.1.1 列表赋值 a.直接使用一个列表变量给另一个列表变量赋值，赋的是地址。 赋完值之后，对其中一个列表进行增删改，会影响另一个列表b.如果赋值的时候赋的列表的切片或者拷贝,会产生新的地址，然后使用新的地址赋值。赋完值之后，两个列表相互之间不影响1234567891011121314# 现象1：list1 = [1, 2, 3]list2 = list1list2.append(100)print(list1) # [1, 2, 3, 100]list1 = [1, 2, 3]list2.append(200)print(list1)# 现象2：list1 = [1, 2, 3]list2 = list1[:]list2.append(100)print(list1) # [1, 2, 3] ##7.1.2 列表中的方法 1.列表.count(元素) - 获取指定元素在列表中出现的次数12numbers = [100, 34, 90, 89, 100, 7, 100, 18]print(numbers.count(100)) 2.列表.extend(序列) - 将序列中所有的元素都添加到列表中123456numbers.extend(['abc', 'hello'])print(numbers)numbers.extend('world')print(numbers)numbers.extend(range(11, 15))print(numbers) 3.列表.index(元素) - 获取指定元素的下标注意:a.如果元素有多个，只去第一个的下标b.如果这个元素不存在，会报错(ValueError)123numbers = [3, 1, 2, 3, 4, 5, 3]print(numbers.index(3)) # 0# print(numbers.index(33)) # ValueError: 33 is not in list 4.列表.reverse() - 反向列表(将列表元素倒序)123numbers = [19, 89, 2, 8, 98, 10, 32]numbers.reverse()print(numbers) 5.列表.sort() - 对列表进行升序排序(从小到大)列表.sort(reverse=True) - 对列表进行降序排序(从大到小)注意：列表的要求：a.列表的元素类型必须一样 b.元素支持比较运算符1234567891011numbers = [19, 89, 2, 8, 98, 10, 32]numbers.sort()print(numbers)numbers = [19, 89, 2, 8, 98, 10, 32]numbers.sort(reverse=True)print(numbers)names = ['路飞', '娜美', '山治', '罗宾', '弗兰克', '乔巴', '佐罗']names.sort()print(names) 6.列表.clear() - 清空列表12345678names = ['路飞', '娜美', '山治', '罗宾', '弗兰克', '乔巴', '佐罗']names.clear()print(names)# 注意: 清空列表尽量使用clear()# names = ['路飞', '娜美', '山治', '罗宾', '弗兰克', '乔巴', '佐罗']# names = []# print(names) 7.列表.copy() - 将列表中元素直接赋值一份产生一个新的列表。和列表[:]效果一样.注意: 这儿的拷贝是浅拷贝1234list1 = [1, 2, 3]list2 = list1.copy()print(list2)print(list1 is list2) # False #7.2 浅拷贝和深拷贝 import copycopy.copy(对象) - 浅拷贝 （直接拷贝元素的值产生一个新的地址）copy.deepcopy(对象) - 深拷贝(不会直接复制地址，而是将地址对应的值拷贝一份产生新的地址)123456789101112131415161718192021222324252627numbers1 = [1, 2, 3]numbers2 = [10, 20, 30]list1 = [numbers1, numbers2]print('1.浅拷贝：')list2 = list1.copy()print('修改前list1:', list1)print('修改前list2:', list2)print('针对list1进行修改')list1.append(111)list1[0].append(100)print('修改后list1:', list1)print('修改后list2:', list2)numbers1 = [1, 2, 3]numbers2 = [10, 20, 30]list1 = [numbers1, numbers2]print('2.深拷贝')list2 = copy.deepcopy(list1)print('修改前list1:', list1)print('修改前list2:', list2)print('针对list1进行修改')list1.append(111)list1[0].append(100)print('修改后list1:', list1)print('修改后list2:', list2) #7.3 元组 1.什么是元祖（tuple）元祖就是不可变的列表。（有序，不可变）有序 - 可以通过下标获取元素不可变 - 不支持增、删、改2.元祖的字面量: 通过小括号将多个元素括起来，多个元素之间用逗号隔开1234567891011121314151617181920212223242526272829303132333435363738394041424344tuple1 = (1, True, 'abc', [1, 2], 1)print(tuple1)# a.只要一个元素的元祖: 在元素的后面必须加一个逗号tuple2 = (10,)print(tuple2, type(tuple2))# b.直接将多个数据用逗号隔开，不用括号括起来。还是一个元祖值tuple3 = 1, 2, 3, 'abc'print(tuple3, type(tuple3))# c.获取元祖元素tuple4 = (10, 20)print(tuple4[0], tuple4[-2])# 可以通过变量个数和元祖元素个数保持一致来获取元祖中的每个元素x, y = tuple4 # x, y = 10, 20print(x, y)# 通过在变量名前加*,获取没有*的变量获取到的元素的剩下的部分。以列表的形式返回tuple5 = ('余婷', 98, 90, 99, 87, 78)name, *scores = tuple5print(name, scores) # '余婷' [98, 90, 99, 87, 78]name, number, *scores = tuple5print(name, number) # '余婷' 98print(scores) # [90, 99, 87, 78]*list1, num = tuple5print(list1, num) # ['余婷', 98, 90, 99, 87] 78num1, *list1, num2 = tuple5print(num1, num2) # 余婷 78print(list1) # [98, 90, 99, 87]# (了解)tuple1 = (1, 2, 3)print(*tuple1)list1 = ['aa', 'bb', 'cc']# a = list1[0]# b = list1[1]# c = list1[2]# *list1 == a b cprint(*list1) 3.获取元祖元素和列表获取列表回去列表元素一模一样123456tuple1 = 1, 2, 3, 4, 5print(tuple1[1])print(tuple1[:3])for item in tuple1: print(item) 4.相关运算和列表一样+, *, in/not in, len(), tuple(), max(), min()123456print((1, 2) + ('a', 'n'))print((1, 2) * 3)print(1 in (1, 2))print(len((1, 2, 4)))print(max((1, 89, 0)))print(min((1, 89, 0))) 5.元祖相关的方法： 只有列表中的count和index #7.4 认识字典 1.什么是字典（dict）字典是python中内置的容器类的数据类型,可变，无序的。字典的元素是键值对 2.字典的字面量：使用大括号括起来，大括号中是键值对，多个键值对之间用逗号隔开键值对- 键:值键(key) - 不可变的；唯一的 (一般使用字符串作为key)值(value) - 任何类型的数据12345678dict1 = &#123;&apos;aa&apos;: 100, 10: &apos;abc&apos;, (10, 20): &apos;hello&apos;&#125;# 列表和字典不能作为key# dict2 = &#123;&#123;&apos;a&apos;: 1&#125;: 100, 10: &apos;abc&apos;, (10, 20): &apos;hello&apos;&#125; # TypeError# key是唯一的dict2 = &#123;&apos;aa&apos;: 100, &apos;aa&apos;: 200, &apos;bb&apos;: 300&#125;print(dict2) # &#123;&apos;aa&apos;: 200, &apos;bb&apos;: 300&#125; 什么时候使用字典:如果一个容器里面存储的数据是不同意义的数据(数据之间需要区分),就使用字典1234567# 用一个变量来存储一个学生的信息：姓名、年龄、电话、成绩、学号student = ['小明', 28, '1627399992', 30, '1982001', 98]print(student[0])student = &#123;'name': '小明', 'age': 28, 'tel': '1627399992', 'score': 30, '学号':'1982001'&#125;print(student['name']) #7.5 字典的增删改查 #7.5.1 查(获取字典的值) a.获取单个值字典[key] - 获取字典中key对应的值 (注意：如果key不存在，会报错:KeyError字典.get(key) - 获取字典中key对应的值 (如果key不存在，不会报错，并且会返回一个默认值None)None是python中的关键字，表示一个特殊值，(没有、空的意思)12345678dog1 = &#123;'name': '旺财', 'age': 3, 'color': '黄色', 'type': '土狗'&#125;print(dog1['name'])print(dog1['color'])# print(dog1['sex']) # KeyError: 'sex'print(dog1.get('age'))print(dog1.get('type'))print(dog1.get('sex')) b.遍历12345678# 直接遍历字典拿到的是字典中所有的keyfor key in dog1: print(key, dog1[key])# 同时获取key和value（看着方便但是性能差，内存消耗多）print(dog1.items())for key, value in dog1.items(): print(key, value) #7.5.2 增(添加键值对) 字典[key] = 值 - 当key不存的时候，就是在字典中添加键值对123dict1 = &#123;'a': 100&#125;dict1['b'] = 200print(dict1) 字典1.update(序列) - 将序列中的元素转换成键值对，然后再添加到字典1中。注意:在这儿的序列要求是能够转换成字典的序列。序列中的元素是只有两个元素的小序列12345678910dict1 = &#123;'a': 100, 'b': 200&#125;# 当key值有重名的时候，会用序列中键值对对应的值，更新原字典的key对应的值dict1.update(&#123;'aa': 10, 'bb': 20, 'a': 'abc'&#125;)print(dict1)dict1.update([[1, 2], ['a', 2], [2, 'b']])print(dict1)dict1.update([('aaa', 100), [12, 200]])print(dict1) ##7.5.3 改(修改key对应的值) 字典[key] = 值 - 当key存在的时候，就是修改key对应的值123dict1 = &#123;'a': 10, 'b': 20&#125;dict1['a'] = 100print(dict1) 7.5.4 删(删除键值对) a. del 字典[key] - 删除字典中key对应的键值对123person = &#123;'name': '张三', 'age': 30, 'sex': '男'&#125;del person['sex']print(person) b.字典.pop(key) - 取出字典中key对应的值（删除整个键值对）12345678person = &#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 30, &apos;sex&apos;: &apos;男&apos;&#125;age = person.pop(&apos;age&apos;)print(person, age)person = &#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 30, &apos;sex&apos;: &apos;男&apos;&#125;# 删除最后一个键值对(取出最后一个键值对, 以元祖的形式返回) - 无意义value = person.popitem()print(person, value) #7.6 字典的相关运算和方法 1.字典不支持+和* in 和 not inkey in 字典 - 判断字典中是否存在指定的key12dict1 = &#123;'a': 12, 'b': 20, 'c': 30&#125;print('a' in dict1)","categories":[],"tags":[]},{"title":"","slug":"day6-列表作业","date":"2018-12-21T01:34:21.316Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day6-列表作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day6-列表作业/","excerpt":"","text":"1.已知一个列表，求列表中心元素。12345678#1.已知一个列表，求列表中心元素。 ]l1 = [1, 2, 'abc', 4, 5]#l2 = [213, 'a', 'b', 321]if len(l1) &amp; 1: print('l1的中心元素为：', l1[len(l1)//2])else: print('l1的中心元素有两个，它们为：', l1[len(l1)//2 - 1], l1[len(l1)//2]) print('l1的中心元素有两个，它们为：', l1[len(l1) &gt;&gt; 1 - 1], l1[len(l1) &gt;&gt; 1]) 结果： 2.已知一个列表，求所有元素和。123#2.已知一个列表，求所有元素和。list1 = [1, 2, 3, 4]print(sum(list1)) # 10 3.已知一个列表，输出所有奇数下标元素。12345#3.已知一个列表，输出所有奇数下标元素。list1 = [1, 2, 3, 4, 5, 6, 7, 8]for i in range(len(list1)): if i &amp; 1: print(list1[i], end='\\t') 1234#3.已知一个列表，输出所有奇数下标元素。list1 = [1, 2, 3, 4, 5, 6, 7, 8]for i in range(1, len(list1), 2): print(list1[i], end='\\t') 结果： 4.已知一个列表，输出所有元素中，值为奇数的。12345#4.已知一个列表，输出所有元素中，值为奇数的。list1 = ['a', 33, 'b', 55, 88]for i in range(len(list1)): if isinstance(list1[i], int) and (list1[i] &amp; 1): print(list1[i], end='\\t') 结果： 5.已知一个列表，将所有元素乘二。123456#5.已知一个列表，将所有元素乘二。list1 = [1, 'a', 2, 'b']for i in range(len(list1)): list1[i] = list1[i]*2 # list1[i] *= 2print(list1) 结果： 6.有一个长度是10的列表，数组内有10个人名，要求去掉重复的例如:names = [‘张三’, ‘李四’, ‘大黄’, ‘张三’] -&gt; names = [‘张三’, ‘李四’, ‘大黄’]12345678910111213141516171819#6.有一个长度是10的列表，数组内有10个人名，要求去掉重复的 例如:# names = ['张三', '李四', '大黄', '张三'] -&gt; names = ['张三', '李四', '大黄']# 1names = ['张三', '李四', '大黄', '张三', '李四', '大黄', '小明', '大黄', '小狗', '小二郎']i = 0count = 0while i &lt; len(names)-count: j = i + 1 while j &lt; len(names): if names[i] == names[j]: names.pop(j) count += 1 # 弹出多少个，长度就需减去多少 continue # 弹出一个元素，下次还需从这元素下标开始 j += 1 i += 1print(names) 1234567#2集合names = ['张三', '李四', '大黄', '张三', '李四', '大黄', '小明', '大黄', '小狗', '小二郎']set_names = set(names)names = list(set_names)print(names) 123456789#3names = ['张三', '李四', '大黄', '张三', '李四', '大黄', '小明', '大黄', '小狗', '小二郎']new_names = []for item in names: if item not in new_names: new_names.append(item)print(new_names) 12345678910#4names = ['张三', '李四', '大黄', '张三', '李四', '大黄', '小明', '大黄', '小狗', '小二郎']for item in names.copy(): # 防止取不到，也能防止下标越界 count = names.count(item) if count &gt; 1: names.remove(item)print(names) 结果： 7.已知一个数字列表(数字大小在0~6535之间), 将列表转换成数字对应的字符列表例如: list1 = [97, 98, 99] -&gt; list1 = [‘a’, ‘b’, ‘c’]123456789\"\"\"7.已知一个数字列表(数字大小在0~65535之间), 将列表转换成数字对应的字符列表例如: list1 = [97, 98, 99] -&gt; list1 = ['a', 'b', 'c']\"\"\"list1 = [97, 98, 99, 120, 130, 446, 487, 619]for i in range(len(list1)): list1[i] = chr(list1[i])print(list1) 结果： 8.用一个列表来保存一个节目的所有分数，求平均分数(去掉一个最高分，去掉一个最低分，求最后得分)123456#8.用一个列表来保存一个节目的所有分数，求平均分数# (去掉一个最高分，去掉一个最低分，求最后得分)scores = [55.5, 65.6, 77.7, 33.2, 88.8, 88.8, 88.8]scores.remove(max(scores)) # 删除遇到的第一个等于max(scores)的值scores.remove(min(scores))print('平均成绩为：%.2f' %(sum(scores)/len(scores))) 结果： 9.有两个列表A和B，使用列表C来获取两个列表中公共的元素例如: A = [1, ‘a’, 4, 90] B = [‘a’, 8, ‘j’, 1] –&gt; C = [1, ‘a’]1234567891011# 9.有两个列表A和B，使用列表C来获取两个列表中公共的元素# 例如: A = [1, 'a', 4, 90] B = ['a', 8, 'j', 1] --&gt; C = [1, 'a']A = [1, 'a', 4, 90]B = ['a', 8, 'j', 1]C = []for i in range(len(A)): for j in range(len(B)): if i == j: C.append(i)print(C) 结果：","categories":[],"tags":[]},{"title":"","slug":"day5-分支和循环作业","date":"2018-12-21T01:34:21.309Z","updated":"2018-12-21T01:31:35.000Z","comments":true,"path":"2018/12/21/day5-分支和循环作业/","link":"","permalink":"http://yoursite.com/2018/12/21/day5-分支和循环作业/","excerpt":"","text":"读程序，总结程序的功能:1.1234numbers=1for i in range(0,20): numbers*=2print(numbers) 输出2^20次方的值2.1234567summation=0num=1while num&lt;=100: if (num%3==0 or num%7==0) and num%21!=0: summation += 1 num +=1print(summation) 求1~100内所有能被3或7整除但不能被21整除的数个数 编程实现(for和while各写⼀遍): 求1到100之间所有数的和、平均值 程序：123456789101112131415#求1到100之间所有数的和、平均值# forsum1 = 0for num in range(1,101): sum1 += numprint('1~100之间所有整数的和为：%d\\n' %(sum1),'平均值为：%.2f' %(sum1/100))print('*'*30)# whilenum2 = 0sum2 = 0while num2 &lt;= 100: sum2 += num2 num2 += 1print('1~100之间所有整数的和为：%d\\n' %(sum2),'平均值为：%.2f' %(sum2/100)) 结果： 计算1-100之间能3整除的数的和程序：1234567891011121314151617#2. 计算1-100之间能被3整除的数的和# forsum1 = 0for num in range(1,101): if num % 3 == 0: sum1 += numprint('1-100之间能被3整除的数的和为：%d\\n' %(sum1))print('*'*30)# whilenum2 = 0sum2 = 0while num2 &lt;= 100: if num2 % 3 == 0: sum2 += num2 num2 += 1print('1-100之间能被3整除的数的和为：%d\\n' %(sum2)) 结果： 计算1-100之间不能被7整除的数的和程序：1234567891011121314151617#3. 计算1-100之间不能被7整除的数的和# forsum1 = 0for num in range(1,101): if num % 7 != 0: sum1 += numprint('1-100之间不能被7整除的数的和为：%d\\n' %(sum1))print('*'*30)# whilenum2 = 0sum2 = 0while num2 &lt;= 100: if num2 % 7 != 0: sum2 += num2 num2 += 1print('11-100之间不能被7整除的数的和为：%d\\n' %(sum2)) 结果： 求斐波那契数列中第n个数的值： 1， 1， 2， 3， 5， 8， 13， 21， 34….程序：12345678910111213141516171819202122#1. 求斐波那契数列中第n个数的值： 1， 1， 2， 3， 5， 8， 13， 21， 34....# 方法1：n = int(input('请输入您要获得斐波那契数列中第几个数的值：\\n'))n1 = n2 = 1if n &lt; 3: print(1)else: for _ in range(0, n-2): n3 = n1 + n2 n1, n2 = n2, n3 print('本斐波那契数列中第%d个数的值为：%d' % (n, n3))print('*'*50)# 方法2：list1 = [1, 1]n1 = n2 = list1[0]for _ in range(0, n-2): n3 = n1 + n2 n1, n2 = n2, n3 list1.append(n3)print('本斐波那契数列中第%d个数的值为：%d' %(n, list1[n-1])) 结果： 判断101-200之间有多少个素数，并输出所有素数。判断素数的⽅法：⽤⼀个数分别除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。程序：12345678910111213141516171819\"\"\"2. 判断101-200之间有多少个素数，并输出所有素数。判断素数的⽅法：⽤⼀个数分别除以2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。\"\"\"print('101~200之间所有的素数打印如下：')sum1 = 0for i in range(101,201): n = int(i**0.5) # sqrt(i) for j in range(2, n+1): if i % j != 0: if j == n: sum1 += 1 print(i,end='\\t') else: continue else: breakprint('共%d个' %(sum1)) 123456for num in range(101,201): for x in range(2, num): if num % x == 0: break else: # 自然死亡才执行 print(num, '是素数') 123456789for num in range(101, 201): count = 0 for x in range(2, num): if num % x == 0: count += 1 breakif count == 0: print(num, '是素数') 结果： 打印出所有的⽔仙花数,所谓⽔仙花数是指⼀个三位数，其各位数字⽴⽅和等于该数本身。例如： 153是⼀个⽔仙花数,因为153 = 1^3 + 5^3 + 3^3程序：12345678910111213\"\"\"3. 打印出所有的⽔仙花数,所谓⽔仙花数是指⼀个三位数，其各位数字⽴⽅和等于该数本身。例如： 153是⼀个⽔仙花数,因为153 = 1^3 + 5^3 + 3^3\"\"\"print('所有三位数的水仙花数为：')for i in range(100, 1000): ge_wei = i % 10 shi_wei = i % 100 // 10 bai_wei = i // 100 if ge_wei**3 + shi_wei**3 +bai_wei**3 == i: print(i, end='\\t') else: continue 结果： 有⼀分数序列： 2/1,3/2,5/3,8/5,13/8,21/13…求出这个数列的第20个分数分⼦：上⼀个分数的分⼦加分⺟ 分⺟: 上⼀个分数的分⼦ fz = 2 fm = 1 fz+fm / fz程序：12345678910\"\"\"4. 有⼀分数序列： 2/1,3/2,5/3,8/5,13/8,21/13...求出这个数列的第20个分数分⼦：上⼀个分数的分⼦加分⺟ 分⺟: 上⼀个分数的分⼦ fz = 2 fm = 1 fz+fm / fz\"\"\"fz, fm = 2, 1for _ in range(1, 20): new_fz = fz + fm new_fm = fz fz, fm = new_fz, new_fmprint('这个数列的第20个分数为：', '%d/%d' %(fz, fm)) 结果： 给⼀个正整数，要求： 1、求它是⼏位数 2.逆序打印出各位数字程序：12345#5. 给⼀个正整数，要求： 1、求它是⼏位数 2.逆序打印出各位数字num1 = input('请输入一个正整数：')wei_shu = len(num1)ni_xu = num1[::-1] # ni_xu = num1[-1:-wei_shu-1:-1]print('%s是一个%d位数，它的逆序打印为：' %(num1, wei_shu),ni_xu) 结果：","categories":[],"tags":[]}]}